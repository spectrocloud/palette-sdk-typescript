/**
 * Copyright (c) Spectro Cloud
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Palette APIs - 4.8
 * OpenAPI spec version: v1
 */
import type {
  APIEndpoint,
  AWSVolumeTypes,
  AlertEntity,
  AmiTypes,
  ApiKey,
  ApiKeyCreateResponse,
  ApiKeyEntity,
  ApiKeyUpdate,
  ApiKeys,
  AppDeployment,
  AppDeploymentClusterGroupEntity,
  AppDeploymentProfileEntity,
  AppDeploymentProfileSpec,
  AppDeploymentProfileVersions,
  AppDeploymentVirtualClusterEntity,
  AppDeploymentsFilterSpec,
  AppDeploymentsSummary,
  AppDeploymentsUidProfileApplyParams,
  AppProfile,
  AppProfileCloneEntity,
  AppProfileCloneMetaInputEntity,
  AppProfileMetaEntity,
  AppProfileTiers,
  AppProfilesFilterSpec,
  AppProfilesMetadata,
  AppProfilesSummary,
  AppTier,
  AppTierEntity,
  AppTierManifests,
  AppTierPatchEntity,
  AppTierResolvedValues,
  AsyncOperationIdEntity,
  Audit,
  AuditMsgUpdate,
  AuditSysMsg,
  Audits,
  AuditsListParams,
  AuthLogin,
  AuthOrgParams,
  AuthRefreshParams,
  AuthTokenRevoke,
  AuthTokenSettings,
  AuthenticateParams,
  AwsAccount,
  AwsAccountCredentials,
  AwsAccountSts,
  AwsAccounts,
  AwsAvailabilityZones,
  AwsCloudAccount,
  AwsCloudClusterConfigEntity,
  AwsCloudConfig,
  AwsCloudCostSpec,
  AwsCloudCostSummary,
  AwsCloudHybridConfigEntity,
  AwsCreditAccountEntity,
  AwsFindImageRequest,
  AwsImage,
  AwsInstanceTypes,
  AwsKeyPairs,
  AwsKmsKeyEntity,
  AwsKmsKeys,
  AwsMachine,
  AwsMachines,
  AwsPolicies,
  AwsPolicyArnsSpec,
  AwsPropertiesValidateSpec,
  AwsRegions,
  AwsS3BucketCredentials,
  AwsSecretSpecInputEntity,
  AwsSecurityGroups,
  AwsStorageTypes,
  AwsVolumeSize,
  AwsVpcs,
  AzValidateEntity,
  AzureAccount,
  AzureAccounts,
  AzureCloudAccount,
  AzureCloudConfig,
  AzureGroups,
  AzureInstanceTypes,
  AzureMachine,
  AzureMachines,
  AzurePrivateDnsZones,
  AzureRegions,
  AzureResourceGroupList,
  AzureStorageAccountEntity,
  AzureStorageAccounts,
  AzureStorageContainers,
  AzureStorageTypes,
  AzureSubscriptionList,
  AzureVhdUrlEntity,
  AzureVirtualNetworkList,
  AzureZoneEntity,
  BasicOciRegistriesCreateParams,
  BasicOciRegistriesUidSyncParams,
  BasicOciRegistry,
  BasicOciRegistrySpec,
  BulkDeleteRequest,
  BulkDeleteResponse,
  BulkEvents,
  Channel,
  CloudAccountUidEntity,
  CloudAccountsAwsGetParams,
  CloudAccountsAwsListParams,
  CloudAccountsAzureListParams,
  CloudAccountsCloudStackListParams,
  CloudAccountsCustomListParams,
  CloudAccountsGcpListParams,
  CloudAccountsListSummaryParams,
  CloudAccountsMaasListParams,
  CloudAccountsMetadata,
  CloudAccountsOpenStackListParams,
  CloudAccountsPatch,
  CloudAccountsSummary,
  CloudAccountsVsphereListParams,
  CloudConfigsAksPoolMachinesListParams,
  CloudConfigsAwsPoolMachinesListParams,
  CloudConfigsAzurePoolMachinesListParams,
  CloudConfigsCustomPoolMachinesListParams,
  CloudConfigsEksPoolMachinesListParams,
  CloudConfigsGcpPoolMachinesListParams,
  CloudConfigsGenericPoolMachinesListParams,
  CloudConfigsGkePoolMachinesListParams,
  CloudConfigsMaasPoolMachinesListParams,
  CloudConfigsVirtualPoolMachinesListParams,
  CloudConfigsVspherePoolMachinesListParams,
  CloudCost,
  CloudStackAccount,
  CloudStackAccountInputEntity,
  CloudStackAccountUpdateEntity,
  CloudStackAccounts,
  CloudStackCloudAccount,
  CloudStackCloudClusterConfigEntity,
  CloudStackCloudConfig,
  CloudStackDiskOfferings,
  CloudStackDomains,
  CloudStackKeypairs,
  CloudStackMachine,
  CloudStackMachines,
  CloudStackNetworks,
  CloudStackOfferings,
  CloudStackProjects,
  CloudStackTemplates,
  CloudStackVpcs,
  CloudStackZones,
  CloudstackAccountsUidDiskofferingsParams,
  CloudstackAccountsUidKeypairsParams,
  CloudstackAccountsUidNetworksParams,
  CloudstackAccountsUidOfferingsParams,
  CloudstackAccountsUidTemplatesParams,
  CloudstackAccountsUidVpcsParams,
  ClusterBackup,
  ClusterBackupLocationType,
  ClusterComplianceOnDemandConfig,
  ClusterComplianceScan,
  ClusterComplianceScanLogs,
  ClusterCondition,
  ClusterDefinitionEntity,
  ClusterEdgeInstallerConfig,
  ClusterFeatureBackupGetParams,
  ClusterFeatureDriverLogDownloadParams,
  ClusterFeatureKubeBenchLogGetParams,
  ClusterFeatureKubeHunterLogGetParams,
  ClusterFeatureLogFetcherGetParams,
  ClusterFeatureLogFetcherLogDownloadParams,
  ClusterFeatureLogFetcherLogUpdateBody,
  ClusterFeatureLogFetcherLogUpdateParams,
  ClusterFeatureRestoreGetParams,
  ClusterFeatureSonobuoyLogGetParams,
  ClusterGroup,
  ClusterGroupEntity,
  ClusterGroupHostClusterEntity,
  ClusterGroupUidHostClustersSummaryParams,
  ClusterGroupUidVirtualClustersSummaryParams,
  ClusterGroupsDeveloperCreditUsage,
  ClusterGroupsHostClusterMetadata,
  ClusterGroupsHostClusterSummary,
  ClusterGroupsUidProfilesGetParams,
  ClusterGroupsValidateNameParams,
  ClusterHelmCharts,
  ClusterHybridSettingsEntity,
  ClusterLogFetcher,
  ClusterLogFetcherRequest,
  ClusterManifests,
  ClusterMetaAttributeEntity,
  ClusterNamespaceResource,
  ClusterNamespaceResourceInputEntity,
  ClusterNamespaceResources,
  ClusterNamespaceResourcesUpdateEntity,
  ClusterNamespaces,
  ClusterNamespacesGetParams,
  ClusterNotificationUpdateEntity,
  ClusterProfile,
  ClusterProfileCloneEntity,
  ClusterProfileCloneMetaInputEntity,
  ClusterProfileEntity,
  ClusterProfileImportEntity,
  ClusterProfilePackConfigList,
  ClusterProfilePacksEntities,
  ClusterProfilePacksManifests,
  ClusterProfileSummary,
  ClusterProfileUpdateEntity,
  ClusterProfileValidatorResponse,
  ClusterProfilesCreateParams,
  ClusterProfilesDeleteParams,
  ClusterProfilesFilterSpec,
  ClusterProfilesFilterSummaryParams,
  ClusterProfilesGetParams,
  ClusterProfilesImportFileBody,
  ClusterProfilesImportFileParams,
  ClusterProfilesImportParams,
  ClusterProfilesMetadata,
  ClusterProfilesPacksRefUpdateParams,
  ClusterProfilesSummary,
  ClusterProfilesUidPacksAddParams,
  ClusterProfilesUidPacksConfigGetParams,
  ClusterProfilesUidPacksGetParams,
  ClusterProfilesUidPacksManifestsGetParams,
  ClusterProfilesUpdateParams,
  ClusterProfilesValidateNameVersionParams,
  ClusterRbac,
  ClusterRbacInputEntity,
  ClusterRbacResourcesUpdateEntity,
  ClusterRbacs,
  ClusterReconcile,
  ClusterRefs,
  ClusterRestore,
  ClusterRestoreConfig,
  ClusterScanLogKubeBench,
  ClusterScanLogKubeHunter,
  ClusterScanLogSonobuoy,
  ClusterScanLogSyft,
  ClusterSearchInputSpec,
  ClusterTemplate,
  ClusterTemplateEntity,
  ClusterTemplatePoliciesUpdateEntity,
  ClusterTemplateProfileVariablesResponse,
  ClusterTemplateProfilesUpdateEntity,
  ClusterTemplateProfilesVariablesBatchEntity,
  ClusterTemplateTags,
  ClusterTemplateUpgradeSpec,
  ClusterTemplateVariablesUpdateEntity,
  ClusterTemplatesFilterSummaryParams,
  ClusterTemplatesFilterSummarySpec,
  ClusterTemplatesMetadata,
  ClusterTemplatesSummary,
  ClusterUpgradeSettingsEntity,
  ClusterVMSnapshotsListParams,
  ClusterVirtualMachine,
  ClusterVirtualMachineList,
  ClusterVirtualPacksValues,
  ClusterWorkload,
  ClusterWorkloadCronJobs,
  ClusterWorkloadDaemonSets,
  ClusterWorkloadDeployments,
  ClusterWorkloadJobs,
  ClusterWorkloadNamespaces,
  ClusterWorkloadPods,
  ClusterWorkloadRoleBindings,
  ClusterWorkloadStatefulSets,
  ControlPlaneHealthCheckTimeoutEntity,
  CustomAccount,
  CustomAccountEntity,
  CustomAccounts,
  CustomCloudClusterConfigEntity,
  CustomCloudConfig,
  CustomCloudMetaEntity,
  CustomCloudRequestEntity,
  CustomCloudTypeCloudAccountKeys,
  CustomCloudTypeContentResponse,
  CustomCloudTypes,
  CustomMachine,
  CustomMachines,
  DashboardAppDeploymentsParams,
  DashboardAppProfilesParams,
  DashboardCloudAccountsMetadataParams,
  DashboardClustersSearchSummaryExportGetParams,
  DashboardClustersSearchSummaryExportParams,
  DashboardEdgehostsSearchParams,
  DashboardPcgsSearchSummaryParams,
  DashboardSpectroClustersRepaveListParams,
  DashboardWorkspaces,
  DataSinkConfig,
  DeletedMsg,
  DeveloperCredit,
  EcrRegistriesCreateParams,
  EcrRegistriesUidSyncParams,
  EcrRegistry,
  EcrRegistrySpec,
  EdgeHostClusterEntity,
  EdgeHostConfig,
  EdgeHostDevice,
  EdgeHostDeviceEntity,
  EdgeHostDeviceHostCheckSum,
  EdgeHostDeviceHostPairingKey,
  EdgeHostDeviceMetaUpdateEntity,
  EdgeHostDevices,
  EdgeHostDevicesUidGetParams,
  EdgeHostDevicesUidPackManifestsUidGetParams,
  EdgeHostDevicesUidProfilesGetParams,
  EdgeHostHealth,
  EdgeHostVsphereCloudProperties,
  EdgeHostsMeta,
  EdgeHostsMetadataFilter,
  EdgeHostsMetadataQuickFilterGetParams,
  EdgeHostsMetadataSummary,
  EdgeHostsSearchSummary,
  EdgeHostsTags,
  EdgeNativeCloudClusterConfigEntity,
  EdgeNativeCloudConfig,
  EdgeNativeMachine,
  EdgeNativeMachines,
  EdgeToken,
  EdgeTokenActiveState,
  EdgeTokenEntity,
  EdgeTokenUpdate,
  EdgeTokens,
  EksCloudClusterConfigEntity,
  EksCloudConfig,
  EksFargateProfiles,
  EksPropertiesValidateSpec,
  Event,
  Events,
  EventsComponentsListParams,
  EventsComponentsObjTypeUidListParams,
  FeatureUpdate,
  Features,
  FiltersListParams,
  FiltersMetadata,
  FiltersMetadataParams,
  FiltersSummary,
  FipsSettings,
  GcpAccount,
  GcpAccountNameValidateSpec,
  GcpAccounts,
  GcpCloudAccountValidateEntity,
  GcpCloudConfig,
  GcpImageUrlEntity,
  GcpInstanceTypes,
  GcpMachine,
  GcpMachines,
  GcpNetworks,
  GcpProjects,
  GcpPropertiesValidateSpec,
  GcpRegions,
  GcpStorageTypes,
  GcpZones,
  GenericCloudClusterConfigEntity,
  GenericCloudConfig,
  GenericMachine,
  GenericMachines,
  GeolocationLatlong,
  HelmRegistries,
  HelmRegistriesSummary,
  HelmRegistry,
  HelmRegistryEntity,
  HelmRegistrySpec,
  HostClusterConfigEntity,
  HybridEdgeNativeMachinePoolConfig,
  HybridEdgeNativeMachinePoolConfigEntity,
  HybridEdgeNativeMachinePoolConfigUpdateEntity,
  IdentityProviders,
  Invoice,
  IpPools,
  KubeBenchEntity,
  KubeHunterEntity,
  LifecycleConfigEntity,
  LoadBalancerService,
  LoginBannerSettings,
  LoginResponse,
  MaasAccount,
  MaasAccounts,
  MaasCloudAccount,
  MaasCloudClusterConfigEntity,
  MaasCloudConfig,
  MaasDomains,
  MaasMachine,
  MaasMachines,
  MaasPools,
  MaasSubnets,
  MaasTags,
  MaasZones,
  MachineCertificates,
  MachineMaintenance,
  MachineMaintenanceStatus,
  MachinePoolsMachineUids,
  Macros,
  Manifest,
  ManifestEntities,
  ManifestEntity,
  ManifestRefInputEntities,
  MetricTimeSeries,
  MetricTimeSeriesList,
  MetricsListParams,
  MetricsUidListParams,
  NotificationEvent,
  Notifications,
  NotificationsListParams,
  NotificationsObjTypeUidListParams,
  OciImageRegistry,
  OciRegistries,
  OciRegistriesGetParams,
  OciRegistryEntity,
  OpenStackAccount,
  OpenStackAccounts,
  OpenStackAzs,
  OpenStackCloudAccount,
  OpenStackCloudClusterConfigEntity,
  OpenStackCloudConfig,
  OpenStackFlavors,
  OpenStackKeypairs,
  OpenStackMachine,
  OpenStackMachines,
  OpenStackNetworks,
  OpenStackProjects,
  OpenStackRegions,
  OpenstackAccountsUidAzsParams,
  OpenstackAccountsUidFlavorsParams,
  OpenstackAccountsUidKeypairsParams,
  OpenstackAccountsUidNetworksParams,
  Organizations,
  OsPatchEntity,
  OverloadVsphereOva,
  Overlord,
  OverlordCloudStackAccountCreate,
  OverlordCloudStackAccountEntity,
  OverlordMaasAccountCreate,
  OverlordMaasAccountEntity,
  OverlordManifest,
  OverlordMigrateEntity,
  OverlordOpenStackAccountCreate,
  OverlordOpenStackAccountEntity,
  OverlordVsphereAccountCreate,
  OverlordVsphereAccountEntity,
  Overlords,
  OverlordsCloudStackManifestParams,
  OverlordsListParams,
  OverlordsOpenStackManifestParams,
  OverlordsPairingCodeParams,
  OverlordsUidCloudStackAccountValidateBody,
  OverlordsUidMaasAccountValidateBody,
  OverlordsUidOpenStackAccountValidateBody,
  OverlordsUidVsphereAccountValidateBody,
  OverlordsUidVsphereComputeclusterResParams,
  OverlordsVsphereManifestParams,
  PackInputEntity,
  PackManifests,
  PackMetadataList,
  PackReadme,
  PackRefSummaryResponse,
  PackRegistries,
  PackRegistriesSummary,
  PackRegistry,
  PackRegistrySpec,
  PackResolvedValues,
  PackSummaries,
  PackTagEntity,
  PackUpdateEntity,
  PacksFilterSpec,
  PacksNameRegistryUidListParams,
  PacksSearchParams,
  PacksSummaryListParams,
  PairingCode,
  PasswordResetRequestBody,
  PcgSelfHostedParams,
  PcgServiceKubectlCommands,
  PcgsSummary,
  Permissions,
  PermissionsListParams,
  ProfileMetaEntity,
  Project,
  ProjectActiveResources,
  ProjectAlertComponents,
  ProjectCleanup,
  ProjectClusterSettings,
  ProjectRolesEntity,
  ProjectTeamsEntity,
  ProjectUsersEntity,
  ProjectsFilterSpec,
  ProjectsFilterSummaryParams,
  ProjectsMetadata,
  ProjectsMetadataParams,
  ProjectsSummary,
  ProjectsUidDeleteParams,
  RateConfig,
  RegistriesHelmCreateParams,
  RegistriesHelmListParams,
  RegistriesHelmSummaryListParams,
  RegistriesHelmUidSyncParams,
  RegistriesMetadata,
  RegistriesMetadataParams,
  RegistriesPackCreateParams,
  RegistriesPackListParams,
  RegistriesPackSummaryListParams,
  RegistriesPackUidSyncParams,
  RegistryConfigEntity,
  RegistrySyncStatus,
  ResourceCostSummarySpec,
  ResourceRoles,
  ResourceUsageSummarySpec,
  ResourcesCloudCostSummary,
  ResourcesConsumption,
  ResourcesCostSummary,
  ResourcesUsageSummary,
  Role,
  RoleClone,
  Roles,
  RolesListParams,
  SearchFilterSchemaSpec,
  SectroClusterK8sDashboardUrl,
  ServiceManifest,
  ServiceManifestGetParams,
  ServiceVersion,
  ServiceVersionGetParams,
  SonobuoyEntity,
  SpcApply,
  SpcPatchTimeEntity,
  SpcPoliciesFilterSpec,
  SpcPoliciesFilterSummaryParams,
  SpcPoliciesMetadata,
  SpcPoliciesSummary,
  SpcPolicyEntity,
  SpcPolicyTags,
  SpectroAwsClusterImportEntity,
  SpectroAwsClusterRateEntity,
  SpectroAzureClusterImportEntity,
  SpectroCloudStackClusterImportEntity,
  SpectroCloudStackClusterRateEntity,
  SpectroCluster,
  SpectroClusterAssetEntity,
  SpectroClusterAssetFrpKubeConfig,
  SpectroClusterAssetKubeConfig,
  SpectroClusterAssetKubeConfigClient,
  SpectroClusterAssetManifest,
  SpectroClusterAssetTokenKubeConfig,
  SpectroClusterCloudCostSummarySpec,
  SpectroClusterCostSummary,
  SpectroClusterHeartbeat,
  SpectroClusterHybridPoolsMetadata,
  SpectroClusterK8sCertificate,
  SpectroClusterKubeCtlRedirect,
  SpectroClusterLocationInputEntity,
  SpectroClusterMetadataSpec,
  SpectroClusterOidcSpec,
  SpectroClusterPackConfigList,
  SpectroClusterPackProperties,
  SpectroClusterProfileList,
  SpectroClusterProfileUpdates,
  SpectroClusterProfilesDeleteEntity,
  SpectroClusterProfilesPacksManifests,
  SpectroClusterProfilesResolvedValues,
  SpectroClusterRate,
  SpectroClusterRepave,
  SpectroClusterRepaveValidationResponse,
  SpectroClusterStatusEntity,
  SpectroClusterTags,
  SpectroClusterUidSummary,
  SpectroClusterUidUpgrades,
  SpectroClusterVMCloneEntity,
  SpectroClusterValidatorResponse,
  SpectroClusterVariableUpdateEntity,
  SpectroClusterVariables,
  SpectroClustersAksRateParams,
  SpectroClustersAwsRateParams,
  SpectroClustersAzureRateParams,
  SpectroClustersCloudStackRateParams,
  SpectroClustersDeleteParams,
  SpectroClustersEdgeNativeRateParams,
  SpectroClustersEksRateParams,
  SpectroClustersFiltersWorkspaceParams,
  SpectroClustersGcpRateParams,
  SpectroClustersGenericRateParams,
  SpectroClustersGetParams,
  SpectroClustersGetProfilesPacksManifestsParams,
  SpectroClustersGetProfilesParams,
  SpectroClustersGkeRateParams,
  SpectroClustersMaasRateParams,
  SpectroClustersMeta,
  SpectroClustersMetadata,
  SpectroClustersMetadataGetParams,
  SpectroClustersMetadataSearch,
  SpectroClustersOpenStackRateParams,
  SpectroClustersPacksRefUpdateParams,
  SpectroClustersPatchProfilesParams,
  SpectroClustersSearchFilterSummaryParams,
  SpectroClustersSummary,
  SpectroClustersUidCostSummaryParams,
  SpectroClustersUidKubeConfigParams,
  SpectroClustersUidPackManifestsUidGetParams,
  SpectroClustersUidPackPropertiesParams,
  SpectroClustersUidRateParams,
  SpectroClustersUpdateProfilesParams,
  SpectroClustersVMAddVolumeParams,
  SpectroClustersVMCloneParams,
  SpectroClustersVMCreateParams,
  SpectroClustersVMDeleteParams,
  SpectroClustersVMGetParams,
  SpectroClustersVMListParams,
  SpectroClustersVMMigrateParams,
  SpectroClustersVMPauseParams,
  SpectroClustersVMRemoveVolumeParams,
  SpectroClustersVMRestartParams,
  SpectroClustersVMResumeParams,
  SpectroClustersVMStartParams,
  SpectroClustersVMStopParams,
  SpectroClustersVMUpdateParams,
  SpectroClustersValidateNameParams,
  SpectroClustersVsphereRateParams,
  SpectroEdgeNativeClusterImportEntity,
  SpectroEdgeNativeClusterRateEntity,
  SpectroEksClusterRateEntity,
  SpectroGcpClusterImportEntity,
  SpectroGenericClusterImportEntity,
  SpectroGenericClusterRateEntity,
  SpectroMaasClusterImportEntity,
  SpectroMaasClusterRateEntity,
  SpectroOpenStackClusterImportEntity,
  SpectroOpenStackClusterRateEntity,
  SpectroTunnelConfig,
  SpectroTunnelStatus,
  SpectroVsphereClusterImportEntity,
  SpectroVsphereClusterRateEntity,
  SsoLogins,
  SyftEntity,
  SyftScanLogImageSBOMGetParams,
  SystemFeatures,
  SystemReverseProxy,
  SystemScarSpec,
  TagFilterSummary,
  Team,
  TeamPatch,
  TeamTenantRolesEntity,
  TeamTenantRolesUpdate,
  Teams,
  TeamsListParams,
  TeamsSummaryList,
  TeamsSummarySpec,
  TenantAddressPatch,
  TenantAssetCert,
  TenantAssetCerts,
  TenantClusterRbacSettings,
  TenantClusterSettings,
  TenantDomains,
  TenantEmailPatch,
  TenantEnableClusterGroup,
  TenantFreemium,
  TenantFreemiumUsage,
  TenantOidcClientSpec,
  TenantPasswordPolicyEntity,
  TenantResourceLimits,
  TenantResourceLimitsEntity,
  TenantSamlRequestSpec,
  TenantSamlSpec,
  TenantSsoAuthProvidersEntity,
  TenantsCreditAccountDeleteParams,
  TimezoneUpdateEntity,
  Uid,
  Uids,
  Updated,
  UpdatedMsg,
  User,
  UserAssetSsh,
  UserAssetSshEntity,
  UserAssetsLocationAzure,
  UserAssetsLocationGcp,
  UserAssetsLocationS3,
  UserAssetsLocations,
  UserAssetsSsh,
  UserEntity,
  UserInfo,
  UserKubectlSession,
  UserPatch,
  UserRoleUIDs,
  UserRolesEntity,
  UserStatusLoginMode,
  UserToken,
  UserUpdateEntity,
  Users,
  UsersAssetsLocationGetParams,
  UsersAssetsSshGetParams,
  UsersEmailPasswordResetBody,
  UsersListParams,
  UsersMetadata,
  UsersSummaryList,
  UsersSummarySpec,
  UsersUidPasswordChangeBody,
  V1ApiKeyActiveStateBody,
  V1AppProfileEntityBody,
  V1AppTierUpdateEntityBody,
  V1AuthUserOrgForgotParams,
  V1AwsAccountStsGetParams,
  V1AwsClusterNameValidateParams,
  V1AwsIamPoliciesParams,
  V1AwsInstanceTypesParams,
  V1AwsKeyPairValidateParams,
  V1AwsKeyPairsParams,
  V1AwsKmsKeyGetParams,
  V1AwsKmsKeyValidateParams,
  V1AwsKmsKeysParams,
  V1AwsMachineBody,
  V1AwsMachinePoolConfigEntityBody,
  V1AwsPolicyArnsValidateParams,
  V1AwsRegionsParams,
  V1AwsSecurityGroupsParams,
  V1AwsVolumeSizeGetParams,
  V1AwsVolumeTypesGetParams,
  V1AwsVpcsParams,
  V1AwsZonesParams,
  V1AzureCloudClusterConfigEntityBody,
  V1AzureClusterNameValidateParams,
  V1AzureGroupsParams,
  V1AzureInstanceTypesParams,
  V1AzureMachineBody,
  V1AzureMachinePoolConfigEntityBody,
  V1AzurePrivateDnsZonesParams,
  V1AzureRegionsParams,
  V1AzureResourceGroupListParams,
  V1AzureStorageAccountTypesParams,
  V1AzureStorageAccountsParams,
  V1AzureStorageContainersParams,
  V1AzureSubscriptionListParams,
  V1AzureVhdUrlParams,
  V1AzureVirtualNetworkListParams,
  V1AzureZonesParams,
  V1BasicOciRegistryBody,
  V1ChannelBody,
  V1CloudComputeRateParams,
  V1CloudStackDiskOfferingsGetParams,
  V1CloudStackDomainsGetParams,
  V1CloudStackKeypairsGetParams,
  V1CloudStackMachineBody,
  V1CloudStackMachinePoolConfigEntityBody,
  V1CloudStackNetworksGetParams,
  V1CloudStackOfferingsGetParams,
  V1CloudStackProjectsGetParams,
  V1CloudStackTemplatesGetParams,
  V1CloudStackVpcsGetParams,
  V1CloudStackZonesGetParams,
  V1CloudStorageRateParams,
  V1CloudWatchConfig,
  V1ClusterBackupConfigBody,
  V1ClusterComplianceScheduleConfigBody,
  V1ClusterProfileImportEntityBody,
  V1ClusterProfileTemplateDraftBody,
  V1ClusterProfilesUidExportParams,
  V1ClusterProfilesUidExportTerraformParams,
  V1ClusterRbacBody,
  V1ClusterTemplatesValidateNameParams,
  V1ClusterUpgradeSettingsEntityBody,
  V1ClusterVirtualMachineBody,
  V1ClusterWorkloadsSpecBody,
  V1CustomCloudTypeBootstrapUpdateBody,
  V1CustomMachineBody,
  V1CustomMachinePoolConfigEntityBody,
  V1DataSinkCloudWatchConfig,
  V1DataSinkConfigBody,
  V1EcrRegistryBody,
  V1EdgeHostDeviceBody,
  V1EdgeNativeMachineBody,
  V1EdgeNativeMachinePoolConfigEntityBody,
  V1EksMachinePoolConfigEntityBody,
  V1GcpAccountEntityBody,
  V1GcpAvailabilityZonesParams,
  V1GcpCloudClusterConfigEntityBody,
  V1GcpContainerImageValidateParams,
  V1GcpInstanceTypesParams,
  V1GcpMachineBody,
  V1GcpMachinePoolConfigEntityBody,
  V1GcpNetworksParams,
  V1GcpProjectsParams,
  V1GcpRegionsParams,
  V1GcpZonesParams,
  V1GenericMachineBody,
  V1GenericMachinePoolConfigEntityBody,
  V1IpPoolInputEntityBody,
  V1MaasDomainsGetParams,
  V1MaasMachineBody,
  V1MaasMachinePoolConfigEntityBody,
  V1MaasPoolsGetParams,
  V1MaasSubnetsGetParams,
  V1MaasTagsGetParams,
  V1MaasZonesGetParams,
  V1MacrosBody,
  V1ManifestInputEntityBody,
  V1ManifestRefUpdateEntityBody,
  V1NodesAutoRemediationSettingsBody,
  V1ObjectMetaBody,
  V1ObjectMetaInputEntitySchemaBody,
  V1OidcCallbackParams,
  V1OidcLogoutParams,
  V1OpenStackAzsGetParams,
  V1OpenStackFlavorsGetParams,
  V1OpenStackKeypairsGetParams,
  V1OpenStackMachineBody,
  V1OpenStackMachinePoolConfigEntityBody,
  V1OpenStackNetworksGetParams,
  V1OpenStackProjectsGetParams,
  V1OpenStackRegionsGetParams,
  V1OverlordCloudStackCloudConfigBody,
  V1OverlordMaasCloudConfigBody,
  V1OverlordOpenStackCloudConfigBody,
  V1OverlordVsphereCloudConfigBody,
  V1OverlordsMaasManifestParams,
  V1PackRegistryBody,
  V1PasswordActivateBodyBody,
  V1PasswordsBlockListBody,
  V1ProjectEntityBody,
  V1ProjectRolesPatchBody,
  V1ResourceConsumptionSpecBody,
  V1ResourceRolesUpdateEntityBody,
  V1RoleBody,
  V1SamlCallbackBody,
  V1SamlCallbackParams,
  V1SamlLogoutBody,
  V1SamlLogoutParams,
  V1SearchFilterSummarySpecBody,
  V1SpcPoliciesValidateNameParams,
  V1SpcPolicyEntityBody,
  V1SpectroAwsClusterEntityBody,
  V1SpectroAzureClusterEntityBody,
  V1SpectroAzureClusterRateEntityBody,
  V1SpectroCloudStackClusterEntityBody,
  V1SpectroClusterPacksEntityBody,
  V1SpectroClusterPacksStatusEntityBody,
  V1SpectroClusterProfilesBody,
  V1SpectroClustersClusterTemplatesUIDProfilesGetParams,
  V1SpectroCustomClusterEntityBody,
  V1SpectroEdgeNativeClusterEntityBody,
  V1SpectroEksClusterEntityBody,
  V1SpectroGcpClusterEntityBody,
  V1SpectroGcpClusterRateEntityBody,
  V1SpectroMaasClusterEntityBody,
  V1SpectroOpenStackClusterEntityBody,
  V1SpectroVirtualClusterEntityBody,
  V1SpectroVsphereClusterEntityBody,
  V1SsoCallbackParams,
  V1SsoLoginsParams,
  V1TagFilterBody,
  V1TeamBody,
  V1TenantAssetCertBody,
  V1UserAssetsLocationAzureBody,
  V1UserAssetsLocationGcpBody,
  V1UserAssetsLocationS3Body,
  V1UsersPasswordChangeBody,
  V1VariablesBody,
  V1VirtualMachineBody,
  V1VirtualMachinePoolConfigEntityBody,
  V1VirtualMachineSnapshotBody,
  V1VsphereAccountBody,
  V1VsphereCloudAccountBody,
  V1VsphereComputeClusterResourcesParams,
  V1VsphereDatacentersParams,
  V1VsphereDnsMappingBody,
  V1VsphereMachineBody,
  V1VsphereMachinePoolConfigEntityBody,
  V1WorkspaceBackupConfigEntityBody,
  V1WorkspaceWorkloadsSpecBody,
  V1WorkspacesRolesPatchBody,
  VMAddVolumeEntity,
  VMClusters,
  VMRemoveVolumeEntity,
  VMSnapshotCreateParams,
  VMSnapshotDeleteParams,
  VMSnapshotGetParams,
  VMSnapshotUpdateParams,
  VariableNames,
  Variables,
  VirtualCloudClusterConfigEntity,
  VirtualCloudConfig,
  VirtualClusterResize,
  VirtualClustersPacksValuesParams,
  VirtualMachine,
  VirtualMachineSnapshot,
  VirtualMachineSnapshotList,
  VirtualMachines,
  VsphereAccount,
  VsphereAccounts,
  VsphereAccountsUidClusterResParams,
  VsphereCloudClusterConfigEntity,
  VsphereCloudConfig,
  VsphereComputeClusterResources,
  VsphereDatacenters,
  VsphereDnsMapping,
  VsphereDnsMappings,
  VsphereDnsMappingsGetParams,
  VsphereEnv,
  VsphereMachine,
  VsphereMachines,
  VsphereMappingGetParams,
  Workspace,
  WorkspaceBackup,
  WorkspaceBackupDeleteEntity,
  WorkspaceClusterNamespacesEntity,
  WorkspaceClustersWorkloadCronJobs,
  WorkspaceClustersWorkloadDaemonSets,
  WorkspaceClustersWorkloadDeployments,
  WorkspaceClustersWorkloadJobs,
  WorkspaceClustersWorkloadNamespaces,
  WorkspaceClustersWorkloadPods,
  WorkspaceClustersWorkloadRoleBindings,
  WorkspaceClustersWorkloadStatefulSets,
  WorkspaceEntity,
  WorkspaceOpsBackupGetParams,
  WorkspaceOpsRestoreGetParams,
  WorkspaceRestore,
  WorkspaceRestoreConfigEntity,
  WorkspaceScopeRoles,
  WorkspacesValidateNameParams
} from './schemas';

import { customFetch } from '../client/index';

// Runtime configuration for base URL
let PALETTE_BASE_URL = "https://api.spectrocloud.com";

/**
 * Configure the base URL for all Palette API calls
 * @param baseUrl - The base URL for your Palette instance (e.g., "https://your-palette-host.com")
 */
export const setPaletteBaseUrl = (baseUrl: string) => {
  PALETTE_BASE_URL = baseUrl.replace(/\/$/, ''); // Remove trailing slash
};

/**
 * Get the current configured base URL
 */
export const getPaletteBaseUrl = () => PALETTE_BASE_URL;

/**
 * @summary Retrieves a list of API keys
 */
export const getApiKeysListUrl = () => {


  

  return `/v1/apiKeys`
}

export const apiKeysList = async ( options?: RequestInit): Promise<ApiKeys> => {
  
  return customFetch<ApiKeys>(getApiKeysListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create an API key
 */
export const getApiKeysCreateUrl = () => {


  

  return `/v1/apiKeys`
}

export const apiKeysCreate = async (apiKeyEntity: ApiKeyEntity, options?: RequestInit): Promise<ApiKeyCreateResponse> => {
  
  return customFetch<ApiKeyCreateResponse>(getApiKeysCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      apiKeyEntity,)
  }
);}



/**
 * @summary Deletes the specified API key
 */
export const getApiKeysUidDeleteUrl = (uid: string,) => {


  

  return `/v1/apiKeys/${uid}`
}

export const apiKeysUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getApiKeysUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified API key
 */
export const getApiKeysUidGetUrl = (uid: string,) => {


  

  return `/v1/apiKeys/${uid}`
}

export const apiKeysUidGet = async (uid: string, options?: RequestInit): Promise<ApiKey> => {
  
  return customFetch<ApiKey>(getApiKeysUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Activate or de-active the specified API key
 */
export const getApiKeysUidActiveStateUrl = (uid: string,) => {


  

  return `/v1/apiKeys/${uid}`
}

export const apiKeysUidActiveState = async (uid: string,
    v1ApiKeyActiveStateBody: V1ApiKeyActiveStateBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getApiKeysUidActiveStateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ApiKeyActiveStateBody,)
  }
);}



/**
 * @summary Update the specified API key
 */
export const getApiKeysUidUpdateUrl = (uid: string,) => {


  

  return `/v1/apiKeys/${uid}`
}

export const apiKeysUidUpdate = async (uid: string,
    apiKeyUpdate: ApiKeyUpdate, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getApiKeysUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      apiKeyUpdate,)
  }
);}



/**
 * @summary Revoke or re-activate the API key access
 */
export const getApiKeysUidStateUrl = (uid: string,) => {


  

  return `/v1/apiKeys/${uid}/state`
}

export const apiKeysUidState = async (uid: string,
    v1ApiKeyActiveStateBody: V1ApiKeyActiveStateBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getApiKeysUidStateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ApiKeyActiveStateBody,)
  }
);}



/**
 * @summary Creates a application deployment in the virtual cluster
 */
export const getAppDeploymentsVirtualClusterCreateUrl = () => {


  

  return `/v1/appDeployments`
}

export const appDeploymentsVirtualClusterCreate = async (appDeploymentVirtualClusterEntity: AppDeploymentVirtualClusterEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppDeploymentsVirtualClusterCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appDeploymentVirtualClusterEntity,)
  }
);}



/**
 * @summary Creates a application deployment in one of virtual clusters in the cluster group
 */
export const getAppDeploymentsClusterGroupCreateUrl = () => {


  

  return `/v1/appDeployments/clusterGroup`
}

export const appDeploymentsClusterGroupCreate = async (appDeploymentClusterGroupEntity: AppDeploymentClusterGroupEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppDeploymentsClusterGroupCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appDeploymentClusterGroupEntity,)
  }
);}



/**
 * @summary Deletes the specified application deployment
 */
export const getAppDeploymentsUidDeleteUrl = (uid: string,) => {


  

  return `/v1/appDeployments/${uid}`
}

export const appDeploymentsUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppDeploymentsUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified application deployment
 */
export const getAppDeploymentsUidGetUrl = (uid: string,) => {


  

  return `/v1/appDeployments/${uid}`
}

export const appDeploymentsUidGet = async (uid: string, options?: RequestInit): Promise<AppDeployment> => {
  
  return customFetch<AppDeployment>(getAppDeploymentsUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns profile of the specified application deployment
 */
export const getAppDeploymentsUidProfileGetUrl = (uid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile`
}

export const appDeploymentsUidProfileGet = async (uid: string, options?: RequestInit): Promise<AppDeploymentProfileSpec> => {
  
  return customFetch<AppDeploymentProfileSpec>(getAppDeploymentsUidProfileGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified application deployment profile
 */
export const getAppDeploymentsUidProfileUpdateUrl = (uid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile`
}

export const appDeploymentsUidProfileUpdate = async (uid: string,
    appDeploymentProfileEntity: AppDeploymentProfileEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppDeploymentsUidProfileUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appDeploymentProfileEntity,)
  }
);}



/**
 * @summary Apply the application deployment profile updates
 */
export const getAppDeploymentsUidProfileApplyUrl = (uid: string,
    params?: AppDeploymentsUidProfileApplyParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/appDeployments/${uid}/profile/apply?${stringifiedParams}` : `/v1/appDeployments/${uid}/profile/apply`
}

export const appDeploymentsUidProfileApply = async (uid: string,
    params?: AppDeploymentsUidProfileApplyParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppDeploymentsUidProfileApplyUrl(uid,params),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Returns the specified application deployment profile tier information
 */
export const getAppDeploymentsProfileTiersUidGetUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile/tiers/${tierUid}`
}

export const appDeploymentsProfileTiersUidGet = async (uid: string,
    tierUid: string, options?: RequestInit): Promise<AppTier> => {
  
  return customFetch<AppTier>(getAppDeploymentsProfileTiersUidGetUrl(uid,tierUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified application deployment profile tier information
 */
export const getAppDeploymentsProfileTiersUidUpdateUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile/tiers/${tierUid}`
}

export const appDeploymentsProfileTiersUidUpdate = async (uid: string,
    tierUid: string,
    v1AppTierUpdateEntityBody: V1AppTierUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppDeploymentsProfileTiersUidUpdateUrl(uid,tierUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AppTierUpdateEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of manifests of the specified application deployment profile tier
 */
export const getAppDeploymentsProfileTiersUidManifestsGetUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile/tiers/${tierUid}/manifests`
}

export const appDeploymentsProfileTiersUidManifestsGet = async (uid: string,
    tierUid: string, options?: RequestInit): Promise<AppTierManifests> => {
  
  return customFetch<AppTierManifests>(getAppDeploymentsProfileTiersUidManifestsGetUrl(uid,tierUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified application deployment tier manifest information
 */
export const getAppDeploymentsProfileTiersManifestsUidGetUrl = (uid: string,
    tierUid: string,
    manifestUid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile/tiers/${tierUid}/manifests/${manifestUid}`
}

export const appDeploymentsProfileTiersManifestsUidGet = async (uid: string,
    tierUid: string,
    manifestUid: string, options?: RequestInit): Promise<Manifest> => {
  
  return customFetch<Manifest>(getAppDeploymentsProfileTiersManifestsUidGetUrl(uid,tierUid,manifestUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified application deployment tier manifest information
 */
export const getAppDeploymentsProfileTiersManifestsUidUpdateUrl = (uid: string,
    tierUid: string,
    manifestUid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile/tiers/${tierUid}/manifests/${manifestUid}`
}

export const appDeploymentsProfileTiersManifestsUidUpdate = async (uid: string,
    tierUid: string,
    manifestUid: string,
    v1ManifestRefUpdateEntityBody: V1ManifestRefUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppDeploymentsProfileTiersManifestsUidUpdateUrl(uid,tierUid,manifestUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ManifestRefUpdateEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of profile versions of the specified application deployment
 */
export const getAppDeploymentsUidProfileVersionsGetUrl = (uid: string,) => {


  

  return `/v1/appDeployments/${uid}/profile/versions`
}

export const appDeploymentsUidProfileVersionsGet = async (uid: string, options?: RequestInit): Promise<AppDeploymentProfileVersions> => {
  
  return customFetch<AppDeploymentProfileVersions>(getAppDeploymentsUidProfileVersionsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a application profile
 */
export const getAppProfilesCreateUrl = () => {


  

  return `/v1/appProfiles`
}

export const appProfilesCreate = async (v1AppProfileEntityBody: V1AppProfileEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppProfilesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AppProfileEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of application profile macros
 */
export const getAppProfilesMacrosListUrl = () => {


  

  return `/v1/appProfiles/macros`
}

export const appProfilesMacrosList = async ( options?: RequestInit): Promise<Macros> => {
  
  return customFetch<Macros>(getAppProfilesMacrosListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified application profile
 */
export const getAppProfilesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}`
}

export const appProfilesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified application profile
 */
export const getAppProfilesUidGetUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}`
}

export const appProfilesUidGet = async (uid: string, options?: RequestInit): Promise<AppProfile> => {
  
  return customFetch<AppProfile>(getAppProfilesUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified application profile
 */
export const getAppProfilesUidUpdateUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}`
}

export const appProfilesUidUpdate = async (uid: string,
    v1AppProfileEntityBody: V1AppProfileEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AppProfileEntityBody,)
  }
);}



/**
 * @summary Clones the specified application profile
 */
export const getAppProfilesUidCloneUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}/clone`
}

export const appProfilesUidClone = async (uid: string,
    appProfileCloneEntity: AppProfileCloneEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppProfilesUidCloneUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appProfileCloneEntity,)
  }
);}



/**
 * @summary Validates the specified application profile clone
 */
export const getAppProfilesUidCloneValidateUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}/clone/validate`
}

export const appProfilesUidCloneValidate = async (uid: string,
    appProfileCloneMetaInputEntity: AppProfileCloneMetaInputEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidCloneValidateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appProfileCloneMetaInputEntity,)
  }
);}



/**
 * @summary Updates the specified application profile metadata
 */
export const getAppProfilesUidMetadataUpdateUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}/metadata`
}

export const appProfilesUidMetadataUpdate = async (uid: string,
    appProfileMetaEntity: AppProfileMetaEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidMetadataUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appProfileMetaEntity,)
  }
);}



/**
 * @summary Retrieves a list of tiers of the specified application profile
 */
export const getAppProfilesUidTiersGetUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers`
}

export const appProfilesUidTiersGet = async (uid: string, options?: RequestInit): Promise<AppProfileTiers> => {
  
  return customFetch<AppProfileTiers>(getAppProfilesUidTiersGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates app tier of the specified application profile
 */
export const getAppProfilesUidTiersPatchUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers`
}

export const appProfilesUidTiersPatch = async (uid: string,
    appTierPatchEntity: AppTierPatchEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppProfilesUidTiersPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appTierPatchEntity,)
  }
);}



/**
 * @summary Adds tier to the specified application profile
 */
export const getAppProfilesUidTiersCreateUrl = (uid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers`
}

export const appProfilesUidTiersCreate = async (uid: string,
    appTierEntity: AppTierEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppProfilesUidTiersCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appTierEntity,)
  }
);}



/**
 * @summary Deletes the specified application profile tier
 */
export const getAppProfilesUidTiersUidDeleteUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}`
}

export const appProfilesUidTiersUidDelete = async (uid: string,
    tierUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidTiersUidDeleteUrl(uid,tierUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified application profile tier information
 */
export const getAppProfilesUidTiersUidGetUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}`
}

export const appProfilesUidTiersUidGet = async (uid: string,
    tierUid: string, options?: RequestInit): Promise<AppTier> => {
  
  return customFetch<AppTier>(getAppProfilesUidTiersUidGetUrl(uid,tierUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified application profile tier
 */
export const getAppProfilesUidTiersUidUpdateUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}`
}

export const appProfilesUidTiersUidUpdate = async (uid: string,
    tierUid: string,
    v1AppTierUpdateEntityBody: V1AppTierUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidTiersUidUpdateUrl(uid,tierUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AppTierUpdateEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of manifests of the specified application profile tier
 */
export const getAppProfilesUidTiersUidManifestsGetUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}/manifests`
}

export const appProfilesUidTiersUidManifestsGet = async (uid: string,
    tierUid: string, options?: RequestInit): Promise<AppTierManifests> => {
  
  return customFetch<AppTierManifests>(getAppProfilesUidTiersUidManifestsGetUrl(uid,tierUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds manifest to the specified application profile tier
 */
export const getAppProfilesUidTiersUidManifestsCreateUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}/manifests`
}

export const appProfilesUidTiersUidManifestsCreate = async (uid: string,
    tierUid: string,
    v1ManifestInputEntityBody: V1ManifestInputEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getAppProfilesUidTiersUidManifestsCreateUrl(uid,tierUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ManifestInputEntityBody,)
  }
);}



/**
 * @summary Deletes the specified application profile tier manifest
 */
export const getAppProfilesUidTiersUidManifestsUidDeleteUrl = (uid: string,
    tierUid: string,
    manifestUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}/manifests/${manifestUid}`
}

export const appProfilesUidTiersUidManifestsUidDelete = async (uid: string,
    tierUid: string,
    manifestUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidTiersUidManifestsUidDeleteUrl(uid,tierUid,manifestUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified application profile tier manifest information
 */
export const getAppProfilesUidTiersUidManifestsUidGetUrl = (uid: string,
    tierUid: string,
    manifestUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}/manifests/${manifestUid}`
}

export const appProfilesUidTiersUidManifestsUidGet = async (uid: string,
    tierUid: string,
    manifestUid: string, options?: RequestInit): Promise<Manifest> => {
  
  return customFetch<Manifest>(getAppProfilesUidTiersUidManifestsUidGetUrl(uid,tierUid,manifestUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified application profile tier manifest information
 */
export const getAppProfilesUidTiersUidManifestsUidUpdateUrl = (uid: string,
    tierUid: string,
    manifestUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}/manifests/${manifestUid}`
}

export const appProfilesUidTiersUidManifestsUidUpdate = async (uid: string,
    tierUid: string,
    manifestUid: string,
    v1ManifestRefUpdateEntityBody: V1ManifestRefUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAppProfilesUidTiersUidManifestsUidUpdateUrl(uid,tierUid,manifestUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ManifestRefUpdateEntityBody,)
  }
);}



/**
 * @summary Returns the specified application profile tier resolved values
 */
export const getAppProfilesUidTiersUidResolvedValuesGetUrl = (uid: string,
    tierUid: string,) => {


  

  return `/v1/appProfiles/${uid}/tiers/${tierUid}/resolvedValues`
}

export const appProfilesUidTiersUidResolvedValuesGet = async (uid: string,
    tierUid: string, options?: RequestInit): Promise<AppTierResolvedValues> => {
  
  return customFetch<AppTierResolvedValues>(getAppProfilesUidTiersUidResolvedValuesGetUrl(uid,tierUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves the list of audit logs
 */
export const getAuditsListUrl = (params?: AuditsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/audits?${stringifiedParams}` : `/v1/audits`
}

export const auditsList = async (params?: AuditsListParams, options?: RequestInit): Promise<Audits> => {
  
  return customFetch<Audits>(getAuditsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified audit log
 */
export const getAuditsUidGetUrl = (uid: string,) => {


  

  return `/v1/audits/${uid}`
}

export const auditsUidGet = async (uid: string, options?: RequestInit): Promise<Audit> => {
  
  return customFetch<Audit>(getAuditsUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified system audit message
 */
export const getAuditsUidGetSysMsgUrl = (uid: string,) => {


  

  return `/v1/audits/${uid}/sysMsg`
}

export const auditsUidGetSysMsg = async (uid: string, options?: RequestInit): Promise<AuditSysMsg> => {
  
  return customFetch<AuditSysMsg>(getAuditsUidGetSysMsgUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified user message for the specified audit
 */
export const getAuditsUidMsgUpdateUrl = (uid: string,) => {


  

  return `/v1/audits/${uid}/userMsg`
}

export const auditsUidMsgUpdate = async (uid: string,
    auditMsgUpdate: AuditMsgUpdate, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAuditsUidMsgUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      auditMsgUpdate,)
  }
);}



/**
 * Creates a authentication request with the specified credentials
 * @summary Authenticates the user for the specified crendentials
 */
export const getAuthenticateUrl = (params?: AuthenticateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/authenticate?${stringifiedParams}` : `/v1/auth/authenticate`
}

export const authenticate = async (authLogin: AuthLogin,
    params?: AuthenticateParams, options?: RequestInit): Promise<UserToken> => {
  
  return customFetch<UserToken>(getAuthenticateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authLogin,)
  }
);}



/**
 * Returns the allowed login method and information with the organization details
 * @summary Returns the user organization details
 */
export const getAuthOrgUrl = (params?: AuthOrgParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/org?${stringifiedParams}` : `/v1/auth/org`
}

export const authOrg = async (params?: AuthOrgParams, options?: RequestInit): Promise<LoginResponse> => {
  
  return customFetch<LoginResponse>(getAuthOrgUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns the Authorization token for the palette. This is called by the IDP as a callback url after IDP authenticates the user with its server.
 * @summary Idp authorization code callback
 */
export const getV1OidcCallbackUrl = (org: string,
    params?: V1OidcCallbackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/org/${org}/oidc/callback?${stringifiedParams}` : `/v1/auth/org/${org}/oidc/callback`
}

export const v1OidcCallback = async (org: string,
    params?: V1OidcCallbackParams, options?: RequestInit): Promise<UserToken> => {
  
  return customFetch<UserToken>(getV1OidcCallbackUrl(org,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns No Content. Works as a callback url after the IDP logout from their server.
 * @summary Identity provider logout url for the Oidc
 */
export const getV1OidcLogoutUrl = (org: string,
    params?: V1OidcLogoutParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/org/${org}/oidc/logout?${stringifiedParams}` : `/v1/auth/org/${org}/oidc/logout`
}

export const v1OidcLogout = async (org: string,
    params?: V1OidcLogoutParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1OidcLogoutUrl(org,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns the Authorization token for the palette. This is called by the SAML based IDP as a callback url after IDP authenticates the user with its server.
 * @summary Identity provider callback url for the SMAL authentication
 */
export const getV1SamlCallbackUrl = (org: string,
    params?: V1SamlCallbackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/org/${org}/saml/callback?${stringifiedParams}` : `/v1/auth/org/${org}/saml/callback`
}

export const v1SamlCallback = async (org: string,
    v1SamlCallbackBody: V1SamlCallbackBody,
    params?: V1SamlCallbackParams, options?: RequestInit): Promise<UserToken> => {
    const formUrlEncoded = new URLSearchParams();
if(v1SamlCallbackBody.SAMLResponse !== undefined) {
 formUrlEncoded.append(`SAMLResponse`, v1SamlCallbackBody.SAMLResponse)
 }
if(v1SamlCallbackBody.RelayState !== undefined) {
 formUrlEncoded.append(`RelayState`, v1SamlCallbackBody.RelayState)
 }

  return customFetch<UserToken>(getV1SamlCallbackUrl(org,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}



/**
 * Returns No Content. Works as a callback url after the IDP logout from their server.
 * @summary Identity provider logout url for the SMAL
 */
export const getV1SamlLogoutUrl = (org: string,
    params?: V1SamlLogoutParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/org/${org}/saml/logout?${stringifiedParams}` : `/v1/auth/org/${org}/saml/logout`
}

export const v1SamlLogout = async (org: string,
    v1SamlLogoutBody: V1SamlLogoutBody,
    params?: V1SamlLogoutParams, options?: RequestInit): Promise<void> => {
    const formUrlEncoded = new URLSearchParams();
if(v1SamlLogoutBody.SAMLResponse !== undefined) {
 formUrlEncoded.append(`SAMLResponse`, v1SamlLogoutBody.SAMLResponse)
 }

  return customFetch<void>(getV1SamlLogoutUrl(org,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}



/**
 * Returns a list of user's organizations details and login methods
 * @summary Returns a list of user's organizations
 */
export const getV1AuthOrgsUrl = () => {


  

  return `/v1/auth/orgs`
}

export const v1AuthOrgs = async ( options?: RequestInit): Promise<Organizations> => {
  
  return customFetch<Organizations>(getV1AuthOrgsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates and Activates user password with the help of password token
 * @summary Updates and Activates the specified user password using the password token
 */
export const getPasswordActivateUrl = (passwordToken: string,) => {


  

  return `/v1/auth/password/${passwordToken}/activate`
}

export const passwordActivate = async (passwordToken: string,
    v1PasswordActivateBodyBody: V1PasswordActivateBodyBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getPasswordActivateUrl(passwordToken),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1PasswordActivateBodyBody,)
  }
);}



/**
 * Updates the new user password with the help of password token
 * @summary Resets the user password using the password token
 */
export const getPasswordResetUrl = (passwordToken: string,) => {


  

  return `/v1/auth/password/${passwordToken}/reset`
}

export const passwordReset = async (passwordToken: string,
    v1PasswordActivateBodyBody: V1PasswordActivateBodyBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getPasswordResetUrl(passwordToken),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1PasswordActivateBodyBody,)
  }
);}



/**
 * Returns a new token within refresh timeout and same session id is maintained
 * @summary Refreshes authentication token
 */
export const getAuthRefreshUrl = (token: string,
    params?: AuthRefreshParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/refresh/${token}?${stringifiedParams}` : `/v1/auth/refresh/${token}`
}

export const authRefresh = async (token: string,
    params?: AuthRefreshParams, options?: RequestInit): Promise<UserToken> => {
  
  return customFetch<UserToken>(getAuthRefreshUrl(token,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns a list of predefined Identity Provider (IDP)
 * @summary Returns a list of predefined Identity Provider (IDP)
 */
export const getV1SsoIdpsUrl = () => {


  

  return `/v1/auth/sso/idps`
}

export const v1SsoIdps = async ( options?: RequestInit): Promise<IdentityProviders> => {
  
  return customFetch<IdentityProviders>(getV1SsoIdpsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns a list of supported sso logins and their authentication mechanism
 * @summary Returns a list of supported sso logins
 */
export const getV1SsoLoginsUrl = (params?: V1SsoLoginsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/sso/logins?${stringifiedParams}` : `/v1/auth/sso/logins`
}

export const v1SsoLogins = async (params?: V1SsoLoginsParams, options?: RequestInit): Promise<SsoLogins> => {
  
  return customFetch<SsoLogins>(getV1SsoLoginsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns a list of supported sso auth providers
 * @summary Returns a list of supported sso auth providers
 */
export const getV1AuthSsoProvidersUrl = () => {


  

  return `/v1/auth/sso/providers`
}

export const v1AuthSsoProviders = async ( options?: RequestInit): Promise<SsoLogins> => {
  
  return customFetch<SsoLogins>(getV1AuthSsoProvidersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns Authorization token. Works as a callback url for the system defined sso apps
 * @summary Returns Authorization token. Works as a callback url for the system defined sso apps
 */
export const getV1SsoCallbackUrl = (ssoApp: string,
    params?: V1SsoCallbackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/sso/${ssoApp}/callback?${stringifiedParams}` : `/v1/auth/sso/${ssoApp}/callback`
}

export const v1SsoCallback = async (ssoApp: string,
    params?: V1SsoCallbackParams, options?: RequestInit): Promise<UserToken> => {
  
  return customFetch<UserToken>(getV1SsoCallbackUrl(ssoApp,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns No Content. Sends the user organization(s) information via email
 * @summary Returns No Content. Sends the user organization information via email
 */
export const getV1AuthUserOrgForgotUrl = (params: V1AuthUserOrgForgotParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/auth/user/org/forgot?${stringifiedParams}` : `/v1/auth/user/org/forgot`
}

export const v1AuthUserOrgForgot = async (params: V1AuthUserOrgForgotParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AuthUserOrgForgotUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates request to reset password via email. Password reset email will be sent to the user. Sends 204 No Content.
 * @summary Creates request to reset password via email
 */
export const getPasswordResetRequestUrl = () => {


  

  return `/v1/auth/user/password/reset`
}

export const passwordResetRequest = async (passwordResetRequestBody: PasswordResetRequestBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getPasswordResetRequestUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      passwordResetRequestBody,)
  }
);}



/**
 * @summary Retrieves a list of CloudStack cloud accounts
 */
export const getCloudAccountsCloudStackListUrl = (params?: CloudAccountsCloudStackListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack`
}

export const cloudAccountsCloudStackList = async (params?: CloudAccountsCloudStackListParams, options?: RequestInit): Promise<CloudStackAccounts> => {
  
  return customFetch<CloudStackAccounts>(getCloudAccountsCloudStackListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a CloudStack cloud account
 */
export const getCloudAccountsCloudStackCreateUrl = () => {


  

  return `/v1/cloudaccounts/apache-cloudstack`
}

export const cloudAccountsCloudStackCreate = async (cloudStackAccountInputEntity: CloudStackAccountInputEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsCloudStackCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cloudStackAccountInputEntity,)
  }
);}



/**
 * @summary Deletes the specified CloudStack account
 */
export const getCloudAccountsCloudStackDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/apache-cloudstack/${uid}`
}

export const cloudAccountsCloudStackDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsCloudStackDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified CloudStack account
 */
export const getCloudAccountsCloudStackGetUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/apache-cloudstack/${uid}`
}

export const cloudAccountsCloudStackGet = async (uid: string, options?: RequestInit): Promise<CloudStackAccount> => {
  
  return customFetch<CloudStackAccount>(getCloudAccountsCloudStackGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified CloudStack account
 */
export const getCloudAccountsCloudStackUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/apache-cloudstack/${uid}`
}

export const cloudAccountsCloudStackUpdate = async (uid: string,
    cloudStackAccountUpdateEntity: CloudStackAccountUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsCloudStackUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cloudStackAccountUpdateEntity,)
  }
);}



/**
 * @summary Get the cloudstack disk offerings for a given account and zone
 */
export const getCloudstackAccountsUidDiskofferingsUrl = (uid: string,
    params?: CloudstackAccountsUidDiskofferingsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/diskofferings?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/diskofferings`
}

export const cloudstackAccountsUidDiskofferings = async (uid: string,
    params?: CloudstackAccountsUidDiskofferingsParams, options?: RequestInit): Promise<CloudStackDiskOfferings> => {
  
  return customFetch<CloudStackDiskOfferings>(getCloudstackAccountsUidDiskofferingsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack domains for a given account
 */
export const getCloudstackAccountsUidDomainsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/domains`
}

export const cloudstackAccountsUidDomains = async (uid: string, options?: RequestInit): Promise<CloudStackDomains> => {
  
  return customFetch<CloudStackDomains>(getCloudstackAccountsUidDomainsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack SSH key pairs for a given account
 */
export const getCloudstackAccountsUidKeypairsUrl = (uid: string,
    params?: CloudstackAccountsUidKeypairsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/keypairs?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/keypairs`
}

export const cloudstackAccountsUidKeypairs = async (uid: string,
    params?: CloudstackAccountsUidKeypairsParams, options?: RequestInit): Promise<CloudStackKeypairs> => {
  
  return customFetch<CloudStackKeypairs>(getCloudstackAccountsUidKeypairsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack networks for a given account and zone
 */
export const getCloudstackAccountsUidNetworksUrl = (uid: string,
    params?: CloudstackAccountsUidNetworksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/networks?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/networks`
}

export const cloudstackAccountsUidNetworks = async (uid: string,
    params?: CloudstackAccountsUidNetworksParams, options?: RequestInit): Promise<CloudStackNetworks> => {
  
  return customFetch<CloudStackNetworks>(getCloudstackAccountsUidNetworksUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack compute offerings for a given account and zone
 */
export const getCloudstackAccountsUidOfferingsUrl = (uid: string,
    params?: CloudstackAccountsUidOfferingsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/offerings?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/offerings`
}

export const cloudstackAccountsUidOfferings = async (uid: string,
    params?: CloudstackAccountsUidOfferingsParams, options?: RequestInit): Promise<CloudStackOfferings> => {
  
  return customFetch<CloudStackOfferings>(getCloudstackAccountsUidOfferingsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack projects for a given account and domain
 */
export const getCloudstackAccountsUidProjectsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/projects`
}

export const cloudstackAccountsUidProjects = async (uid: string, options?: RequestInit): Promise<CloudStackProjects> => {
  
  return customFetch<CloudStackProjects>(getCloudstackAccountsUidProjectsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack templates for a given account and zone
 */
export const getCloudstackAccountsUidTemplatesUrl = (uid: string,
    params?: CloudstackAccountsUidTemplatesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["templateIds"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/templates?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/templates`
}

export const cloudstackAccountsUidTemplates = async (uid: string,
    params?: CloudstackAccountsUidTemplatesParams, options?: RequestInit): Promise<CloudStackTemplates> => {
  
  return customFetch<CloudStackTemplates>(getCloudstackAccountsUidTemplatesUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack VPCs for a given account
 */
export const getCloudstackAccountsUidVpcsUrl = (uid: string,
    params?: CloudstackAccountsUidVpcsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/vpcs?${stringifiedParams}` : `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/vpcs`
}

export const cloudstackAccountsUidVpcs = async (uid: string,
    params?: CloudstackAccountsUidVpcsParams, options?: RequestInit): Promise<CloudStackVpcs> => {
  
  return customFetch<CloudStackVpcs>(getCloudstackAccountsUidVpcsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cloudstack zones for a given account
 */
export const getCloudstackAccountsUidZonesUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/apache-cloudstack/${uid}/properties/zones`
}

export const cloudstackAccountsUidZones = async (uid: string, options?: RequestInit): Promise<CloudStackZones> => {
  
  return customFetch<CloudStackZones>(getCloudstackAccountsUidZonesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of AWS cloud accounts
 */
export const getCloudAccountsAwsListUrl = (params?: CloudAccountsAwsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/aws?${stringifiedParams}` : `/v1/cloudaccounts/aws`
}

export const cloudAccountsAwsList = async (params?: CloudAccountsAwsListParams, options?: RequestInit): Promise<AwsAccounts> => {
  
  return customFetch<AwsAccounts>(getCloudAccountsAwsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates an AWS cloud account
 */
export const getCloudAccountsAwsCreateUrl = () => {


  

  return `/v1/cloudaccounts/aws`
}

export const cloudAccountsAwsCreate = async (awsAccount: AwsAccount, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsAwsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsAccount,)
  }
);}



/**
 * @summary Deletes the specified AWS account
 */
export const getCloudAccountsAwsDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/aws/${uid}`
}

export const cloudAccountsAwsDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsAwsDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified AWS account
 */
export const getCloudAccountsAwsGetUrl = (uid: string,
    params?: CloudAccountsAwsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/aws/${uid}?${stringifiedParams}` : `/v1/cloudaccounts/aws/${uid}`
}

export const cloudAccountsAwsGet = async (uid: string,
    params?: CloudAccountsAwsGetParams, options?: RequestInit): Promise<AwsAccount> => {
  
  return customFetch<AwsAccount>(getCloudAccountsAwsGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified AWS account
 */
export const getCloudAccountsAwsUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/aws/${uid}`
}

export const cloudAccountsAwsUpdate = async (uid: string,
    awsAccount: AwsAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsAwsUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsAccount,)
  }
);}



/**
 * @summary Retrieves a list of azure cloud accounts
 */
export const getCloudAccountsAzureListUrl = (params?: CloudAccountsAzureListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/azure?${stringifiedParams}` : `/v1/cloudaccounts/azure`
}

export const cloudAccountsAzureList = async (params?: CloudAccountsAzureListParams, options?: RequestInit): Promise<AzureAccounts> => {
  
  return customFetch<AzureAccounts>(getCloudAccountsAzureListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create azure cloud account
 */
export const getCloudAccountsAzureCreateUrl = () => {


  

  return `/v1/cloudaccounts/azure`
}

export const cloudAccountsAzureCreate = async (azureAccount: AzureAccount, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsAzureCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      azureAccount,)
  }
);}



/**
 * @summary Deletes the specified azure account
 */
export const getCloudAccountsAzureDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/azure/${uid}`
}

export const cloudAccountsAzureDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsAzureDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified azure cloud account
 */
export const getCloudAccountsAzureGetUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/azure/${uid}`
}

export const cloudAccountsAzureGet = async (uid: string, options?: RequestInit): Promise<AzureAccount> => {
  
  return customFetch<AzureAccount>(getCloudAccountsAzureGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified azure account
 */
export const getCloudAccountsAzureUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/azure/${uid}`
}

export const cloudAccountsAzureUpdate = async (uid: string,
    azureAccount: AzureAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsAzureUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      azureAccount,)
  }
);}



/**
 * @summary Retrieves a list of cloud accounts by cloud type
 */
export const getCloudAccountsCustomListUrl = (cloudType: string,
    params?: CloudAccountsCustomListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/cloudTypes/${cloudType}?${stringifiedParams}` : `/v1/cloudaccounts/cloudTypes/${cloudType}`
}

export const cloudAccountsCustomList = async (cloudType: string,
    params?: CloudAccountsCustomListParams, options?: RequestInit): Promise<CustomAccounts> => {
  
  return customFetch<CustomAccounts>(getCloudAccountsCustomListUrl(cloudType,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates an cloud account of specific cloud type
 */
export const getCloudAccountsCustomCreateUrl = (cloudType: string,) => {


  

  return `/v1/cloudaccounts/cloudTypes/${cloudType}`
}

export const cloudAccountsCustomCreate = async (cloudType: string,
    customAccountEntity: CustomAccountEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsCustomCreateUrl(cloudType),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customAccountEntity,)
  }
);}



/**
 * @summary Deletes the specified account by cloud type
 */
export const getCloudAccountsCustomDeleteUrl = (cloudType: string,
    uid: string,) => {


  

  return `/v1/cloudaccounts/cloudTypes/${cloudType}/${uid}`
}

export const cloudAccountsCustomDelete = async (cloudType: string,
    uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsCustomDeleteUrl(cloudType,uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified account by cloud type
 */
export const getCloudAccountsCustomGetUrl = (cloudType: string,
    uid: string,) => {


  

  return `/v1/cloudaccounts/cloudTypes/${cloudType}/${uid}`
}

export const cloudAccountsCustomGet = async (cloudType: string,
    uid: string, options?: RequestInit): Promise<CustomAccount> => {
  
  return customFetch<CustomAccount>(getCloudAccountsCustomGetUrl(cloudType,uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified account by cloud type
 */
export const getCloudAccountsCustomUpdateUrl = (cloudType: string,
    uid: string,) => {


  

  return `/v1/cloudaccounts/cloudTypes/${cloudType}/${uid}`
}

export const cloudAccountsCustomUpdate = async (cloudType: string,
    uid: string,
    customAccountEntity: CustomAccountEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsCustomUpdateUrl(cloudType,uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customAccountEntity,)
  }
);}



/**
 * @summary Retrieves a list of gcp cloud accounts
 */
export const getCloudAccountsGcpListUrl = (params?: CloudAccountsGcpListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/gcp?${stringifiedParams}` : `/v1/cloudaccounts/gcp`
}

export const cloudAccountsGcpList = async (params?: CloudAccountsGcpListParams, options?: RequestInit): Promise<GcpAccounts> => {
  
  return customFetch<GcpAccounts>(getCloudAccountsGcpListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a GCP cloud account
 */
export const getCloudAccountsGcpCreateUrl = () => {


  

  return `/v1/cloudaccounts/gcp`
}

export const cloudAccountsGcpCreate = async (v1GcpAccountEntityBody: V1GcpAccountEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsGcpCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpAccountEntityBody,)
  }
);}



/**
 * @summary Deletes the specified GCP account
 */
export const getCloudAccountsGcpDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/gcp/${uid}`
}

export const cloudAccountsGcpDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsGcpDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified GCP cloud account
 */
export const getCloudAccountsGcpGetUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/gcp/${uid}`
}

export const cloudAccountsGcpGet = async (uid: string, options?: RequestInit): Promise<GcpAccount> => {
  
  return customFetch<GcpAccount>(getCloudAccountsGcpGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified GCP account
 */
export const getCloudAccountsGcpUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/gcp/${uid}`
}

export const cloudAccountsGcpUpdate = async (uid: string,
    v1GcpAccountEntityBody: V1GcpAccountEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsGcpUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpAccountEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of Maas cloud accounts
 */
export const getCloudAccountsMaasListUrl = (params?: CloudAccountsMaasListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/maas?${stringifiedParams}` : `/v1/cloudaccounts/maas`
}

export const cloudAccountsMaasList = async (params?: CloudAccountsMaasListParams, options?: RequestInit): Promise<MaasAccounts> => {
  
  return customFetch<MaasAccounts>(getCloudAccountsMaasListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates an Maas cloud account
 */
export const getCloudAccountsMaasCreateUrl = () => {


  

  return `/v1/cloudaccounts/maas`
}

export const cloudAccountsMaasCreate = async (maasAccount: MaasAccount, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsMaasCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      maasAccount,)
  }
);}



/**
 * @summary Deletes the specified Maas account
 */
export const getCloudAccountsMaasDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}`
}

export const cloudAccountsMaasDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsMaasDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified Maas account
 */
export const getCloudAccountsMaasGetUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}`
}

export const cloudAccountsMaasGet = async (uid: string, options?: RequestInit): Promise<MaasAccount> => {
  
  return customFetch<MaasAccount>(getCloudAccountsMaasGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Patches the specified CloudAccount Maas
 */
export const getCloudAccountsMaasPatchUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}`
}

export const cloudAccountsMaasPatch = async (uid: string,
    cloudAccountsPatch: CloudAccountsPatch, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsMaasPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cloudAccountsPatch,)
  }
);}



/**
 * @summary Updates the specified Maas account
 */
export const getCloudAccountsMaasUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}`
}

export const cloudAccountsMaasUpdate = async (uid: string,
    maasAccount: MaasAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsMaasUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      maasAccount,)
  }
);}



/**
 * @summary Get the maas azs for a given account
 */
export const getMaasAccountsUidAzsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}/properties/azs`
}

export const maasAccountsUidAzs = async (uid: string, options?: RequestInit): Promise<MaasZones> => {
  
  return customFetch<MaasZones>(getMaasAccountsUidAzsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the maas domains for a given account
 */
export const getMaasAccountsUidDomainsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}/properties/domains`
}

export const maasAccountsUidDomains = async (uid: string, options?: RequestInit): Promise<MaasDomains> => {
  
  return customFetch<MaasDomains>(getMaasAccountsUidDomainsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the maas pools for a given account
 */
export const getMaasAccountsUidPoolsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}/properties/resourcePools`
}

export const maasAccountsUidPools = async (uid: string, options?: RequestInit): Promise<MaasPools> => {
  
  return customFetch<MaasPools>(getMaasAccountsUidPoolsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the maas subnets for a given account
 */
export const getMaasAccountsUidSubnetsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}/properties/subnets`
}

export const maasAccountsUidSubnets = async (uid: string, options?: RequestInit): Promise<MaasSubnets> => {
  
  return customFetch<MaasSubnets>(getMaasAccountsUidSubnetsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the maas tags for a given account
 */
export const getMaasAccountsUidTagsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/maas/${uid}/properties/tags`
}

export const maasAccountsUidTags = async (uid: string, options?: RequestInit): Promise<MaasTags> => {
  
  return customFetch<MaasTags>(getMaasAccountsUidTagsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of OpenStack cloud accounts
 */
export const getCloudAccountsOpenStackListUrl = (params?: CloudAccountsOpenStackListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/openstack?${stringifiedParams}` : `/v1/cloudaccounts/openstack`
}

export const cloudAccountsOpenStackList = async (params?: CloudAccountsOpenStackListParams, options?: RequestInit): Promise<OpenStackAccounts> => {
  
  return customFetch<OpenStackAccounts>(getCloudAccountsOpenStackListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a OpenStack cloud account
 */
export const getCloudAccountsOpenStackCreateUrl = () => {


  

  return `/v1/cloudaccounts/openstack`
}

export const cloudAccountsOpenStackCreate = async (openStackAccount: OpenStackAccount, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsOpenStackCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openStackAccount,)
  }
);}



/**
 * @summary Deletes the specified OpenStack account
 */
export const getCloudAccountsOpenStackDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/openstack/${uid}`
}

export const cloudAccountsOpenStackDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsOpenStackDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified OpenStack account
 */
export const getCloudAccountsOpenStackGetUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/openstack/${uid}`
}

export const cloudAccountsOpenStackGet = async (uid: string, options?: RequestInit): Promise<OpenStackAccount> => {
  
  return customFetch<OpenStackAccount>(getCloudAccountsOpenStackGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified OpenStack account
 */
export const getCloudAccountsOpenStackUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/openstack/${uid}`
}

export const cloudAccountsOpenStackUpdate = async (uid: string,
    openStackAccount: OpenStackAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsOpenStackUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openStackAccount,)
  }
);}



/**
 * @summary Get the openstack azs for a given account and region
 */
export const getOpenstackAccountsUidAzsUrl = (uid: string,
    params?: OpenstackAccountsUidAzsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/openstack/${uid}/properties/azs?${stringifiedParams}` : `/v1/cloudaccounts/openstack/${uid}/properties/azs`
}

export const openstackAccountsUidAzs = async (uid: string,
    params?: OpenstackAccountsUidAzsParams, options?: RequestInit): Promise<OpenStackAzs> => {
  
  return customFetch<OpenStackAzs>(getOpenstackAccountsUidAzsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the openstack keypairs for a given account and scope
 */
export const getOpenstackAccountsUidFlavorsUrl = (uid: string,
    params?: OpenstackAccountsUidFlavorsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/openstack/${uid}/properties/flavors?${stringifiedParams}` : `/v1/cloudaccounts/openstack/${uid}/properties/flavors`
}

export const openstackAccountsUidFlavors = async (uid: string,
    params?: OpenstackAccountsUidFlavorsParams, options?: RequestInit): Promise<OpenStackFlavors> => {
  
  return customFetch<OpenStackFlavors>(getOpenstackAccountsUidFlavorsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the openstack keypairs for a given account and scope
 */
export const getOpenstackAccountsUidKeypairsUrl = (uid: string,
    params?: OpenstackAccountsUidKeypairsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/openstack/${uid}/properties/keypairs?${stringifiedParams}` : `/v1/cloudaccounts/openstack/${uid}/properties/keypairs`
}

export const openstackAccountsUidKeypairs = async (uid: string,
    params?: OpenstackAccountsUidKeypairsParams, options?: RequestInit): Promise<OpenStackKeypairs> => {
  
  return customFetch<OpenStackKeypairs>(getOpenstackAccountsUidKeypairsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the openstack networks for a given account and scope
 */
export const getOpenstackAccountsUidNetworksUrl = (uid: string,
    params?: OpenstackAccountsUidNetworksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/openstack/${uid}/properties/networks?${stringifiedParams}` : `/v1/cloudaccounts/openstack/${uid}/properties/networks`
}

export const openstackAccountsUidNetworks = async (uid: string,
    params?: OpenstackAccountsUidNetworksParams, options?: RequestInit): Promise<OpenStackNetworks> => {
  
  return customFetch<OpenStackNetworks>(getOpenstackAccountsUidNetworksUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the openstack projects for a given account
 */
export const getOpenstackAccountsUidProjectsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/openstack/${uid}/properties/projects`
}

export const openstackAccountsUidProjects = async (uid: string, options?: RequestInit): Promise<OpenStackProjects> => {
  
  return customFetch<OpenStackProjects>(getOpenstackAccountsUidProjectsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the openstack regions for a given account
 */
export const getOpenstackAccountsUidRegionsUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/openstack/${uid}/properties/regions`
}

export const openstackAccountsUidRegions = async (uid: string, options?: RequestInit): Promise<OpenStackRegions> => {
  
  return customFetch<OpenStackRegions>(getOpenstackAccountsUidRegionsUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cloud accounts summary
 */
export const getCloudAccountsListSummaryUrl = (params?: CloudAccountsListSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/summary?${stringifiedParams}` : `/v1/cloudaccounts/summary`
}

export const cloudAccountsListSummary = async (params?: CloudAccountsListSummaryParams, options?: RequestInit): Promise<CloudAccountsSummary> => {
  
  return customFetch<CloudAccountsSummary>(getCloudAccountsListSummaryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of vSphere cloud accounts
 */
export const getCloudAccountsVsphereListUrl = (params?: CloudAccountsVsphereListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/vsphere?${stringifiedParams}` : `/v1/cloudaccounts/vsphere`
}

export const cloudAccountsVsphereList = async (params?: CloudAccountsVsphereListParams, options?: RequestInit): Promise<VsphereAccounts> => {
  
  return customFetch<VsphereAccounts>(getCloudAccountsVsphereListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a vSphere cloud account
 */
export const getCloudAccountsVsphereCreateUrl = () => {


  

  return `/v1/cloudaccounts/vsphere`
}

export const cloudAccountsVsphereCreate = async (v1VsphereAccountBody: V1VsphereAccountBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudAccountsVsphereCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereAccountBody,)
  }
);}



/**
 * @summary Deletes the specified vSphere account
 */
export const getCloudAccountsVsphereDeleteUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/vsphere/${uid}`
}

export const cloudAccountsVsphereDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsVsphereDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified vSphere account
 */
export const getCloudAccountsVsphereGetUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/vsphere/${uid}`
}

export const cloudAccountsVsphereGet = async (uid: string, options?: RequestInit): Promise<VsphereAccount> => {
  
  return customFetch<VsphereAccount>(getCloudAccountsVsphereGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified VSphere account
 */
export const getCloudAccountsVsphereUpdateUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/vsphere/${uid}`
}

export const cloudAccountsVsphereUpdate = async (uid: string,
    v1VsphereAccountBody: V1VsphereAccountBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudAccountsVsphereUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereAccountBody,)
  }
);}



/**
 * @summary Get the vSphere computecluster resources for the given overlord account
 */
export const getVsphereAccountsUidClusterResUrl = (uid: string,
    params: VsphereAccountsUidClusterResParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudaccounts/vsphere/${uid}/properties/computecluster/resources?${stringifiedParams}` : `/v1/cloudaccounts/vsphere/${uid}/properties/computecluster/resources`
}

export const vsphereAccountsUidClusterRes = async (uid: string,
    params: VsphereAccountsUidClusterResParams, options?: RequestInit): Promise<VsphereComputeClusterResources> => {
  
  return customFetch<VsphereComputeClusterResources>(getVsphereAccountsUidClusterResUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the vSphere datacenters & datacluster for the given overlord account
 */
export const getVsphereAccountsUidDatacentersUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/vsphere/${uid}/properties/datacenters`
}

export const vsphereAccountsUidDatacenters = async (uid: string, options?: RequestInit): Promise<VsphereDatacenters> => {
  
  return customFetch<VsphereDatacenters>(getVsphereAccountsUidDatacentersUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the geolocation annotation
 */
export const getAccountsGeolocationPatchUrl = (uid: string,) => {


  

  return `/v1/cloudaccounts/${uid}/geoLocation`
}

export const accountsGeolocationPatch = async (uid: string,
    geolocationLatlong: GeolocationLatlong, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAccountsGeolocationPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      geolocationLatlong,)
  }
);}



/**
 * @summary Returns the specified AKS cloud config
 */
export const getCloudConfigsAksGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}`
}

export const cloudConfigsAksGet = async (configUid: string, options?: RequestInit): Promise<AzureCloudConfig> => {
  
  return customFetch<AzureCloudConfig>(getCloudConfigsAksGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsAksUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/clusterConfig`
}

export const cloudConfigsAksUidClusterConfig = async (configUid: string,
    v1AzureCloudClusterConfigEntityBody: V1AzureCloudClusterConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAksUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureCloudClusterConfigEntityBody,)
  }
);}



/**
 * @summary Creates an AKS cloud config's machine pool
 */
export const getCloudConfigsAksMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools`
}

export const cloudConfigsAksMachinePoolCreate = async (configUid: string,
    v1AzureMachinePoolConfigEntityBody: V1AzureMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsAksMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsAksMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsAksMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAksMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified AKS cloud config's machine pool
 */
export const getCloudConfigsAksMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsAksMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1AzureMachinePoolConfigEntityBody: V1AzureMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAksMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of AKS machines
 */
export const getCloudConfigsAksPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsAksPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsAksPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsAksPoolMachinesListParams, options?: RequestInit): Promise<AzureMachines> => {
  
  return customFetch<AzureMachines>(getCloudConfigsAksPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsAksPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsAksPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1AzureMachineBody: V1AzureMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsAksPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachineBody,)
  }
);}



/**
 * @summary Deletes the specified Azure machine
 */
export const getCloudConfigsAksPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAksPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAksPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified AKS machine
 */
export const getCloudConfigsAksPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAksPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<AzureMachine> => {
  
  return customFetch<AzureMachine>(getCloudConfigsAksPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsAksPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/aks/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAksPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1AzureMachineBody: V1AzureMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAksPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachineBody,)
  }
);}



/**
 * @summary Returns the specified CloudStack cloud config
 */
export const getCloudConfigsCloudStackGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}`
}

export const cloudConfigsCloudStackGet = async (configUid: string, options?: RequestInit): Promise<CloudStackCloudConfig> => {
  
  return customFetch<CloudStackCloudConfig>(getCloudConfigsCloudStackGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsCloudStackUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/clusterConfig`
}

export const cloudConfigsCloudStackUidClusterConfig = async (configUid: string,
    cloudStackCloudClusterConfigEntity: CloudStackCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCloudStackUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cloudStackCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates a CloudStack cloud config's machine pool
 */
export const getCloudConfigsCloudStackMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools`
}

export const cloudConfigsCloudStackMachinePoolCreate = async (configUid: string,
    v1CloudStackMachinePoolConfigEntityBody: V1CloudStackMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsCloudStackMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CloudStackMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsCloudStackMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsCloudStackMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCloudStackMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified CloudStack cloud config's machine pool
 */
export const getCloudConfigsCloudStackMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsCloudStackMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1CloudStackMachinePoolConfigEntityBody: V1CloudStackMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCloudStackMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CloudStackMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of CloudStack machines
 */
export const getCloudConfigsCloudStackPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsCloudStackPoolMachinesList = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<CloudStackMachines> => {
  
  return customFetch<CloudStackMachines>(getCloudConfigsCloudStackPoolMachinesListUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the CloudStack machine to cloud config's machine pool
 */
export const getCloudConfigsCloudStackPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsCloudStackPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1CloudStackMachineBody: V1CloudStackMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsCloudStackPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CloudStackMachineBody,)
  }
);}



/**
 * @summary Deletes the specified CloudStack machine
 */
export const getCloudConfigsCloudStackPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsCloudStackPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCloudStackPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified CloudStack machine
 */
export const getCloudConfigsCloudStackPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsCloudStackPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<CloudStackMachine> => {
  
  return customFetch<CloudStackMachine>(getCloudConfigsCloudStackPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to cloud config's machine pool
 */
export const getCloudConfigsCloudStackPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/apache-cloudstack/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsCloudStackPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1CloudStackMachineBody: V1CloudStackMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCloudStackPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CloudStackMachineBody,)
  }
);}



/**
 * @summary Returns the specified AWS cloud config
 */
export const getCloudConfigsAwsGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}`
}

export const cloudConfigsAwsGet = async (configUid: string, options?: RequestInit): Promise<AwsCloudConfig> => {
  
  return customFetch<AwsCloudConfig>(getCloudConfigsAwsGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsAwsUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/clusterConfig`
}

export const cloudConfigsAwsUidClusterConfig = async (configUid: string,
    awsCloudClusterConfigEntity: AwsCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAwsUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Updates the hybrid configuration information of AWS cluster
 */
export const getAwsCloudConfigsUidHybridConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/clusterConfig/hybridConfig`
}

export const awsCloudConfigsUidHybridConfig = async (configUid: string,
    awsCloudHybridConfigEntity: AwsCloudHybridConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAwsCloudConfigsUidHybridConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsCloudHybridConfigEntity,)
  }
);}



/**
 * @summary Creates an Hybrid AWS cloud config's Edge-Native machine pool
 */
export const getV1AwsCloudConfigsEdgeNativeUidMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/edge-native/machinePools`
}

export const v1AwsCloudConfigsEdgeNativeUidMachinePoolCreate = async (configUid: string,
    hybridEdgeNativeMachinePoolConfigEntity: HybridEdgeNativeMachinePoolConfigEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1AwsCloudConfigsEdgeNativeUidMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hybridEdgeNativeMachinePoolConfigEntity,)
  }
);}



/**
 * @summary Deletes the specified Edge-Native machine pool of hybrid AWS cluster
 */
export const getAwsCloudConfigsEdgeNativeMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/edge-native/machinePools/${machinePoolName}`
}

export const awsCloudConfigsEdgeNativeMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAwsCloudConfigsEdgeNativeMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified AWS Cluster's Edge-Native machine pool configuration
 */
export const getAwsCloudConfigsEdgeNativeMachinePoolGetUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/edge-native/machinePools/${machinePoolName}`
}

export const awsCloudConfigsEdgeNativeMachinePoolGet = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<HybridEdgeNativeMachinePoolConfig> => {
  
  return customFetch<HybridEdgeNativeMachinePoolConfig>(getAwsCloudConfigsEdgeNativeMachinePoolGetUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified Hybrid AWS cluster cloud config's Edge-Native machine pool
 */
export const getAwsCloudConfigsEdgeNativeMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/edge-native/machinePools/${machinePoolName}`
}

export const awsCloudConfigsEdgeNativeMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    hybridEdgeNativeMachinePoolConfigUpdateEntity: HybridEdgeNativeMachinePoolConfigUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getAwsCloudConfigsEdgeNativeMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hybridEdgeNativeMachinePoolConfigUpdateEntity,)
  }
);}



/**
 * @summary Creates an AWS cloud config's machine pool
 */
export const getCloudConfigsAwsMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools`
}

export const cloudConfigsAwsMachinePoolCreate = async (configUid: string,
    v1AwsMachinePoolConfigEntityBody: V1AwsMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsAwsMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AwsMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsAwsMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsAwsMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAwsMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified AWS cloud config's machine pool
 */
export const getCloudConfigsAwsMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsAwsMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1AwsMachinePoolConfigEntityBody: V1AwsMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAwsMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AwsMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of AWS machines
 */
export const getCloudConfigsAwsPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsAwsPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsAwsPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsAwsPoolMachinesListParams, options?: RequestInit): Promise<AwsMachines> => {
  
  return customFetch<AwsMachines>(getCloudConfigsAwsPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsAwsPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsAwsPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1AwsMachineBody: V1AwsMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsAwsPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AwsMachineBody,)
  }
);}



/**
 * @summary Deletes the specified AWS machine
 */
export const getCloudConfigsAwsPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAwsPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAwsPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified AWS machine
 */
export const getCloudConfigsAwsPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAwsPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<AwsMachine> => {
  
  return customFetch<AwsMachine>(getCloudConfigsAwsPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsAwsPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/aws/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAwsPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1AwsMachineBody: V1AwsMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAwsPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AwsMachineBody,)
  }
);}



/**
 * @summary Returns the specified Azure cloud config
 */
export const getCloudConfigsAzureGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}`
}

export const cloudConfigsAzureGet = async (configUid: string, options?: RequestInit): Promise<AzureCloudConfig> => {
  
  return customFetch<AzureCloudConfig>(getCloudConfigsAzureGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsAzureUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/clusterConfig`
}

export const cloudConfigsAzureUidClusterConfig = async (configUid: string,
    v1AzureCloudClusterConfigEntityBody: V1AzureCloudClusterConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAzureUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureCloudClusterConfigEntityBody,)
  }
);}



/**
 * @summary Creates an Azure cloud config's machine pool
 */
export const getCloudConfigsAzureMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools`
}

export const cloudConfigsAzureMachinePoolCreate = async (configUid: string,
    v1AzureMachinePoolConfigEntityBody: V1AzureMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsAzureMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsAzureMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsAzureMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAzureMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified Azure cloud config's machine pool
 */
export const getCloudConfigsAzureMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsAzureMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1AzureMachinePoolConfigEntityBody: V1AzureMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAzureMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachinePoolConfigEntityBody,)
  }
);}



/**
 * Returns all the Azure machines restricted to the user role and filters.
 * @summary Retrieves a list of Azure machines
 */
export const getCloudConfigsAzurePoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsAzurePoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsAzurePoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsAzurePoolMachinesListParams, options?: RequestInit): Promise<AzureMachines> => {
  
  return customFetch<AzureMachines>(getCloudConfigsAzurePoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsAzurePoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsAzurePoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1AzureMachineBody: V1AzureMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsAzurePoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachineBody,)
  }
);}



/**
 * @summary Deletes the specified Azure machine
 */
export const getCloudConfigsAzurePoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAzurePoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAzurePoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Returns a Azure machine for the specified uid.
 * @summary Returns the specified Azure machine
 */
export const getCloudConfigsAzurePoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAzurePoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<AzureMachine> => {
  
  return customFetch<AzureMachine>(getCloudConfigsAzurePoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to cloud config's machine pool
 */
export const getCloudConfigsAzurePoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/azure/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsAzurePoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1AzureMachineBody: V1AzureMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsAzurePoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AzureMachineBody,)
  }
);}



/**
 * @summary Returns the specified Custom cloud config
 */
export const getCloudConfigsCustomGetUrl = (cloudType: string,
    configUid: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}`
}

export const cloudConfigsCustomGet = async (cloudType: string,
    configUid: string, options?: RequestInit): Promise<CustomCloudConfig> => {
  
  return customFetch<CustomCloudConfig>(getCloudConfigsCustomGetUrl(cloudType,configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsCustomUidClusterConfigUrl = (cloudType: string,
    configUid: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/clusterConfig`
}

export const cloudConfigsCustomUidClusterConfig = async (cloudType: string,
    configUid: string,
    customCloudClusterConfigEntity: CustomCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCustomUidClusterConfigUrl(cloudType,configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates an Custom cloud config's machine pool
 */
export const getCloudConfigsCustomMachinePoolCreateUrl = (cloudType: string,
    configUid: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools`
}

export const cloudConfigsCustomMachinePoolCreate = async (cloudType: string,
    configUid: string,
    v1CustomMachinePoolConfigEntityBody: V1CustomMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsCustomMachinePoolCreateUrl(cloudType,configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CustomMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsCustomMachinePoolDeleteUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsCustomMachinePoolDelete = async (cloudType: string,
    configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCustomMachinePoolDeleteUrl(cloudType,configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified Custom cloud config's machine pool
 */
export const getCloudConfigsCustomMachinePoolUpdateUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsCustomMachinePoolUpdate = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    v1CustomMachinePoolConfigEntityBody: V1CustomMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCustomMachinePoolUpdateUrl(cloudType,configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CustomMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of Custom machines
 */
export const getCloudConfigsCustomPoolMachinesListUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,
    params?: CloudConfigsCustomPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsCustomPoolMachinesList = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    params?: CloudConfigsCustomPoolMachinesListParams, options?: RequestInit): Promise<CustomMachines> => {
  
  return customFetch<CustomMachines>(getCloudConfigsCustomPoolMachinesListUrl(cloudType,configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsCustomPoolMachinesAddUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsCustomPoolMachinesAdd = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    v1CustomMachineBody: V1CustomMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsCustomPoolMachinesAddUrl(cloudType,configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CustomMachineBody,)
  }
);}



/**
 * @summary Deletes the specified Custom machine
 */
export const getCloudConfigsCustomPoolMachinesUidDeleteUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsCustomPoolMachinesUidDelete = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCustomPoolMachinesUidDeleteUrl(cloudType,configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified Custom machine
 */
export const getCloudConfigsCustomPoolMachinesUidGetUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsCustomPoolMachinesUidGet = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<CustomMachine> => {
  
  return customFetch<CustomMachine>(getCloudConfigsCustomPoolMachinesUidGetUrl(cloudType,configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsCustomPoolMachinesUidUpdateUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/cloudTypes/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsCustomPoolMachinesUidUpdate = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1CustomMachineBody: V1CustomMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsCustomPoolMachinesUidUpdateUrl(cloudType,configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CustomMachineBody,)
  }
);}



/**
 * @summary Returns the specified edge-native cloud config
 */
export const getCloudConfigsEdgeNativeGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}`
}

export const cloudConfigsEdgeNativeGet = async (configUid: string, options?: RequestInit): Promise<EdgeNativeCloudConfig> => {
  
  return customFetch<EdgeNativeCloudConfig>(getCloudConfigsEdgeNativeGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsEdgeNativeUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/clusterConfig`
}

export const cloudConfigsEdgeNativeUidClusterConfig = async (configUid: string,
    edgeNativeCloudClusterConfigEntity: EdgeNativeCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEdgeNativeUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeNativeCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates a edge-native cloud config's machine pool
 */
export const getCloudConfigsEdgeNativeMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools`
}

export const cloudConfigsEdgeNativeMachinePoolCreate = async (configUid: string,
    v1EdgeNativeMachinePoolConfigEntityBody: V1EdgeNativeMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsEdgeNativeMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EdgeNativeMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsEdgeNativeMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsEdgeNativeMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEdgeNativeMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified edge-native cloud config's machine pool
 */
export const getCloudConfigsEdgeNativeMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsEdgeNativeMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1EdgeNativeMachinePoolConfigEntityBody: V1EdgeNativeMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEdgeNativeMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EdgeNativeMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of edge-native machines
 */
export const getCloudConfigsEdgeNativePoolMachinesListUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsEdgeNativePoolMachinesList = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<EdgeNativeMachines> => {
  
  return customFetch<EdgeNativeMachines>(getCloudConfigsEdgeNativePoolMachinesListUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the edge-native machine to cloud config's machine pool
 */
export const getCloudConfigsEdgeNativePoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsEdgeNativePoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1EdgeNativeMachineBody: V1EdgeNativeMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsEdgeNativePoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EdgeNativeMachineBody,)
  }
);}



/**
 * @summary Deletes the specified edge-native machine
 */
export const getCloudConfigsEdgeNativePoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsEdgeNativePoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEdgeNativePoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified edge-native machine
 */
export const getCloudConfigsEdgeNativePoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsEdgeNativePoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<EdgeNativeMachine> => {
  
  return customFetch<EdgeNativeMachine>(getCloudConfigsEdgeNativePoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to cloud config's machine pool
 */
export const getCloudConfigsEdgeNativePoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/edge-native/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsEdgeNativePoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1EdgeNativeMachineBody: V1EdgeNativeMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEdgeNativePoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EdgeNativeMachineBody,)
  }
);}



/**
 * @summary Returns the specified EKS cloud config
 */
export const getCloudConfigsEksGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}`
}

export const cloudConfigsEksGet = async (configUid: string, options?: RequestInit): Promise<EksCloudConfig> => {
  
  return customFetch<EksCloudConfig>(getCloudConfigsEksGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsEksUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/clusterConfig`
}

export const cloudConfigsEksUidClusterConfig = async (configUid: string,
    eksCloudClusterConfigEntity: EksCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEksUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eksCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Updates EKS cloud config's fargate profiles
 */
export const getCloudConfigsEksUidFargateProfilesUpdateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/fargateProfiles`
}

export const cloudConfigsEksUidFargateProfilesUpdate = async (configUid: string,
    eksFargateProfiles: EksFargateProfiles, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEksUidFargateProfilesUpdateUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eksFargateProfiles,)
  }
);}



/**
 * @summary Creates an EKS cloud config's machine pool
 */
export const getCloudConfigsEksMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools`
}

export const cloudConfigsEksMachinePoolCreate = async (configUid: string,
    v1EksMachinePoolConfigEntityBody: V1EksMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsEksMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EksMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsEksMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsEksMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEksMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified EKS cloud config's machine pool
 */
export const getCloudConfigsEksMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsEksMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1EksMachinePoolConfigEntityBody: V1EksMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEksMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EksMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of EKS machines
 */
export const getCloudConfigsEksPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsEksPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsEksPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsEksPoolMachinesListParams, options?: RequestInit): Promise<AwsMachines> => {
  
  return customFetch<AwsMachines>(getCloudConfigsEksPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsEksPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsEksPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1AwsMachineBody: V1AwsMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsEksPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AwsMachineBody,)
  }
);}



/**
 * @summary Deletes the specified EKS machine
 */
export const getCloudConfigsEksPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsEksPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEksPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified EKS machine
 */
export const getCloudConfigsEksPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsEksPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<AwsMachine> => {
  
  return customFetch<AwsMachine>(getCloudConfigsEksPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsEksPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/eks/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsEksPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1AwsMachineBody: V1AwsMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsEksPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1AwsMachineBody,)
  }
);}



/**
 * @summary Returns the specified GCP cloud config
 */
export const getCloudConfigsGcpGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}`
}

export const cloudConfigsGcpGet = async (configUid: string, options?: RequestInit): Promise<GcpCloudConfig> => {
  
  return customFetch<GcpCloudConfig>(getCloudConfigsGcpGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsGcpUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/clusterConfig`
}

export const cloudConfigsGcpUidClusterConfig = async (configUid: string,
    v1GcpCloudClusterConfigEntityBody: V1GcpCloudClusterConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGcpUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpCloudClusterConfigEntityBody,)
  }
);}



/**
 * @summary Creates a Gcp cloud config's machine pool
 */
export const getCloudConfigsGcpMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools`
}

export const cloudConfigsGcpMachinePoolCreate = async (configUid: string,
    v1GcpMachinePoolConfigEntityBody: V1GcpMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsGcpMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsGcpMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsGcpMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGcpMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified GCP cloud config's machine pool
 */
export const getCloudConfigsGcpMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsGcpMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1GcpMachinePoolConfigEntityBody: V1GcpMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGcpMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of GCP machines
 */
export const getCloudConfigsGcpPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsGcpPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsGcpPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsGcpPoolMachinesListParams, options?: RequestInit): Promise<GcpMachines> => {
  
  return customFetch<GcpMachines>(getCloudConfigsGcpPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsGcpPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsGcpPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1GcpMachineBody: V1GcpMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsGcpPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachineBody,)
  }
);}



/**
 * @summary Deletes the specified GCP machine
 */
export const getCloudConfigsGcpPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGcpPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGcpPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified GCP machine
 */
export const getCloudConfigsGcpPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGcpPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<GcpMachine> => {
  
  return customFetch<GcpMachine>(getCloudConfigsGcpPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsGcpPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/gcp/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGcpPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1GcpMachineBody: V1GcpMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGcpPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachineBody,)
  }
);}



/**
 * @summary Returns the specified Generic cloud config
 */
export const getCloudConfigsGenericGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}`
}

export const cloudConfigsGenericGet = async (configUid: string, options?: RequestInit): Promise<GenericCloudConfig> => {
  
  return customFetch<GenericCloudConfig>(getCloudConfigsGenericGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsGenericUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/clusterConfig`
}

export const cloudConfigsGenericUidClusterConfig = async (configUid: string,
    genericCloudClusterConfigEntity: GenericCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGenericUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      genericCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates a generic cloud config's machine pool
 */
export const getCloudConfigsGenericMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools`
}

export const cloudConfigsGenericMachinePoolCreate = async (configUid: string,
    v1GenericMachinePoolConfigEntityBody: V1GenericMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsGenericMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GenericMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsGenericMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsGenericMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGenericMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified generic cloud config's machine pool
 */
export const getCloudConfigsGenericMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsGenericMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1GenericMachinePoolConfigEntityBody: V1GenericMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGenericMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GenericMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of Generic machines
 */
export const getCloudConfigsGenericPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsGenericPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsGenericPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsGenericPoolMachinesListParams, options?: RequestInit): Promise<GenericMachines> => {
  
  return customFetch<GenericMachines>(getCloudConfigsGenericPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsGenericPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsGenericPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1GenericMachineBody: V1GenericMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsGenericPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GenericMachineBody,)
  }
);}



/**
 * @summary Deletes the specified machine
 */
export const getCloudConfigsGenericPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGenericPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGenericPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified generic machine
 */
export const getCloudConfigsGenericPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGenericPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<GenericMachine> => {
  
  return customFetch<GenericMachine>(getCloudConfigsGenericPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsGenericPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/generic/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGenericPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1GenericMachineBody: V1GenericMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGenericPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GenericMachineBody,)
  }
);}



/**
 * @summary Returns the specified GKE cloud config
 */
export const getCloudConfigsGkeGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}`
}

export const cloudConfigsGkeGet = async (configUid: string, options?: RequestInit): Promise<GcpCloudConfig> => {
  
  return customFetch<GcpCloudConfig>(getCloudConfigsGkeGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsGkeUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/clusterConfig`
}

export const cloudConfigsGkeUidClusterConfig = async (configUid: string,
    v1GcpCloudClusterConfigEntityBody: V1GcpCloudClusterConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGkeUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpCloudClusterConfigEntityBody,)
  }
);}



/**
 * @summary Creates an GKE cloud config's machine pool
 */
export const getCloudConfigsGkeMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools`
}

export const cloudConfigsGkeMachinePoolCreate = async (configUid: string,
    v1GcpMachinePoolConfigEntityBody: V1GcpMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsGkeMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsGkeMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsGkeMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGkeMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified GKE cloud config's machine pool
 */
export const getCloudConfigsGkeMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsGkeMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1GcpMachinePoolConfigEntityBody: V1GcpMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGkeMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of GKE machines
 */
export const getCloudConfigsGkePoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsGkePoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsGkePoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsGkePoolMachinesListParams, options?: RequestInit): Promise<GcpMachines> => {
  
  return customFetch<GcpMachines>(getCloudConfigsGkePoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsGkePoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsGkePoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1GcpMachineBody: V1GcpMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsGkePoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachineBody,)
  }
);}



/**
 * @summary Deletes the specified Gcp machine
 */
export const getCloudConfigsGkePoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGkePoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGkePoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified GKE machine
 */
export const getCloudConfigsGkePoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGkePoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<GcpMachine> => {
  
  return customFetch<GcpMachine>(getCloudConfigsGkePoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsGkePoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/gke/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsGkePoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1GcpMachineBody: V1GcpMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsGkePoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1GcpMachineBody,)
  }
);}



/**
 * @summary Returns the specified Maas cloud config
 */
export const getCloudConfigsMaasGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}`
}

export const cloudConfigsMaasGet = async (configUid: string, options?: RequestInit): Promise<MaasCloudConfig> => {
  
  return customFetch<MaasCloudConfig>(getCloudConfigsMaasGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsMaasUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/clusterConfig`
}

export const cloudConfigsMaasUidClusterConfig = async (configUid: string,
    maasCloudClusterConfigEntity: MaasCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMaasUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      maasCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates an Maas cloud config's machine pool
 */
export const getCloudConfigsMaasMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools`
}

export const cloudConfigsMaasMachinePoolCreate = async (configUid: string,
    v1MaasMachinePoolConfigEntityBody: V1MaasMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsMaasMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MaasMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsMaasMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsMaasMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMaasMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified Maas cloud config's machine pool
 */
export const getCloudConfigsMaasMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsMaasMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1MaasMachinePoolConfigEntityBody: V1MaasMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMaasMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MaasMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of Maas machines
 */
export const getCloudConfigsMaasPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsMaasPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsMaasPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsMaasPoolMachinesListParams, options?: RequestInit): Promise<MaasMachines> => {
  
  return customFetch<MaasMachines>(getCloudConfigsMaasPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsMaasPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsMaasPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1MaasMachineBody: V1MaasMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsMaasPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MaasMachineBody,)
  }
);}



/**
 * @summary Deletes the specified Maas machine
 */
export const getCloudConfigsMaasPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsMaasPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMaasPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified Maas machine
 */
export const getCloudConfigsMaasPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsMaasPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<MaasMachine> => {
  
  return customFetch<MaasMachine>(getCloudConfigsMaasPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsMaasPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/maas/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsMaasPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1MaasMachineBody: V1MaasMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMaasPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MaasMachineBody,)
  }
);}



/**
 * @summary Returns the specified OpenStack cloud config
 */
export const getCloudConfigsOpenStackGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}`
}

export const cloudConfigsOpenStackGet = async (configUid: string, options?: RequestInit): Promise<OpenStackCloudConfig> => {
  
  return customFetch<OpenStackCloudConfig>(getCloudConfigsOpenStackGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsOpenStackUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/clusterConfig`
}

export const cloudConfigsOpenStackUidClusterConfig = async (configUid: string,
    openStackCloudClusterConfigEntity: OpenStackCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsOpenStackUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openStackCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates a OpenStack cloud config's machine pool
 */
export const getCloudConfigsOpenStackMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools`
}

export const cloudConfigsOpenStackMachinePoolCreate = async (configUid: string,
    v1OpenStackMachinePoolConfigEntityBody: V1OpenStackMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsOpenStackMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OpenStackMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsOpenStackMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsOpenStackMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsOpenStackMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified OpenStack cloud config's machine pool
 */
export const getCloudConfigsOpenStackMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsOpenStackMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1OpenStackMachinePoolConfigEntityBody: V1OpenStackMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsOpenStackMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OpenStackMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of OpenStack machines
 */
export const getCloudConfigsOpenStackPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsOpenStackPoolMachinesList = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<OpenStackMachines> => {
  
  return customFetch<OpenStackMachines>(getCloudConfigsOpenStackPoolMachinesListUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the OpenStack machine to cloud config's machine pool
 */
export const getCloudConfigsOpenStackPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsOpenStackPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1OpenStackMachineBody: V1OpenStackMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsOpenStackPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OpenStackMachineBody,)
  }
);}



/**
 * @summary Deletes the specified OpenStack machine
 */
export const getCloudConfigsOpenStackPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsOpenStackPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsOpenStackPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified OpenStack machine
 */
export const getCloudConfigsOpenStackPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsOpenStackPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<OpenStackMachine> => {
  
  return customFetch<OpenStackMachine>(getCloudConfigsOpenStackPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to cloud config's machine pool
 */
export const getCloudConfigsOpenStackPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/openstack/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsOpenStackPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1OpenStackMachineBody: V1OpenStackMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsOpenStackPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OpenStackMachineBody,)
  }
);}



/**
 * @summary Returns the specified Virtual cloud config
 */
export const getCloudConfigsVirtualGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}`
}

export const cloudConfigsVirtualGet = async (configUid: string, options?: RequestInit): Promise<VirtualCloudConfig> => {
  
  return customFetch<VirtualCloudConfig>(getCloudConfigsVirtualGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsVirtualUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/clusterConfig`
}

export const cloudConfigsVirtualUidClusterConfig = async (configUid: string,
    virtualCloudClusterConfigEntity: VirtualCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVirtualUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      virtualCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates a virtual cloud config's machine pool
 */
export const getCloudConfigsVirtualMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools`
}

export const cloudConfigsVirtualMachinePoolCreate = async (configUid: string,
    v1VirtualMachinePoolConfigEntityBody: V1VirtualMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsVirtualMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VirtualMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsVirtualMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsVirtualMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVirtualMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified virtual cloud config's machine pool
 */
export const getCloudConfigsVirtualMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsVirtualMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1VirtualMachinePoolConfigEntityBody: V1VirtualMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVirtualMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VirtualMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of virtual machines
 */
export const getCloudConfigsVirtualPoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsVirtualPoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsVirtualPoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsVirtualPoolMachinesListParams, options?: RequestInit): Promise<VirtualMachines> => {
  
  return customFetch<VirtualMachines>(getCloudConfigsVirtualPoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the machine to cloud config's machine pool
 */
export const getCloudConfigsVirtualPoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsVirtualPoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1VirtualMachineBody: V1VirtualMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsVirtualPoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VirtualMachineBody,)
  }
);}



/**
 * @summary Deletes the specified virtual machine
 */
export const getCloudConfigsVirtualPoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsVirtualPoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVirtualPoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified virtual machine
 */
export const getCloudConfigsVirtualPoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsVirtualPoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<VirtualMachine> => {
  
  return customFetch<VirtualMachine>(getCloudConfigsVirtualPoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to the cloud config's machine pool
 */
export const getCloudConfigsVirtualPoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsVirtualPoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1VirtualMachineBody: V1VirtualMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVirtualPoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VirtualMachineBody,)
  }
);}



/**
 * @summary Updates and resizes the virtual cluster
 */
export const getCloudConfigsVirtualUidUpdateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/virtual/${configUid}/resize`
}

export const cloudConfigsVirtualUidUpdate = async (configUid: string,
    virtualClusterResize: VirtualClusterResize, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVirtualUidUpdateUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      virtualClusterResize,)
  }
);}



/**
 * @summary Returns the specified vSphere cloud config
 */
export const getCloudConfigsVsphereGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}`
}

export const cloudConfigsVsphereGet = async (configUid: string, options?: RequestInit): Promise<VsphereCloudConfig> => {
  
  return customFetch<VsphereCloudConfig>(getCloudConfigsVsphereGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster configuration information
 */
export const getCloudConfigsVsphereUidClusterConfigUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/clusterConfig`
}

export const cloudConfigsVsphereUidClusterConfig = async (configUid: string,
    vsphereCloudClusterConfigEntity: VsphereCloudClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVsphereUidClusterConfigUrl(configUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vsphereCloudClusterConfigEntity,)
  }
);}



/**
 * @summary Creates a vSphere cloud config's machine pool
 */
export const getCloudConfigsVsphereMachinePoolCreateUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools`
}

export const cloudConfigsVsphereMachinePoolCreate = async (configUid: string,
    v1VsphereMachinePoolConfigEntityBody: V1VsphereMachinePoolConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsVsphereMachinePoolCreateUrl(configUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Deletes the specified machine pool
 */
export const getCloudConfigsVsphereMachinePoolDeleteUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsVsphereMachinePoolDelete = async (configUid: string,
    machinePoolName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVsphereMachinePoolDeleteUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified vSphere cloud config's machine pool
 */
export const getCloudConfigsVsphereMachinePoolUpdateUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}`
}

export const cloudConfigsVsphereMachinePoolUpdate = async (configUid: string,
    machinePoolName: string,
    v1VsphereMachinePoolConfigEntityBody: V1VsphereMachinePoolConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVsphereMachinePoolUpdateUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereMachinePoolConfigEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of vSphere machines
 */
export const getCloudConfigsVspherePoolMachinesListUrl = (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsVspherePoolMachinesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}/machines?${stringifiedParams}` : `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsVspherePoolMachinesList = async (configUid: string,
    machinePoolName: string,
    params?: CloudConfigsVspherePoolMachinesListParams, options?: RequestInit): Promise<VsphereMachines> => {
  
  return customFetch<VsphereMachines>(getCloudConfigsVspherePoolMachinesListUrl(configUid,machinePoolName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds the vSphere machine to cloud config's machine pool
 */
export const getCloudConfigsVspherePoolMachinesAddUrl = (configUid: string,
    machinePoolName: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}/machines`
}

export const cloudConfigsVspherePoolMachinesAdd = async (configUid: string,
    machinePoolName: string,
    v1VsphereMachineBody: V1VsphereMachineBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getCloudConfigsVspherePoolMachinesAddUrl(configUid,machinePoolName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereMachineBody,)
  }
);}



/**
 * @summary Deletes the specified vSphere machine
 */
export const getCloudConfigsVspherePoolMachinesUidDeleteUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsVspherePoolMachinesUidDelete = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVspherePoolMachinesUidDeleteUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified vSphere machine
 */
export const getCloudConfigsVspherePoolMachinesUidGetUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsVspherePoolMachinesUidGet = async (configUid: string,
    machinePoolName: string,
    machineUid: string, options?: RequestInit): Promise<VsphereMachine> => {
  
  return customFetch<VsphereMachine>(getCloudConfigsVspherePoolMachinesUidGetUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified machine to cloud config's machine pool
 */
export const getCloudConfigsVspherePoolMachinesUidUpdateUrl = (configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/vsphere/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}`
}

export const cloudConfigsVspherePoolMachinesUidUpdate = async (configUid: string,
    machinePoolName: string,
    machineUid: string,
    v1VsphereMachineBody: V1VsphereMachineBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsVspherePoolMachinesUidUpdateUrl(configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereMachineBody,)
  }
);}



/**
 * @summary Updates the specified machine maintenance
 */
export const getCloudConfigsMachinePoolsMachineUidMaintenanceUpdateUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}/maintenance`
}

export const cloudConfigsMachinePoolsMachineUidMaintenanceUpdate = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,
    machineMaintenance: MachineMaintenance, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMachinePoolsMachineUidMaintenanceUpdateUrl(cloudType,configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      machineMaintenance,)
  }
);}



/**
 * @summary Updates the specified machine maintenance
 */
export const getCloudConfigsMachinePoolsMachineUidMaintenanceStatusUpdateUrl = (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,) => {


  

  return `/v1/cloudconfigs/${cloudType}/${configUid}/machinePools/${machinePoolName}/machines/${machineUid}/maintenance/status`
}

export const cloudConfigsMachinePoolsMachineUidMaintenanceStatusUpdate = async (cloudType: string,
    configUid: string,
    machinePoolName: string,
    machineUid: string,
    machineMaintenanceStatus: MachineMaintenanceStatus, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getCloudConfigsMachinePoolsMachineUidMaintenanceStatusUpdateUrl(cloudType,configUid,machinePoolName,machineUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      machineMaintenanceStatus,)
  }
);}



/**
 * @summary Returns the specified cloud config's machine pools and machine uid
 */
export const getCloudConfigsMachinePoolsMachineUidsGetUrl = (configUid: string,) => {


  

  return `/v1/cloudconfigs/${configUid}/machinePools/machineUids`
}

export const cloudConfigsMachinePoolsMachineUidsGet = async (configUid: string, options?: RequestInit): Promise<MachinePoolsMachineUids> => {
  
  return customFetch<MachinePoolsMachineUids>(getCloudConfigsMachinePoolsMachineUidsGetUrl(configUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Validates CloudStack account credentials and domain. Verifies API connectivity and that the specified domain exists. Returns no contents if account is valid else error.
 * @summary Check if CloudStack account is valid
 */
export const getV1CloudStackAccountValidateUrl = () => {


  

  return `/v1/clouds/apache-cloudstack/account/validate`
}

export const v1CloudStackAccountValidate = async (cloudStackCloudAccount: CloudStackCloudAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CloudStackAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cloudStackCloudAccount,)
  }
);}



/**
 * @summary Returns the CloudStack disk offerings
 */
export const getV1CloudStackDiskOfferingsGetUrl = (params?: V1CloudStackDiskOfferingsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/diskOfferings?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/diskOfferings`
}

export const v1CloudStackDiskOfferingsGet = async (params?: V1CloudStackDiskOfferingsGetParams, options?: RequestInit): Promise<CloudStackDiskOfferings> => {
  
  return customFetch<CloudStackDiskOfferings>(getV1CloudStackDiskOfferingsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack domains
 */
export const getV1CloudStackDomainsGetUrl = (params?: V1CloudStackDomainsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/domains?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/domains`
}

export const v1CloudStackDomainsGet = async (params?: V1CloudStackDomainsGetParams, options?: RequestInit): Promise<CloudStackDomains> => {
  
  return customFetch<CloudStackDomains>(getV1CloudStackDomainsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack SSH key pairs
 */
export const getV1CloudStackKeypairsGetUrl = (params?: V1CloudStackKeypairsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/keypairs?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/keypairs`
}

export const v1CloudStackKeypairsGet = async (params?: V1CloudStackKeypairsGetParams, options?: RequestInit): Promise<CloudStackKeypairs> => {
  
  return customFetch<CloudStackKeypairs>(getV1CloudStackKeypairsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack networks
 */
export const getV1CloudStackNetworksGetUrl = (params?: V1CloudStackNetworksGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/networks?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/networks`
}

export const v1CloudStackNetworksGet = async (params?: V1CloudStackNetworksGetParams, options?: RequestInit): Promise<CloudStackNetworks> => {
  
  return customFetch<CloudStackNetworks>(getV1CloudStackNetworksGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack compute offerings
 */
export const getV1CloudStackOfferingsGetUrl = (params?: V1CloudStackOfferingsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/offerings?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/offerings`
}

export const v1CloudStackOfferingsGet = async (params?: V1CloudStackOfferingsGetParams, options?: RequestInit): Promise<CloudStackOfferings> => {
  
  return customFetch<CloudStackOfferings>(getV1CloudStackOfferingsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack projects
 */
export const getV1CloudStackProjectsGetUrl = (params?: V1CloudStackProjectsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/projects?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/projects`
}

export const v1CloudStackProjectsGet = async (params?: V1CloudStackProjectsGetParams, options?: RequestInit): Promise<CloudStackProjects> => {
  
  return customFetch<CloudStackProjects>(getV1CloudStackProjectsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack templates
 */
export const getV1CloudStackTemplatesGetUrl = (params?: V1CloudStackTemplatesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["templateIds"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/templates?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/templates`
}

export const v1CloudStackTemplatesGet = async (params?: V1CloudStackTemplatesGetParams, options?: RequestInit): Promise<CloudStackTemplates> => {
  
  return customFetch<CloudStackTemplates>(getV1CloudStackTemplatesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack Vpcs
 */
export const getV1CloudStackVpcsGetUrl = (params?: V1CloudStackVpcsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/vpcs?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/vpcs`
}

export const v1CloudStackVpcsGet = async (params?: V1CloudStackVpcsGetParams, options?: RequestInit): Promise<CloudStackVpcs> => {
  
  return customFetch<CloudStackVpcs>(getV1CloudStackVpcsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the CloudStack zones
 */
export const getV1CloudStackZonesGetUrl = (params?: V1CloudStackZonesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/apache-cloudstack/zones?${stringifiedParams}` : `/v1/clouds/apache-cloudstack/zones`
}

export const v1CloudStackZonesGet = async (params?: V1CloudStackZonesGetParams, options?: RequestInit): Promise<CloudStackZones> => {
  
  return customFetch<CloudStackZones>(getV1CloudStackZonesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves the Aws secret credentials
 */
export const getV1AwsAccountSecretCredentialsUrl = () => {


  

  return `/v1/clouds/aws/account/secret/credentials`
}

export const v1AwsAccountSecretCredentials = async (awsSecretSpecInputEntity: AwsSecretSpecInputEntity, options?: RequestInit): Promise<AwsAccountCredentials> => {
  
  return customFetch<AwsAccountCredentials>(getV1AwsAccountSecretCredentialsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsSecretSpecInputEntity,)
  }
);}



/**
 * @summary Retrieves AWS external id and account id
 */
export const getV1AwsAccountStsGetUrl = (params?: V1AwsAccountStsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/account/sts?${stringifiedParams}` : `/v1/clouds/aws/account/sts`
}

export const v1AwsAccountStsGet = async (params?: V1AwsAccountStsGetParams, options?: RequestInit): Promise<AwsAccountSts> => {
  
  return customFetch<AwsAccountSts>(getV1AwsAccountStsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validate the specified AWS account credentials
 */
export const getV1AwsAccountValidateUrl = () => {


  

  return `/v1/clouds/aws/account/validate`
}

export const v1AwsAccountValidate = async (awsCloudAccount: AwsCloudAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsCloudAccount,)
  }
);}



/**
 * @summary Retrieves a list of AWS AMI types
 */
export const getV1AwsAmiTypesUrl = () => {


  

  return `/v1/clouds/aws/amiTypes`
}

export const v1AwsAmiTypes = async ( options?: RequestInit): Promise<AmiTypes> => {
  
  return customFetch<AmiTypes>(getV1AwsAmiTypesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Validates aws cloud watch credentials
 * @summary validates aws cloud watch credentials
 */
export const getV1CloudsAwsCloudWatchValidateUrl = () => {


  

  return `/v1/clouds/aws/cloudwatch/validate`
}

export const v1CloudsAwsCloudWatchValidate = async (v1CloudWatchConfig: V1CloudWatchConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CloudsAwsCloudWatchValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1CloudWatchConfig,)
  }
);}



/**
 * @summary Retrieves AWS cloud account usage cost from cost explorer.
 */
export const getAwsCloudCostUrl = () => {


  

  return `/v1/clouds/aws/cost`
}

export const awsCloudCost = async (awsCloudCostSpec: AwsCloudCostSpec, options?: RequestInit): Promise<AwsCloudCostSummary> => {
  
  return customFetch<AwsCloudCostSummary>(getAwsCloudCostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsCloudCostSpec,)
  }
);}



/**
 * Get AWS Volume Size
 * @summary Get AWS Volume Size
 */
export const getV1AwsVolumeSizeGetUrl = (imageId: string,
    params: V1AwsVolumeSizeGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/imageIds/${imageId}/volumeSize?${stringifiedParams}` : `/v1/clouds/aws/imageIds/${imageId}/volumeSize`
}

export const v1AwsVolumeSizeGet = async (imageId: string,
    params: V1AwsVolumeSizeGetParams, options?: RequestInit): Promise<AwsVolumeSize> => {
  
  return customFetch<AwsVolumeSize>(getV1AwsVolumeSizeGetUrl(imageId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of AWS policies for the specified account
 */
export const getV1AwsIamPoliciesUrl = (params?: V1AwsIamPoliciesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/policies?${stringifiedParams}` : `/v1/clouds/aws/policies`
}

export const v1AwsIamPolicies = async (awsCloudAccount: AwsCloudAccount,
    params?: V1AwsIamPoliciesParams, options?: RequestInit): Promise<AwsPolicies> => {
  
  return customFetch<AwsPolicies>(getV1AwsIamPoliciesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsCloudAccount,)
  }
);}



/**
 * @summary Validate the aws policy arns validate
 */
export const getV1AwsPolicyArnsValidateUrl = (params?: V1AwsPolicyArnsValidateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/policyArns/validate?${stringifiedParams}` : `/v1/clouds/aws/policyArns/validate`
}

export const v1AwsPolicyArnsValidate = async (awsPolicyArnsSpec: AwsPolicyArnsSpec,
    params?: V1AwsPolicyArnsValidateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsPolicyArnsValidateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsPolicyArnsSpec,)
  }
);}



/**
 * @summary Validate AWS properties
 */
export const getV1AwsPropertiesValidateUrl = () => {


  

  return `/v1/clouds/aws/properties/validate`
}

export const v1AwsPropertiesValidate = async (awsPropertiesValidateSpec: AwsPropertiesValidateSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsPropertiesValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsPropertiesValidateSpec,)
  }
);}



/**
 * @summary Retrieves a list of AWS regions for the specified account
 */
export const getV1AwsRegionsUrl = (params: V1AwsRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions?${stringifiedParams}` : `/v1/clouds/aws/regions`
}

export const v1AwsRegions = async (params: V1AwsRegionsParams, options?: RequestInit): Promise<AwsRegions> => {
  
  return customFetch<AwsRegions>(getV1AwsRegionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of AWS availability zones for the specified region
 */
export const getV1AwsZonesUrl = (region: string,
    params: V1AwsZonesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/availabilityzones?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/availabilityzones`
}

export const v1AwsZones = async (region: string,
    params: V1AwsZonesParams, options?: RequestInit): Promise<AwsAvailabilityZones> => {
  
  return customFetch<AwsAvailabilityZones>(getV1AwsZonesUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Copies the specified image from one region to another region
 */
export const getV1AwsCopyImageFromDefaultRegionUrl = (region: string,) => {


  

  return `/v1/clouds/aws/regions/${region}/copydefaultimages`
}

export const v1AwsCopyImageFromDefaultRegion = async (region: string,
    awsFindImageRequest: AwsFindImageRequest, options?: RequestInit): Promise<AsyncOperationIdEntity> => {
  
  return customFetch<AsyncOperationIdEntity>(getV1AwsCopyImageFromDefaultRegionUrl(region),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsFindImageRequest,)
  }
);}



/**
 * Returns no contents if aws cluster name is valid else error.
 * @summary Check if Aws cluster name is valid
 */
export const getV1AwsClusterNameValidateUrl = (region: string,
    params: V1AwsClusterNameValidateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/eksClusters/name/validate?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/eksClusters/name/validate`
}

export const v1AwsClusterNameValidate = async (region: string,
    params: V1AwsClusterNameValidateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsClusterNameValidateUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns AWS image for the specified AMI name
 */
export const getV1AwsFindImageUrl = (region: string,) => {


  

  return `/v1/clouds/aws/regions/${region}/images`
}

export const v1AwsFindImage = async (region: string,
    awsFindImageRequest: AwsFindImageRequest, options?: RequestInit): Promise<AwsImage> => {
  
  return customFetch<AwsImage>(getV1AwsFindImageUrl(region),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsFindImageRequest,)
  }
);}



/**
 * @summary Retrieves a list of AWS instance types
 */
export const getV1AwsInstanceTypesUrl = (region: string,
    params?: V1AwsInstanceTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/instancetypes?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/instancetypes`
}

export const v1AwsInstanceTypes = async (region: string,
    params?: V1AwsInstanceTypesParams, options?: RequestInit): Promise<AwsInstanceTypes> => {
  
  return customFetch<AwsInstanceTypes>(getV1AwsInstanceTypesUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of AWS keypairs
 */
export const getV1AwsKeyPairsUrl = (region: string,
    params: V1AwsKeyPairsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/keypairs?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/keypairs`
}

export const v1AwsKeyPairs = async (region: string,
    params: V1AwsKeyPairsParams, options?: RequestInit): Promise<AwsKeyPairs> => {
  
  return customFetch<AwsKeyPairs>(getV1AwsKeyPairsUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validate the specified AWS keypair
 */
export const getV1AwsKeyPairValidateUrl = (region: string,
    keypair: string,
    params: V1AwsKeyPairValidateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/keypairs/${keypair}/validate?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/keypairs/${keypair}/validate`
}

export const v1AwsKeyPairValidate = async (region: string,
    keypair: string,
    params: V1AwsKeyPairValidateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsKeyPairValidateUrl(region,keypair,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * @summary Get AWS KMS key by Id
 */
export const getV1AwsKmsKeyGetUrl = (region: string,
    keyId: string,
    params: V1AwsKmsKeyGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/kms/${keyId}?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/kms/${keyId}`
}

export const v1AwsKmsKeyGet = async (region: string,
    keyId: string,
    params: V1AwsKmsKeyGetParams, options?: RequestInit): Promise<AwsKmsKeyEntity> => {
  
  return customFetch<AwsKmsKeyEntity>(getV1AwsKmsKeyGetUrl(region,keyId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of AWS KMS keys for the specified account
 */
export const getV1AwsKmsKeysUrl = (region: string,
    params: V1AwsKmsKeysParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/kmskeys?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/kmskeys`
}

export const v1AwsKmsKeys = async (region: string,
    params: V1AwsKmsKeysParams, options?: RequestInit): Promise<AwsKmsKeys> => {
  
  return customFetch<AwsKmsKeys>(getV1AwsKmsKeysUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validate an Aws KMS key for the specified account
 */
export const getV1AwsKmsKeyValidateUrl = (region: string,
    params: V1AwsKmsKeyValidateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/kmskeys/validate?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/kmskeys/validate`
}

export const v1AwsKmsKeyValidate = async (region: string,
    params: V1AwsKmsKeyValidateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsKmsKeyValidateUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of AWS storage types
 */
export const getV1AwsStorageTypesUrl = (region: string,) => {


  

  return `/v1/clouds/aws/regions/${region}/storagetypes`
}

export const v1AwsStorageTypes = async (region: string, options?: RequestInit): Promise<AwsStorageTypes> => {
  
  return customFetch<AwsStorageTypes>(getV1AwsStorageTypesUrl(region),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of VPCs for the specified account
 */
export const getV1AwsVpcsUrl = (region: string,
    params: V1AwsVpcsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/regions/${region}/vpcs?${stringifiedParams}` : `/v1/clouds/aws/regions/${region}/vpcs`
}

export const v1AwsVpcs = async (region: string,
    params: V1AwsVpcsParams, options?: RequestInit): Promise<AwsVpcs> => {
  
  return customFetch<AwsVpcs>(getV1AwsVpcsUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validate the AWS S3 bucket
 */
export const getV1AwsS3ValidateUrl = () => {


  

  return `/v1/clouds/aws/s3/validate`
}

export const v1AwsS3Validate = async (awsS3BucketCredentials: AwsS3BucketCredentials, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AwsS3ValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      awsS3BucketCredentials,)
  }
);}



/**
 * @summary Retrieves a list of AWS security groups for the specified account
 */
export const getV1AwsSecurityGroupsUrl = (params: V1AwsSecurityGroupsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/securitygroups?${stringifiedParams}` : `/v1/clouds/aws/securitygroups`
}

export const v1AwsSecurityGroups = async (params: V1AwsSecurityGroupsParams, options?: RequestInit): Promise<AwsSecurityGroups> => {
  
  return customFetch<AwsSecurityGroups>(getV1AwsSecurityGroupsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * List all AWS Volume Types
 * @summary Get all AWS Volume Types
 */
export const getV1AwsVolumeTypesGetUrl = (params: V1AwsVolumeTypesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/aws/volumeTypes?${stringifiedParams}` : `/v1/clouds/aws/volumeTypes`
}

export const v1AwsVolumeTypesGet = async (params: V1AwsVolumeTypesGetParams, options?: RequestInit): Promise<AWSVolumeTypes> => {
  
  return customFetch<AWSVolumeTypes>(getV1AwsVolumeTypesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if account is valid else error.
 * @summary Check if Azure account is valid
 */
export const getV1AzureAccountValidateUrl = () => {


  

  return `/v1/clouds/azure/account/validate`
}

export const v1AzureAccountValidate = async (azureCloudAccount: AzureCloudAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AzureAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      azureCloudAccount,)
  }
);}



/**
 * @summary Retrieves a list of Azure groups
 */
export const getV1AzureGroupsUrl = (params?: V1AzureGroupsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/groups?${stringifiedParams}` : `/v1/clouds/azure/groups`
}

export const v1AzureGroups = async (params?: V1AzureGroupsParams, options?: RequestInit): Promise<AzureGroups> => {
  
  return customFetch<AzureGroups>(getV1AzureGroupsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Azure regions
 */
export const getV1AzureRegionsUrl = (params?: V1AzureRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/regions?${stringifiedParams}` : `/v1/clouds/azure/regions`
}

export const v1AzureRegions = async (params?: V1AzureRegionsParams, options?: RequestInit): Promise<AzureRegions> => {
  
  return customFetch<AzureRegions>(getV1AzureRegionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Azure instance types
 */
export const getV1AzureInstanceTypesUrl = (region: string,
    params?: V1AzureInstanceTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/regions/${region}/instancetypes?${stringifiedParams}` : `/v1/clouds/azure/regions/${region}/instancetypes`
}

export const v1AzureInstanceTypes = async (region: string,
    params?: V1AzureInstanceTypesParams, options?: RequestInit): Promise<AzureInstanceTypes> => {
  
  return customFetch<AzureInstanceTypes>(getV1AzureInstanceTypesUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Azure storage types
 */
export const getV1AzureStorageTypesUrl = (region: string,) => {


  

  return `/v1/clouds/azure/regions/${region}/storagetypes`
}

export const v1AzureStorageTypes = async (region: string, options?: RequestInit): Promise<AzureStorageTypes> => {
  
  return customFetch<AzureStorageTypes>(getV1AzureStorageTypesUrl(region),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if Azure cluster name is valid else error.
 * @summary Check if Azure cluster name is valid
 */
export const getV1AzureClusterNameValidateUrl = (region: string,
    subscriptionId: string,
    params: V1AzureClusterNameValidateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/regions/${region}/subscriptions/${subscriptionId}/aksClusters/name/validate?${stringifiedParams}` : `/v1/clouds/azure/regions/${region}/subscriptions/${subscriptionId}/aksClusters/name/validate`
}

export const v1AzureClusterNameValidate = async (region: string,
    subscriptionId: string,
    params: V1AzureClusterNameValidateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1AzureClusterNameValidateUrl(region,subscriptionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Azure virtual network list for the sepcified account
 */
export const getV1AzureVirtualNetworkListUrl = (region: string,
    subscriptionId: string,
    params: V1AzureVirtualNetworkListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/regions/${region}/subscriptions/${subscriptionId}/networks?${stringifiedParams}` : `/v1/clouds/azure/regions/${region}/subscriptions/${subscriptionId}/networks`
}

export const v1AzureVirtualNetworkList = async (region: string,
    subscriptionId: string,
    params: V1AzureVirtualNetworkListParams, options?: RequestInit): Promise<AzureVirtualNetworkList> => {
  
  return customFetch<AzureVirtualNetworkList>(getV1AzureVirtualNetworkListUrl(region,subscriptionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Azure resource group for the specified account
 */
export const getV1AzureResourceGroupListUrl = (region: string,
    subscriptionId: string,
    params: V1AzureResourceGroupListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/regions/${region}/subscriptions/${subscriptionId}/resourceGroups?${stringifiedParams}` : `/v1/clouds/azure/regions/${region}/subscriptions/${subscriptionId}/resourceGroups`
}

export const v1AzureResourceGroupList = async (region: string,
    subscriptionId: string,
    params: V1AzureResourceGroupListParams, options?: RequestInit): Promise<AzureResourceGroupList> => {
  
  return customFetch<AzureResourceGroupList>(getV1AzureResourceGroupListUrl(region,subscriptionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Azure zones for the specified region
 */
export const getV1AzureZonesUrl = (region: string,
    params?: V1AzureZonesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/regions/${region}/zones?${stringifiedParams}` : `/v1/clouds/azure/regions/${region}/zones`
}

export const v1AzureZones = async (region: string,
    params?: V1AzureZonesParams, options?: RequestInit): Promise<AzureZoneEntity> => {
  
  return customFetch<AzureZoneEntity>(getV1AzureZonesUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns Azure private DNS zones
 * @summary Get Azure private DNS zones for the given resource group
 */
export const getV1AzurePrivateDnsZonesUrl = (resourceGroup: string,
    params: V1AzurePrivateDnsZonesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/resourceGroups/${resourceGroup}/privateDnsZones?${stringifiedParams}` : `/v1/clouds/azure/resourceGroups/${resourceGroup}/privateDnsZones`
}

export const v1AzurePrivateDnsZones = async (resourceGroup: string,
    params: V1AzurePrivateDnsZonesParams, options?: RequestInit): Promise<AzurePrivateDnsZones> => {
  
  return customFetch<AzurePrivateDnsZones>(getV1AzurePrivateDnsZonesUrl(resourceGroup,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns Azure storage accounts.
 * @summary Get Azure storage accounts
 */
export const getV1AzureStorageAccountsUrl = (resourceGroup: string,
    params: V1AzureStorageAccountsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/resourceGroups/${resourceGroup}/storageAccounts?${stringifiedParams}` : `/v1/clouds/azure/resourceGroups/${resourceGroup}/storageAccounts`
}

export const v1AzureStorageAccounts = async (resourceGroup: string,
    params: V1AzureStorageAccountsParams, options?: RequestInit): Promise<AzureStorageAccounts> => {
  
  return customFetch<AzureStorageAccounts>(getV1AzureStorageAccountsUrl(resourceGroup,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns Azure storage containers for the given account.
 * @summary Get Azure storage containers
 */
export const getV1AzureStorageContainersUrl = (resourceGroup: string,
    storageAccountName: string,
    params: V1AzureStorageContainersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/resourceGroups/${resourceGroup}/storageAccounts/${storageAccountName}/containers?${stringifiedParams}` : `/v1/clouds/azure/resourceGroups/${resourceGroup}/storageAccounts/${storageAccountName}/containers`
}

export const v1AzureStorageContainers = async (resourceGroup: string,
    storageAccountName: string,
    params: V1AzureStorageContainersParams, options?: RequestInit): Promise<AzureStorageContainers> => {
  
  return customFetch<AzureStorageContainers>(getV1AzureStorageContainersUrl(resourceGroup,storageAccountName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns Azure storage account types.
 * @summary Get Azure storage account types
 */
export const getV1AzureStorageAccountTypesUrl = (params?: V1AzureStorageAccountTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/storageaccounttypes?${stringifiedParams}` : `/v1/clouds/azure/storageaccounttypes`
}

export const v1AzureStorageAccountTypes = async (params?: V1AzureStorageAccountTypesParams, options?: RequestInit): Promise<AzureStorageAccountEntity> => {
  
  return customFetch<AzureStorageAccountEntity>(getV1AzureStorageAccountTypesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns list of Azure subscription list.
 * @summary Retrieves a list of Azure subscription list for the specified account
 */
export const getV1AzureSubscriptionListUrl = (params: V1AzureSubscriptionListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/subscriptions?${stringifiedParams}` : `/v1/clouds/azure/subscriptions`
}

export const v1AzureSubscriptionList = async (params: V1AzureSubscriptionListParams, options?: RequestInit): Promise<AzureSubscriptionList> => {
  
  return customFetch<AzureSubscriptionList>(getV1AzureSubscriptionListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the Azure vhd url for the specified vhd location
 */
export const getV1AzureVhdUrlUrl = (vhd: string,
    params: V1AzureVhdUrlParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/azure/vhds/${vhd}/url?${stringifiedParams}` : `/v1/clouds/azure/vhds/${vhd}/url`
}

export const v1AzureVhdUrl = async (vhd: string,
    params: V1AzureVhdUrlParams, options?: RequestInit): Promise<AzureVhdUrlEntity> => {
  
  return customFetch<AzureVhdUrlEntity>(getV1AzureVhdUrlUrl(vhd,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the custom cloud types
 */
export const getV1CustomCloudTypesGetUrl = () => {


  

  return `/v1/clouds/cloudTypes`
}

export const v1CustomCloudTypesGet = async ( options?: RequestInit): Promise<CustomCloudTypes> => {
  
  return customFetch<CustomCloudTypes>(getV1CustomCloudTypesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Registers the custom cloud type
 */
export const getV1CustomCloudTypeRegisterUrl = () => {


  

  return `/v1/clouds/cloudTypes/register`
}

export const v1CustomCloudTypeRegister = async (customCloudRequestEntity: CustomCloudRequestEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1CustomCloudTypeRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customCloudRequestEntity,)
  }
);}



/**
 * @summary Deletes the custom cloud type
 */
export const getV1CustomCloudTypesDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}`
}

export const v1CustomCloudTypesDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypesDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns valid keys for the cloud account used for custom cloud type
 */
export const getV1CustomCloudTypeCloudAccountKeysGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/cloudAccountKeys`
}

export const v1CustomCloudTypeCloudAccountKeysGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeCloudAccountKeys> => {
  
  return customFetch<CustomCloudTypeCloudAccountKeys>(getV1CustomCloudTypeCloudAccountKeysGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type cloud account keys
 */
export const getV1CustomCloudTypeCloudAccountKeysUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/cloudAccountKeys`
}

export const v1CustomCloudTypeCloudAccountKeysUpdate = async (cloudType: string,
    customCloudTypeCloudAccountKeys: CustomCloudTypeCloudAccountKeys, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeCloudAccountKeysUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customCloudTypeCloudAccountKeys,)
  }
);}



/**
 * @summary Delete the custom cloud type bootstrap
 */
export const getV1CustomCloudTypeBootstrapDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/bootstrap`
}

export const v1CustomCloudTypeBootstrapDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeBootstrapDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type bootstrap
 */
export const getV1CustomCloudTypeBootstrapGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/bootstrap`
}

export const v1CustomCloudTypeBootstrapGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeBootstrapGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type bootstrap
 */
export const getV1CustomCloudTypeBootstrapUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/bootstrap`
}

export const v1CustomCloudTypeBootstrapUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeBootstrapUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Delete the custom cloud type cloud provider
 */
export const getV1CustomCloudTypeCloudProviderDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/cloudProvider`
}

export const v1CustomCloudTypeCloudProviderDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeCloudProviderDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type cloud provider
 */
export const getV1CustomCloudTypeCloudProviderGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/cloudProvider`
}

export const v1CustomCloudTypeCloudProviderGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeCloudProviderGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type cloud provider
 */
export const getV1CustomCloudTypeCloudProviderUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/cloudProvider`
}

export const v1CustomCloudTypeCloudProviderUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeCloudProviderUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Delete the custom cloud type control plane
 */
export const getV1CustomCloudTypeControlPlaneDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/controlPlane`
}

export const v1CustomCloudTypeControlPlaneDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeControlPlaneDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type control plane
 */
export const getV1CustomCloudTypeControlPlaneGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/controlPlane`
}

export const v1CustomCloudTypeControlPlaneGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeControlPlaneGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type control plane
 */
export const getV1CustomCloudTypeControlPlaneUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/controlPlane`
}

export const v1CustomCloudTypeControlPlaneUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeControlPlaneUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Delete the custom cloud type core
 */
export const getV1CustomCloudTypeCoreDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/core`
}

export const v1CustomCloudTypeCoreDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeCoreDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type core
 */
export const getV1CustomCloudTypeCoreGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/core`
}

export const v1CustomCloudTypeCoreGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeCoreGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type core
 */
export const getV1CustomCloudTypeCoreUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/core`
}

export const v1CustomCloudTypeCoreUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeCoreUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Delete the custom cloud type cluster template
 */
export const getV1CustomCloudTypeClusterTemplateDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/clusterTemplate`
}

export const v1CustomCloudTypeClusterTemplateDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeClusterTemplateDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type cluster template
 */
export const getV1CustomCloudTypeClusterTemplateGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/clusterTemplate`
}

export const v1CustomCloudTypeClusterTemplateGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeClusterTemplateGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type cluster template
 */
export const getV1CustomCloudTypeClusterTemplateUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/clusterTemplate`
}

export const v1CustomCloudTypeClusterTemplateUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeClusterTemplateUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Delete the custom cloud type controlPlane pool template
 */
export const getV1CustomCloudTypeControlPlanePoolTemplateDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/controlPlanePoolTemplate`
}

export const v1CustomCloudTypeControlPlanePoolTemplateDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeControlPlanePoolTemplateDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type controlPlane pool template
 */
export const getV1CustomCloudTypeControlPlanePoolTemplateGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/controlPlanePoolTemplate`
}

export const v1CustomCloudTypeControlPlanePoolTemplateGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeControlPlanePoolTemplateGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type controlPlane pool template
 */
export const getV1CustomCloudTypeControlPlanePoolTemplateUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/controlPlanePoolTemplate`
}

export const v1CustomCloudTypeControlPlanePoolTemplateUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeControlPlanePoolTemplateUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Delete the custom cloud type worker pool template
 */
export const getV1CustomCloudTypeWorkerPoolTemplateDeleteUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/workerPoolTemplate`
}

export const v1CustomCloudTypeWorkerPoolTemplateDelete = async (cloudType: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeWorkerPoolTemplateDeleteUrl(cloudType),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the custom cloud type worker pool template
 */
export const getV1CustomCloudTypeWorkerPoolTemplateGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/workerPoolTemplate`
}

export const v1CustomCloudTypeWorkerPoolTemplateGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudTypeContentResponse> => {
  
  return customFetch<CustomCloudTypeContentResponse>(getV1CustomCloudTypeWorkerPoolTemplateGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type worker pool template
 */
export const getV1CustomCloudTypeWorkerPoolTemplateUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/content/templates/workerPoolTemplate`
}

export const v1CustomCloudTypeWorkerPoolTemplateUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeWorkerPoolTemplateUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Returns the custom cloud type logo
 */
export const getV1CustomCloudTypeLogoGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/logo`
}

export const v1CustomCloudTypeLogoGet = async (cloudType: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getV1CustomCloudTypeLogoGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type logo
 */
export const getV1CustomCloudTypeLogoUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/logo`
}

export const v1CustomCloudTypeLogoUpdate = async (cloudType: string,
    v1CustomCloudTypeBootstrapUpdateBody: V1CustomCloudTypeBootstrapUpdateBody, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(v1CustomCloudTypeBootstrapUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, v1CustomCloudTypeBootstrapUpdateBody.fileName)
 }

  return customFetch<void>(getV1CustomCloudTypeLogoUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Returns the custom cloud type meta
 */
export const getV1CustomCloudTypeMetaGetUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/meta`
}

export const v1CustomCloudTypeMetaGet = async (cloudType: string, options?: RequestInit): Promise<CustomCloudMetaEntity> => {
  
  return customFetch<CustomCloudMetaEntity>(getV1CustomCloudTypeMetaGetUrl(cloudType),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the custom cloud type meta
 */
export const getV1CustomCloudTypeMetaUpdateUrl = (cloudType: string,) => {


  

  return `/v1/clouds/cloudTypes/${cloudType}/meta`
}

export const v1CustomCloudTypeMetaUpdate = async (cloudType: string,
    customCloudRequestEntity: CustomCloudRequestEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1CustomCloudTypeMetaUpdateUrl(cloudType),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customCloudRequestEntity,)
  }
);}



/**
 * @summary Validate EKS properties
 */
export const getV1EksPropertiesValidateUrl = () => {


  

  return `/v1/clouds/eks/properties/validate`
}

export const v1EksPropertiesValidate = async (eksPropertiesValidateSpec: EksPropertiesValidateSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1EksPropertiesValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eksPropertiesValidateSpec,)
  }
);}



/**
 * @summary Validate the specified GCP account credentials
 */
export const getV1GcpAccountValidateUrl = () => {


  

  return `/v1/clouds/gcp/account/validate`
}

export const v1GcpAccountValidate = async (gcpCloudAccountValidateEntity: GcpCloudAccountValidateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1GcpAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gcpCloudAccountValidateEntity,)
  }
);}



/**
 * @summary Validate the specified GCP az
 */
export const getV1GcpAzValidateUrl = () => {


  

  return `/v1/clouds/gcp/azs/validate`
}

export const v1GcpAzValidate = async (azValidateEntity: AzValidateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1GcpAzValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      azValidateEntity,)
  }
);}



/**
 * @summary Validate the specified GCP bucket name credentials
 */
export const getV1GcpBucketNameValidateUrl = () => {


  

  return `/v1/clouds/gcp/bucketname/validate`
}

export const v1GcpBucketNameValidate = async (gcpAccountNameValidateSpec: GcpAccountNameValidateSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1GcpBucketNameValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gcpAccountNameValidateSpec,)
  }
);}



/**
 * @summary Validates the image with tag
 */
export const getV1GcpContainerImageValidateUrl = (params: V1GcpContainerImageValidateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/image/container/validate?${stringifiedParams}` : `/v1/clouds/gcp/image/container/validate`
}

export const v1GcpContainerImageValidate = async (params: V1GcpContainerImageValidateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1GcpContainerImageValidateUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the Gcp image url for the specified image location
 */
export const getV1GcpImageUrlUrl = (imageName: string,) => {


  

  return `/v1/clouds/gcp/images/${imageName}/url`
}

export const v1GcpImageUrl = async (imageName: string, options?: RequestInit): Promise<GcpImageUrlEntity> => {
  
  return customFetch<GcpImageUrlEntity>(getV1GcpImageUrlUrl(imageName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of GCP projects for the specified account
 */
export const getV1GcpProjectsUrl = (params: V1GcpProjectsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/projects?${stringifiedParams}` : `/v1/clouds/gcp/projects`
}

export const v1GcpProjects = async (params: V1GcpProjectsParams, options?: RequestInit): Promise<GcpProjects> => {
  
  return customFetch<GcpProjects>(getV1GcpProjectsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of GCP regions
 */
export const getV1GcpRegionsUrl = (project: string,
    params: V1GcpRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/projects/${project}/regions?${stringifiedParams}` : `/v1/clouds/gcp/projects/${project}/regions`
}

export const v1GcpRegions = async (project: string,
    params: V1GcpRegionsParams, options?: RequestInit): Promise<GcpRegions> => {
  
  return customFetch<GcpRegions>(getV1GcpRegionsUrl(project,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of GCP networks for the specified account
 */
export const getV1GcpNetworksUrl = (project: string,
    region: string,
    params: V1GcpNetworksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/projects/${project}/regions/${region}/networks?${stringifiedParams}` : `/v1/clouds/gcp/projects/${project}/regions/${region}/networks`
}

export const v1GcpNetworks = async (project: string,
    region: string,
    params: V1GcpNetworksParams, options?: RequestInit): Promise<GcpNetworks> => {
  
  return customFetch<GcpNetworks>(getV1GcpNetworksUrl(project,region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of GCP zones for the specified account and region
 */
export const getV1GcpZonesUrl = (project: string,
    region: string,
    params: V1GcpZonesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/projects/${project}/regions/${region}/zones?${stringifiedParams}` : `/v1/clouds/gcp/projects/${project}/regions/${region}/zones`
}

export const v1GcpZones = async (project: string,
    region: string,
    params: V1GcpZonesParams, options?: RequestInit): Promise<GcpZones> => {
  
  return customFetch<GcpZones>(getV1GcpZonesUrl(project,region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validate the specified GCP project
 */
export const getV1GcpProjectValidateUrl = (project: string,) => {


  

  return `/v1/clouds/gcp/projects/${project}/validate`
}

export const v1GcpProjectValidate = async (project: string,
    cloudAccountUidEntity: CloudAccountUidEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1GcpProjectValidateUrl(project),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cloudAccountUidEntity,)
  }
);}



/**
 * @summary Retrieves a list of GCP zones for the specified account
 */
export const getV1GcpAvailabilityZonesUrl = (project: string,
    params: V1GcpAvailabilityZonesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/projects/${project}/zones?${stringifiedParams}` : `/v1/clouds/gcp/projects/${project}/zones`
}

export const v1GcpAvailabilityZones = async (project: string,
    params: V1GcpAvailabilityZonesParams, options?: RequestInit): Promise<GcpZones> => {
  
  return customFetch<GcpZones>(getV1GcpAvailabilityZonesUrl(project,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validate GCP properties
 */
export const getV1GcpPropertiesValidateUrl = () => {


  

  return `/v1/clouds/gcp/properties/validate`
}

export const v1GcpPropertiesValidate = async (gcpPropertiesValidateSpec: GcpPropertiesValidateSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1GcpPropertiesValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gcpPropertiesValidateSpec,)
  }
);}



/**
 * @summary Retrieves a list of GCP instance types
 */
export const getV1GcpInstanceTypesUrl = (region: string,
    params?: V1GcpInstanceTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/gcp/regions/${region}/instancetypes?${stringifiedParams}` : `/v1/clouds/gcp/regions/${region}/instancetypes`
}

export const v1GcpInstanceTypes = async (region: string,
    params?: V1GcpInstanceTypesParams, options?: RequestInit): Promise<GcpInstanceTypes> => {
  
  return customFetch<GcpInstanceTypes>(getV1GcpInstanceTypesUrl(region,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Gcp storage types
 */
export const getV1GcpStorageTypesUrl = (region: string,) => {


  

  return `/v1/clouds/gcp/regions/${region}/storagetypes`
}

export const v1GcpStorageTypes = async (region: string, options?: RequestInit): Promise<GcpStorageTypes> => {
  
  return customFetch<GcpStorageTypes>(getV1GcpStorageTypesUrl(region),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if account is valid else error.
 * @summary Check if Maas account is valid
 */
export const getV1MaasAccountValidateUrl = () => {


  

  return `/v1/clouds/maas/account/validate`
}

export const v1MaasAccountValidate = async (maasCloudAccount: MaasCloudAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1MaasAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      maasCloudAccount,)
  }
);}



/**
 * @summary Retrieves a list of Maas zones for a particular account uid
 */
export const getV1MaasZonesGetUrl = (params?: V1MaasZonesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/maas/azs?${stringifiedParams}` : `/v1/clouds/maas/azs`
}

export const v1MaasZonesGet = async (params?: V1MaasZonesGetParams, options?: RequestInit): Promise<MaasZones> => {
  
  return customFetch<MaasZones>(getV1MaasZonesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Maas domains
 */
export const getV1MaasDomainsGetUrl = (params?: V1MaasDomainsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/maas/domains?${stringifiedParams}` : `/v1/clouds/maas/domains`
}

export const v1MaasDomainsGet = async (params?: V1MaasDomainsGetParams, options?: RequestInit): Promise<MaasDomains> => {
  
  return customFetch<MaasDomains>(getV1MaasDomainsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Maas pools for a particular account uid
 */
export const getV1MaasPoolsGetUrl = (params?: V1MaasPoolsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/maas/resourcePools?${stringifiedParams}` : `/v1/clouds/maas/resourcePools`
}

export const v1MaasPoolsGet = async (params?: V1MaasPoolsGetParams, options?: RequestInit): Promise<MaasPools> => {
  
  return customFetch<MaasPools>(getV1MaasPoolsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Maas subnets for a particular account uid
 */
export const getV1MaasSubnetsGetUrl = (params?: V1MaasSubnetsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/maas/subnets?${stringifiedParams}` : `/v1/clouds/maas/subnets`
}

export const v1MaasSubnetsGet = async (params?: V1MaasSubnetsGetParams, options?: RequestInit): Promise<MaasSubnets> => {
  
  return customFetch<MaasSubnets>(getV1MaasSubnetsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Maas tags for a particular account uid
 */
export const getV1MaasTagsGetUrl = (params?: V1MaasTagsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/maas/tags?${stringifiedParams}` : `/v1/clouds/maas/tags`
}

export const v1MaasTagsGet = async (params?: V1MaasTagsGetParams, options?: RequestInit): Promise<MaasTags> => {
  
  return customFetch<MaasTags>(getV1MaasTagsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if account is valid else error.
 * @summary Check if OpenStack account is valid
 */
export const getV1OpenStackAccountValidateUrl = () => {


  

  return `/v1/clouds/openstack/account/validate`
}

export const v1OpenStackAccountValidate = async (openStackCloudAccount: OpenStackCloudAccount, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1OpenStackAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openStackCloudAccount,)
  }
);}



/**
 * @summary Retrieves a list of OpenStack azs for a particular account uid
 */
export const getV1OpenStackAzsGetUrl = (params?: V1OpenStackAzsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/openstack/azs?${stringifiedParams}` : `/v1/clouds/openstack/azs`
}

export const v1OpenStackAzsGet = async (params?: V1OpenStackAzsGetParams, options?: RequestInit): Promise<OpenStackAzs> => {
  
  return customFetch<OpenStackAzs>(getV1OpenStackAzsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the OpenStack flavors
 */
export const getV1OpenStackFlavorsGetUrl = (params?: V1OpenStackFlavorsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/openstack/flavors?${stringifiedParams}` : `/v1/clouds/openstack/flavors`
}

export const v1OpenStackFlavorsGet = async (params?: V1OpenStackFlavorsGetParams, options?: RequestInit): Promise<OpenStackFlavors> => {
  
  return customFetch<OpenStackFlavors>(getV1OpenStackFlavorsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the OpenStack keypair
 */
export const getV1OpenStackKeypairsGetUrl = (params?: V1OpenStackKeypairsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/openstack/keypairs?${stringifiedParams}` : `/v1/clouds/openstack/keypairs`
}

export const v1OpenStackKeypairsGet = async (params?: V1OpenStackKeypairsGetParams, options?: RequestInit): Promise<OpenStackKeypairs> => {
  
  return customFetch<OpenStackKeypairs>(getV1OpenStackKeypairsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the OpenStack networks
 */
export const getV1OpenStackNetworksGetUrl = (params?: V1OpenStackNetworksGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/openstack/networks?${stringifiedParams}` : `/v1/clouds/openstack/networks`
}

export const v1OpenStackNetworksGet = async (params?: V1OpenStackNetworksGetParams, options?: RequestInit): Promise<OpenStackNetworks> => {
  
  return customFetch<OpenStackNetworks>(getV1OpenStackNetworksGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the OpenStack projects
 */
export const getV1OpenStackProjectsGetUrl = (params?: V1OpenStackProjectsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/openstack/projects?${stringifiedParams}` : `/v1/clouds/openstack/projects`
}

export const v1OpenStackProjectsGet = async (params?: V1OpenStackProjectsGetParams, options?: RequestInit): Promise<OpenStackProjects> => {
  
  return customFetch<OpenStackProjects>(getV1OpenStackProjectsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the OpenStack regions
 */
export const getV1OpenStackRegionsGetUrl = (params?: V1OpenStackRegionsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/openstack/regions?${stringifiedParams}` : `/v1/clouds/openstack/regions`
}

export const v1OpenStackRegionsGet = async (params?: V1OpenStackRegionsGetParams, options?: RequestInit): Promise<OpenStackRegions> => {
  
  return customFetch<OpenStackRegions>(getV1OpenStackRegionsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if account is valid else error.
 * @summary Check if Vsphere account is valid
 */
export const getV1VsphereAccountValidateUrl = () => {


  

  return `/v1/clouds/vsphere/account/validate`
}

export const v1VsphereAccountValidate = async (v1VsphereCloudAccountBody: V1VsphereCloudAccountBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1VsphereAccountValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereCloudAccountBody,)
  }
);}



/**
 * @summary Returns the vsphere data centers
 */
export const getV1VsphereDatacentersUrl = (params?: V1VsphereDatacentersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/vsphere/datacenters?${stringifiedParams}` : `/v1/clouds/vsphere/datacenters`
}

export const v1VsphereDatacenters = async (params?: V1VsphereDatacentersParams, options?: RequestInit): Promise<VsphereDatacenters> => {
  
  return customFetch<VsphereDatacenters>(getV1VsphereDatacentersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the resources for vsphere compute cluster
 */
export const getV1VsphereComputeClusterResourcesUrl = (uid: string,
    computecluster: string,
    params: V1VsphereComputeClusterResourcesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/vsphere/datacenters/${uid}/computeclusters/${computecluster}?${stringifiedParams}` : `/v1/clouds/vsphere/datacenters/${uid}/computeclusters/${computecluster}`
}

export const v1VsphereComputeClusterResources = async (uid: string,
    computecluster: string,
    params: V1VsphereComputeClusterResourcesParams, options?: RequestInit): Promise<VsphereComputeClusterResources> => {
  
  return customFetch<VsphereComputeClusterResources>(getV1VsphereComputeClusterResourcesUrl(uid,computecluster,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves vsphere env
 */
export const getV1VsphereEnvUrl = () => {


  

  return `/v1/clouds/vsphere/env`
}

export const v1VsphereEnv = async (v1VsphereCloudAccountBody: V1VsphereCloudAccountBody, options?: RequestInit): Promise<VsphereEnv> => {
  
  return customFetch<VsphereEnv>(getV1VsphereEnvUrl(),
  {      
    ...options,
    method: 'GET',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereCloudAccountBody,)
  }
);}



/**
 * @summary Returns the cloud compute rate
 */
export const getV1CloudComputeRateUrl = (cloud: string,
    type: string,
    params: V1CloudComputeRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/${cloud}/compute/${type}/rate?${stringifiedParams}` : `/v1/clouds/${cloud}/compute/${type}/rate`
}

export const v1CloudComputeRate = async (cloud: string,
    type: string,
    params: V1CloudComputeRateParams, options?: RequestInit): Promise<CloudCost> => {
  
  return customFetch<CloudCost>(getV1CloudComputeRateUrl(cloud,type,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the cloud storage rate
 */
export const getV1CloudStorageRateUrl = (cloud: string,
    type: string,
    params: V1CloudStorageRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clouds/${cloud}/storage/${type}/rate?${stringifiedParams}` : `/v1/clouds/${cloud}/storage/${type}/rate`
}

export const v1CloudStorageRate = async (cloud: string,
    type: string,
    params: V1CloudStorageRateParams, options?: RequestInit): Promise<CloudCost> => {
  
  return customFetch<CloudCost>(getV1CloudStorageRateUrl(cloud,type,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create a new cluster template
 */
export const getV1ClusterTemplatesCreateUrl = () => {


  

  return `/v1/clusterTemplates`
}

export const v1ClusterTemplatesCreate = async (clusterTemplateEntity: ClusterTemplateEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1ClusterTemplatesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplateEntity,)
  }
);}



/**
 * @summary Update the specified cluster's template variables
 */
export const getV1ClusterTemplatesUidSpectroClustersUidVariablesPatchUrl = (clusterUid: string,) => {


  

  return `/v1/clusterTemplates/spectroclusters/${clusterUid}/variables`
}

export const v1ClusterTemplatesUidSpectroClustersUidVariablesPatch = async (clusterUid: string,
    clusterTemplateVariablesUpdateEntity: ClusterTemplateVariablesUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesUidSpectroClustersUidVariablesPatchUrl(clusterUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplateVariablesUpdateEntity,)
  }
);}



/**
 * @summary Retrieves a list of cluster template tags
 */
export const getV1ClusterTemplatesTagsGetUrl = () => {


  

  return `/v1/clusterTemplates/tags`
}

export const v1ClusterTemplatesTagsGet = async ( options?: RequestInit): Promise<ClusterTemplateTags> => {
  
  return customFetch<ClusterTemplateTags>(getV1ClusterTemplatesTagsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates the cluster template name
 */
export const getV1ClusterTemplatesValidateNameUrl = (params?: V1ClusterTemplatesValidateNameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterTemplates/validate/name?${stringifiedParams}` : `/v1/clusterTemplates/validate/name`
}

export const v1ClusterTemplatesValidateName = async (params?: V1ClusterTemplatesValidateNameParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesValidateNameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Delete a cluster template by uid
 */
export const getV1ClusterTemplatesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/clusterTemplates/${uid}`
}

export const v1ClusterTemplatesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster template
 */
export const getV1ClusterTemplatesUidGetUrl = (uid: string,) => {


  

  return `/v1/clusterTemplates/${uid}`
}

export const v1ClusterTemplatesUidGet = async (uid: string, options?: RequestInit): Promise<ClusterTemplate> => {
  
  return customFetch<ClusterTemplate>(getV1ClusterTemplatesUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the specified cluster template metadata
 */
export const getV1ClusterTemplatesUidMetadataUpdateUrl = (uid: string,) => {


  

  return `/v1/clusterTemplates/${uid}/metadata`
}

export const v1ClusterTemplatesUidMetadataUpdate = async (uid: string,
    v1ObjectMetaInputEntitySchemaBody: V1ObjectMetaInputEntitySchemaBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesUidMetadataUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ObjectMetaInputEntitySchemaBody,)
  }
);}



/**
 * @summary Update the specified cluster template policies
 */
export const getV1ClusterTemplatesUidPoliciesUpdateUrl = (uid: string,) => {


  

  return `/v1/clusterTemplates/${uid}/policies`
}

export const v1ClusterTemplatesUidPoliciesUpdate = async (uid: string,
    clusterTemplatePoliciesUpdateEntity: ClusterTemplatePoliciesUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesUidPoliciesUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplatePoliciesUpdateEntity,)
  }
);}



/**
 * @summary Update the specified cluster template profiles
 */
export const getV1ClusterTemplatesUidProfilesUpdateUrl = (uid: string,) => {


  

  return `/v1/clusterTemplates/${uid}/profiles`
}

export const v1ClusterTemplatesUidProfilesUpdate = async (uid: string,
    clusterTemplateProfilesUpdateEntity: ClusterTemplateProfilesUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesUidProfilesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplateProfilesUpdateEntity,)
  }
);}



/**
 * @summary Update variables for profiles in a cluster template
 */
export const getV1ClusterTemplatesUidProfilesVariablesPatchUrl = (uid: string,) => {


  

  return `/v1/clusterTemplates/${uid}/profiles/variables`
}

export const v1ClusterTemplatesUidProfilesVariablesPatch = async (uid: string,
    clusterTemplateProfilesVariablesBatchEntity: ClusterTemplateProfilesVariablesBatchEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterTemplatesUidProfilesVariablesPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplateProfilesVariablesBatchEntity,)
  }
);}



/**
 * @summary Retrieve variables for a specific profile in a cluster template
 */
export const getV1ClusterTemplatesUidProfilesProfileUidVariablesGetUrl = (uid: string,
    profileUid: string,) => {


  

  return `/v1/clusterTemplates/${uid}/profiles/${profileUid}/variables`
}

export const v1ClusterTemplatesUidProfilesProfileUidVariablesGet = async (uid: string,
    profileUid: string, options?: RequestInit): Promise<ClusterTemplateProfileVariablesResponse> => {
  
  return customFetch<ClusterTemplateProfileVariablesResponse>(getV1ClusterTemplatesUidProfilesProfileUidVariablesGetUrl(uid,profileUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the cluster reconcile document for a specific cluster launched from a template
 */
export const getV1ClusterTemplatesUidClusterReconcileClusterUidGetUrl = (uid: string,
    clusterUid: string,) => {


  

  return `/v1/clusterTemplates/${uid}/spectroclusters/${clusterUid}/reconcile`
}

export const v1ClusterTemplatesUidClusterReconcileClusterUidGet = async (uid: string,
    clusterUid: string, options?: RequestInit): Promise<ClusterReconcile> => {
  
  return customFetch<ClusterReconcile>(getV1ClusterTemplatesUidClusterReconcileClusterUidGetUrl(uid,clusterUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create cluster groups
 */
export const getClusterGroupsCreateUrl = () => {


  

  return `/v1/clustergroups`
}

export const clusterGroupsCreate = async (clusterGroupEntity: ClusterGroupEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterGroupsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterGroupEntity,)
  }
);}



/**
 * @summary Get cluster group developer credit usage by scope
 */
export const getClusterGroupsDeveloperCreditUsageGetUrl = (scope: 'system' | 'tenant',) => {


  

  return `/v1/clustergroups/developerCredit/usage/${scope}`
}

export const clusterGroupsDeveloperCreditUsageGet = async (scope: 'system' | 'tenant', options?: RequestInit): Promise<ClusterGroupsDeveloperCreditUsage> => {
  
  return customFetch<ClusterGroupsDeveloperCreditUsage>(getClusterGroupsDeveloperCreditUsageGetUrl(scope),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cluster groups host cluster summary
 */
export const getClusterGroupsHostClusterSummaryUrl = () => {


  

  return `/v1/clustergroups/hostCluster`
}

export const clusterGroupsHostClusterSummary = async ( options?: RequestInit): Promise<ClusterGroupsHostClusterSummary> => {
  
  return customFetch<ClusterGroupsHostClusterSummary>(getClusterGroupsHostClusterSummaryUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cluster groups host cluster metadata
 */
export const getClusterGroupsHostClusterMetadataUrl = () => {


  

  return `/v1/clustergroups/hostCluster/metadata`
}

export const clusterGroupsHostClusterMetadata = async ( options?: RequestInit): Promise<ClusterGroupsHostClusterMetadata> => {
  
  return customFetch<ClusterGroupsHostClusterMetadata>(getClusterGroupsHostClusterMetadataUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates the cluster groups name
 */
export const getClusterGroupsValidateNameUrl = (params: ClusterGroupsValidateNameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clustergroups/validate/name?${stringifiedParams}` : `/v1/clustergroups/validate/name`
}

export const clusterGroupsValidateName = async (params: ClusterGroupsValidateNameParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterGroupsValidateNameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified cluster group
 */
export const getClusterGroupsUidDeleteUrl = (uid: string,) => {


  

  return `/v1/clustergroups/${uid}`
}

export const clusterGroupsUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterGroupsUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster groups
 */
export const getClusterGroupsUidGetUrl = (uid: string,) => {


  

  return `/v1/clustergroups/${uid}`
}

export const clusterGroupsUidGet = async (uid: string, options?: RequestInit): Promise<ClusterGroup> => {
  
  return customFetch<ClusterGroup>(getClusterGroupsUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates cluster reference and host cluster config
 */
export const getClusterGroupsUidHostClusterUpdateUrl = (uid: string,) => {


  

  return `/v1/clustergroups/${uid}/hostCluster`
}

export const clusterGroupsUidHostClusterUpdate = async (uid: string,
    clusterGroupHostClusterEntity: ClusterGroupHostClusterEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterGroupsUidHostClusterUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterGroupHostClusterEntity,)
  }
);}



/**
 * @summary Updates the specified cluster groups meta
 */
export const getClusterGroupsUidMetaUpdateUrl = (uid: string,) => {


  

  return `/v1/clustergroups/${uid}/meta`
}

export const clusterGroupsUidMetaUpdate = async (uid: string,
    v1ObjectMetaBody: V1ObjectMetaBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterGroupsUidMetaUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ObjectMetaBody,)
  }
);}



/**
 * @summary Returns the specified clustergroup's profile packs resolved values
 */
export const getClusterGroupsUidPacksResolvedValuesGetUrl = (uid: string,) => {


  

  return `/v1/clustergroups/${uid}/packs/resolvedValues`
}

export const clusterGroupsUidPacksResolvedValuesGet = async (uid: string, options?: RequestInit): Promise<SpectroClusterProfilesResolvedValues> => {
  
  return customFetch<SpectroClusterProfilesResolvedValues>(getClusterGroupsUidPacksResolvedValuesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the associated profiles of a specified cluster group
 */
export const getClusterGroupsUidProfilesGetUrl = (uid: string,
    params?: ClusterGroupsUidProfilesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clustergroups/${uid}/profiles?${stringifiedParams}` : `/v1/clustergroups/${uid}/profiles`
}

export const clusterGroupsUidProfilesGet = async (uid: string,
    params?: ClusterGroupsUidProfilesGetParams, options?: RequestInit): Promise<SpectroClusterProfileList> => {
  
  return customFetch<SpectroClusterProfileList>(getClusterGroupsUidProfilesGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified cluster groups profiles
 */
export const getClusterGroupsUidProfilesUpdateUrl = (uid: string,) => {


  

  return `/v1/clustergroups/${uid}/profiles`
}

export const clusterGroupsUidProfilesUpdate = async (uid: string,
    v1SpectroClusterProfilesBody: V1SpectroClusterProfilesBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterGroupsUidProfilesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterProfilesBody,)
  }
);}



/**
 * @summary Creates a cluster profile
 */
export const getClusterProfilesCreateUrl = (params?: ClusterProfilesCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles?${stringifiedParams}` : `/v1/clusterprofiles`
}

export const clusterProfilesCreate = async (clusterProfileEntity: ClusterProfileEntity,
    params?: ClusterProfilesCreateParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterProfilesCreateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterProfileEntity,)
  }
);}



/**
 * @summary Deletes list of cluster profiles
 */
export const getClusterProfilesBulkDeleteUrl = () => {


  

  return `/v1/clusterprofiles/bulk`
}

export const clusterProfilesBulkDelete = async (bulkDeleteRequest: BulkDeleteRequest, options?: RequestInit): Promise<BulkDeleteResponse> => {
  
  return customFetch<BulkDeleteResponse>(getClusterProfilesBulkDeleteUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkDeleteRequest,)
  }
);}



/**
 * @summary Imports a cluster profile
 */
export const getClusterProfilesImportUrl = (params?: ClusterProfilesImportParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/import?${stringifiedParams}` : `/v1/clusterprofiles/import`
}

export const clusterProfilesImport = async (v1ClusterProfileImportEntityBody: V1ClusterProfileImportEntityBody,
    params?: ClusterProfilesImportParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterProfilesImportUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterProfileImportEntityBody,)
  }
);}



/**
 * @summary Imports a cluster profile via file
 */
export const getClusterProfilesImportFileUrl = (params?: ClusterProfilesImportFileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/import/file?${stringifiedParams}` : `/v1/clusterprofiles/import/file`
}

export const clusterProfilesImportFile = async (clusterProfilesImportFileBody: ClusterProfilesImportFileBody,
    params?: ClusterProfilesImportFileParams, options?: RequestInit): Promise<Uid> => {
    const formData = new FormData();
if(clusterProfilesImportFileBody.importFile !== undefined) {
 formData.append(`importFile`, clusterProfilesImportFileBody.importFile)
 }

  return customFetch<Uid>(getClusterProfilesImportFileUrl(params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Validates cluster profile import
 */
export const getClusterProfilesImportValidateUrl = () => {


  

  return `/v1/clusterprofiles/import/validate`
}

export const clusterProfilesImportValidate = async (v1ClusterProfileImportEntityBody: V1ClusterProfileImportEntityBody, options?: RequestInit): Promise<ClusterProfileImportEntity> => {
  
  return customFetch<ClusterProfileImportEntity>(getClusterProfilesImportValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterProfileImportEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of macros
 */
export const getMacrosListUrl = () => {


  

  return `/v1/clusterprofiles/macros`
}

export const macrosList = async ( options?: RequestInit): Promise<Macros> => {
  
  return customFetch<Macros>(getMacrosListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Validates the cluster profile name and version
 * @summary Validates the cluster profile metadata
 */
export const getClusterProfilesValidateNameVersionUrl = (params?: ClusterProfilesValidateNameVersionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/validate/name?${stringifiedParams}` : `/v1/clusterprofiles/validate/name`
}

export const clusterProfilesValidateNameVersion = async (params?: ClusterProfilesValidateNameVersionParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesValidateNameVersionUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates cluster profile packs
 */
export const getClusterProfilesValidatePacksUrl = () => {


  

  return `/v1/clusterprofiles/validate/packs`
}

export const clusterProfilesValidatePacks = async (v1ClusterProfileTemplateDraftBody: V1ClusterProfileTemplateDraftBody, options?: RequestInit): Promise<ClusterProfileValidatorResponse> => {
  
  return customFetch<ClusterProfileValidatorResponse>(getClusterProfilesValidatePacksUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterProfileTemplateDraftBody,)
  }
);}



/**
 * @summary Deletes the specified cluster profile
 */
export const getClusterProfilesDeleteUrl = (uid: string,
    params?: ClusterProfilesDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}?${stringifiedParams}` : `/v1/clusterprofiles/${uid}`
}

export const clusterProfilesDelete = async (uid: string,
    params?: ClusterProfilesDeleteParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesDeleteUrl(uid,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns a specified cluster profile
 */
export const getClusterProfilesGetUrl = (uid: string,
    params?: ClusterProfilesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}?${stringifiedParams}` : `/v1/clusterprofiles/${uid}`
}

export const clusterProfilesGet = async (uid: string,
    params?: ClusterProfilesGetParams, options?: RequestInit): Promise<ClusterProfile> => {
  
  return customFetch<ClusterProfile>(getClusterProfilesGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified cluster profile
 */
export const getClusterProfilesUpdateUrl = (uid: string,
    params?: ClusterProfilesUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}?${stringifiedParams}` : `/v1/clusterprofiles/${uid}`
}

export const clusterProfilesUpdate = async (uid: string,
    clusterProfileUpdateEntity: ClusterProfileUpdateEntity,
    params?: ClusterProfilesUpdateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUpdateUrl(uid,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterProfileUpdateEntity,)
  }
);}



/**
 * @summary Creates a clone of the specified cluster profile
 */
export const getClusterProfilesUidCloneUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/clone`
}

export const clusterProfilesUidClone = async (uid: string,
    clusterProfileCloneEntity: ClusterProfileCloneEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterProfilesUidCloneUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterProfileCloneEntity,)
  }
);}



/**
 * Validates the cloned cluster profile name, version and target project uid
 * @summary Validates the cluster profile clone
 */
export const getClusterProfilesUidCloneValidateUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/clone/validate`
}

export const clusterProfilesUidCloneValidate = async (uid: string,
    clusterProfileCloneMetaInputEntity: ClusterProfileCloneMetaInputEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUidCloneValidateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterProfileCloneMetaInputEntity,)
  }
);}



/**
 * @summary Export the specified cluster profile
 */
export const getV1ClusterProfilesUidExportUrl = (uid: string,
    params?: V1ClusterProfilesUidExportParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/export?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/export`
}

export const v1ClusterProfilesUidExport = async (uid: string,
    params?: V1ClusterProfilesUidExportParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getV1ClusterProfilesUidExportUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Downloads the specified cluster profile
 */
export const getV1ClusterProfilesUidExportTerraformUrl = (uid: string,
    params?: V1ClusterProfilesUidExportTerraformParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/export/terraform?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/export/terraform`
}

export const v1ClusterProfilesUidExportTerraform = async (uid: string,
    params?: V1ClusterProfilesUidExportTerraformParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getV1ClusterProfilesUidExportTerraformUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified cluster profile metadata
 */
export const getClusterProfilesUidMetadataUpdateUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/metadata`
}

export const clusterProfilesUidMetadataUpdate = async (uid: string,
    profileMetaEntity: ProfileMetaEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUidMetadataUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      profileMetaEntity,)
  }
);}



/**
 * @summary Updates cluster profile packs ref
 */
export const getClusterProfilesPacksRefUpdateUrl = (uid: string,
    params?: ClusterProfilesPacksRefUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/packRefs?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/packRefs`
}

export const clusterProfilesPacksRefUpdate = async (uid: string,
    params?: ClusterProfilesPacksRefUpdateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesPacksRefUpdateUrl(uid,params),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Returns the specified cluster profile packs
 */
export const getClusterProfilesUidPacksGetUrl = (uid: string,
    params?: ClusterProfilesUidPacksGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/packs?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/packs`
}

export const clusterProfilesUidPacksGet = async (uid: string,
    params?: ClusterProfilesUidPacksGetParams, options?: RequestInit): Promise<ClusterProfilePacksEntities> => {
  
  return customFetch<ClusterProfilePacksEntities>(getClusterProfilesUidPacksGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds a new pack to the specified cluster profile and returns the created pack uid
 */
export const getClusterProfilesUidPacksAddUrl = (uid: string,
    params?: ClusterProfilesUidPacksAddParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/packs?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/packs`
}

export const clusterProfilesUidPacksAdd = async (uid: string,
    packInputEntity: PackInputEntity,
    params?: ClusterProfilesUidPacksAddParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterProfilesUidPacksAddUrl(uid,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      packInputEntity,)
  }
);}



/**
 * @summary Returns the specified cluster profile pack manifests
 */
export const getClusterProfilesUidPacksManifestsGetUrl = (uid: string,
    params?: ClusterProfilesUidPacksManifestsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/packs/manifests?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/packs/manifests`
}

export const clusterProfilesUidPacksManifestsGet = async (uid: string,
    params?: ClusterProfilesUidPacksManifestsGetParams, options?: RequestInit): Promise<ClusterProfilePacksManifests> => {
  
  return customFetch<ClusterProfilePacksManifests>(getClusterProfilesUidPacksManifestsGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified cluster profile packs resolved values
 */
export const getClusterProfilesUidPacksResolvedValuesGetUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/resolvedValues`
}

export const clusterProfilesUidPacksResolvedValuesGet = async (uid: string, options?: RequestInit): Promise<PackResolvedValues> => {
  
  return customFetch<PackResolvedValues>(getClusterProfilesUidPacksResolvedValuesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified pack information in the cluster profile
 */
export const getClusterProfilesUidPacksNameDeleteUrl = (uid: string,
    packName: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}`
}

export const clusterProfilesUidPacksNameDelete = async (uid: string,
    packName: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUidPacksNameDeleteUrl(uid,packName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster profile pack
 */
export const getV1ClusterProfilesUidPacksNameGetUrl = (uid: string,
    packName: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}`
}

export const v1ClusterProfilesUidPacksNameGet = async (uid: string,
    packName: string, options?: RequestInit): Promise<PackRefSummaryResponse> => {
  
  return customFetch<PackRefSummaryResponse>(getV1ClusterProfilesUidPacksNameGetUrl(uid,packName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified pack information in the cluster profile
 */
export const getClusterProfilesUidPacksNameUpdateUrl = (uid: string,
    packName: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}`
}

export const clusterProfilesUidPacksNameUpdate = async (uid: string,
    packName: string,
    packUpdateEntity: PackUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUidPacksNameUpdateUrl(uid,packName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      packUpdateEntity,)
  }
);}



/**
 * @summary Returns the specified cluster profile pack configuration
 */
export const getClusterProfilesUidPacksConfigGetUrl = (uid: string,
    packName: string,
    params: ClusterProfilesUidPacksConfigGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/clusterprofiles/${uid}/packs/${packName}/config?${stringifiedParams}` : `/v1/clusterprofiles/${uid}/packs/${packName}/config`
}

export const clusterProfilesUidPacksConfigGet = async (uid: string,
    packName: string,
    params: ClusterProfilesUidPacksConfigGetParams, options?: RequestInit): Promise<ClusterProfilePackConfigList> => {
  
  return customFetch<ClusterProfilePackConfigList>(getClusterProfilesUidPacksConfigGetUrl(uid,packName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the associated manifests for the specified profile's pack
 */
export const getClusterProfilesUidPacksUidManifestsUrl = (uid: string,
    packName: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}/manifests`
}

export const clusterProfilesUidPacksUidManifests = async (uid: string,
    packName: string, options?: RequestInit): Promise<ManifestEntities> => {
  
  return customFetch<ManifestEntities>(getClusterProfilesUidPacksUidManifestsUrl(uid,packName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Adds manifest to the profiles packs and returns the added manifests uid
 */
export const getClusterProfilesUidPacksNameManifestsAddUrl = (uid: string,
    packName: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}/manifests`
}

export const clusterProfilesUidPacksNameManifestsAdd = async (uid: string,
    packName: string,
    v1ManifestInputEntityBody: V1ManifestInputEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterProfilesUidPacksNameManifestsAddUrl(uid,packName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ManifestInputEntityBody,)
  }
);}



/**
 * @summary Deletes the specified cluster profile pack manifest
 */
export const getClusterProfilesUidPacksNameManifestsUidDeleteUrl = (uid: string,
    packName: string,
    manifestUid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}/manifests/${manifestUid}`
}

export const clusterProfilesUidPacksNameManifestsUidDelete = async (uid: string,
    packName: string,
    manifestUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUidPacksNameManifestsUidDeleteUrl(uid,packName,manifestUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster profile pack manifest
 */
export const getClusterProfilesUidPacksNameManifestsUidGetUrl = (uid: string,
    packName: string,
    manifestUid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}/manifests/${manifestUid}`
}

export const clusterProfilesUidPacksNameManifestsUidGet = async (uid: string,
    packName: string,
    manifestUid: string, options?: RequestInit): Promise<ManifestEntity> => {
  
  return customFetch<ManifestEntity>(getClusterProfilesUidPacksNameManifestsUidGetUrl(uid,packName,manifestUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified manifest of the profile's pack
 */
export const getClusterProfilesUidPacksNameManifestsUidUpdateUrl = (uid: string,
    packName: string,
    manifestUid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/packs/${packName}/manifests/${manifestUid}`
}

export const clusterProfilesUidPacksNameManifestsUidUpdate = async (uid: string,
    packName: string,
    manifestUid: string,
    v1ManifestInputEntityBody: V1ManifestInputEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesUidPacksNameManifestsUidUpdateUrl(uid,packName,manifestUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ManifestInputEntityBody,)
  }
);}



/**
 * Publish the draft cluster profile with next revision, the current draft cluster profile will be marked to published
and the draft cluster profile will be set to null in the cluster profile template.

 * @summary Publishes the specified cluster profile
 */
export const getClusterProfilesPublishUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/publish`
}

export const clusterProfilesPublish = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterProfilesPublishUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Downloads the specified cluster profile
 */
export const getClusterProfilesUidSpcDownloadUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/spc/download`
}

export const clusterProfilesUidSpcDownload = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getClusterProfilesUidSpcDownloadUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates specified cluster profile packs
 */
export const getClusterProfilesUidValidatePacksUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/validate/packs`
}

export const clusterProfilesUidValidatePacks = async (uid: string,
    v1ClusterProfileTemplateDraftBody: V1ClusterProfileTemplateDraftBody, options?: RequestInit): Promise<ClusterProfileValidatorResponse> => {
  
  return customFetch<ClusterProfileValidatorResponse>(getClusterProfilesUidValidatePacksUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterProfileTemplateDraftBody,)
  }
);}



/**
 * @summary Deletes the specified cluster profile variables
 */
export const getV1ClusterProfilesUidVariablesDeleteUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/variables`
}

export const v1ClusterProfilesUidVariablesDelete = async (uid: string,
    variableNames: VariableNames, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterProfilesUidVariablesDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      variableNames,)
  }
);}



/**
 * @summary Retrieve a list of variables defined for the cluster profile
 */
export const getV1ClusterProfilesUidVariablesGetUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/variables`
}

export const v1ClusterProfilesUidVariablesGet = async (uid: string, options?: RequestInit): Promise<Variables> => {
  
  return customFetch<Variables>(getV1ClusterProfilesUidVariablesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update specific variables defined for a cluster profile
 */
export const getV1ClusterProfilesUidVariablesPatchUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/variables`
}

export const v1ClusterProfilesUidVariablesPatch = async (uid: string,
    v1VariablesBody: V1VariablesBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterProfilesUidVariablesPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VariablesBody,)
  }
);}



/**
 * @summary Update the variables defined for a cluster profile
 */
export const getV1ClusterProfilesUidVariablesPutUrl = (uid: string,) => {


  

  return `/v1/clusterprofiles/${uid}/variables`
}

export const v1ClusterProfilesUidVariablesPut = async (uid: string,
    v1VariablesBody: V1VariablesBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterProfilesUidVariablesPutUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VariablesBody,)
  }
);}



/**
 * @summary Retrieves a list of application deployments filter summary Supported filter fields - ["appDeploymentName", "clusterUid", "tags"] Supported sort fields - ["appDeploymentName", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getDashboardAppDeploymentsUrl = (params?: DashboardAppDeploymentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/appDeployments?${stringifiedParams}` : `/v1/dashboard/appDeployments`
}

export const dashboardAppDeployments = async (appDeploymentsFilterSpec: AppDeploymentsFilterSpec,
    params?: DashboardAppDeploymentsParams, options?: RequestInit): Promise<AppDeploymentsSummary> => {
  
  return customFetch<AppDeploymentsSummary>(getDashboardAppDeploymentsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appDeploymentsFilterSpec,)
  }
);}



/**
 * @summary Retrieves a list of application profiles filter summary Supported filter fields - ["profileName", "tags"] Supported sort fields - ["profileName", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getDashboardAppProfilesUrl = (params?: DashboardAppProfilesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/appProfiles?${stringifiedParams}` : `/v1/dashboard/appProfiles`
}

export const dashboardAppProfiles = async (appProfilesFilterSpec: AppProfilesFilterSpec,
    params?: DashboardAppProfilesParams, options?: RequestInit): Promise<AppProfilesSummary> => {
  
  return customFetch<AppProfilesSummary>(getDashboardAppProfilesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appProfilesFilterSpec,)
  }
);}



/**
 * @summary Retrieves a list of application profile metadata
 */
export const getDashboardAppProfilesMetadataUrl = () => {


  

  return `/v1/dashboard/appProfiles/metadata`
}

export const dashboardAppProfilesMetadata = async ( options?: RequestInit): Promise<AppProfilesMetadata> => {
  
  return customFetch<AppProfilesMetadata>(getDashboardAppProfilesMetadataUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of edgehosts summary
 */
export const getEdgeHostsMetadataUrl = () => {


  

  return `/v1/dashboard/appliances/metadata`
}

export const edgeHostsMetadata = async (edgeHostsMetadataFilter: EdgeHostsMetadataFilter, options?: RequestInit): Promise<EdgeHostsMetadataSummary> => {
  
  return customFetch<EdgeHostsMetadataSummary>(getEdgeHostsMetadataUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostsMetadataFilter,)
  }
);}



/**
 * @summary Retrieves a list of cloud accounts metadata
 */
export const getDashboardCloudAccountsMetadataUrl = (params?: DashboardCloudAccountsMetadataParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/cloudaccounts/metadata?${stringifiedParams}` : `/v1/dashboard/cloudaccounts/metadata`
}

export const dashboardCloudAccountsMetadata = async (params?: DashboardCloudAccountsMetadataParams, options?: RequestInit): Promise<CloudAccountsMetadata> => {
  
  return customFetch<CloudAccountsMetadata>(getDashboardCloudAccountsMetadataUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cluster templates filter summary Supported filter fields - ["clusterTemplateName", "tags", "cloudType","projectUid", "policyUid"] Supported sort fields - ["clusterTemplateName", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getClusterTemplatesFilterSummaryUrl = (params?: ClusterTemplatesFilterSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/clusterTemplates?${stringifiedParams}` : `/v1/dashboard/clusterTemplates`
}

export const clusterTemplatesFilterSummary = async (clusterTemplatesFilterSummarySpec: ClusterTemplatesFilterSummarySpec,
    params?: ClusterTemplatesFilterSummaryParams, options?: RequestInit): Promise<ClusterTemplatesSummary> => {
  
  return customFetch<ClusterTemplatesSummary>(getClusterTemplatesFilterSummaryUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplatesFilterSummarySpec,)
  }
);}



/**
 * @summary Retrieves a list of all cluster template metadata.
 */
export const getClusterTemplatesMetadataGetUrl = () => {


  

  return `/v1/dashboard/clusterTemplates/metadata`
}

export const clusterTemplatesMetadataGet = async ( options?: RequestInit): Promise<ClusterTemplatesMetadata> => {
  
  return customFetch<ClusterTemplatesMetadata>(getClusterTemplatesMetadataGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves spectroclusters meta information for clusters launched using the specified cluster template.
 */
export const getClusterTemplatesUidSpectroclustersMetaGetUrl = (uid: string,) => {


  

  return `/v1/dashboard/clusterTemplates/${uid}/spectroclusters/meta`
}

export const clusterTemplatesUidSpectroclustersMetaGet = async (uid: string, options?: RequestInit): Promise<SpectroClustersMeta> => {
  
  return customFetch<SpectroClustersMeta>(getClusterTemplatesUidSpectroclustersMetaGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cluster summary for a given cluster group
 */
export const getClusterGroupUidHostClustersSummaryUrl = (uid: string,
    params?: ClusterGroupUidHostClustersSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/clustergroups/${uid}/hostClusters?${stringifiedParams}` : `/v1/dashboard/clustergroups/${uid}/hostClusters`
}

export const clusterGroupUidHostClustersSummary = async (uid: string,
    v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody,
    params?: ClusterGroupUidHostClustersSummaryParams, options?: RequestInit): Promise<SpectroClustersSummary> => {
  
  return customFetch<SpectroClustersSummary>(getClusterGroupUidHostClustersSummaryUrl(uid,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Retrieves a list of cluster summary for a given cluster group
 */
export const getClusterGroupUidVirtualClustersSummaryUrl = (uid: string,
    params?: ClusterGroupUidVirtualClustersSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/clustergroups/${uid}/virtualClusters?${stringifiedParams}` : `/v1/dashboard/clustergroups/${uid}/virtualClusters`
}

export const clusterGroupUidVirtualClustersSummary = async (uid: string,
    v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody,
    params?: ClusterGroupUidVirtualClustersSummaryParams, options?: RequestInit): Promise<SpectroClustersSummary> => {
  
  return customFetch<SpectroClustersSummary>(getClusterGroupUidVirtualClustersSummaryUrl(uid,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Retrieves a list of cluster profiles filter summary Supported filter fields - ['profileName', 'tags', 'profileType', 'environment', 'resourceType'] Supported sort fields - ['profileName', 'environment', 'profileType', 'creationTimestamp', 'lastModifiedTimestamp']
 */
export const getClusterProfilesFilterSummaryUrl = (params?: ClusterProfilesFilterSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/clusterprofiles?${stringifiedParams}` : `/v1/dashboard/clusterprofiles`
}

export const clusterProfilesFilterSummary = async (clusterProfilesFilterSpec: ClusterProfilesFilterSpec,
    params?: ClusterProfilesFilterSummaryParams, options?: RequestInit): Promise<ClusterProfilesSummary> => {
  
  return customFetch<ClusterProfilesSummary>(getClusterProfilesFilterSummaryUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterProfilesFilterSpec,)
  }
);}



/**
 * @summary Retrieves a list of cluster profiles metadata
 */
export const getClusterProfilesMetadataUrl = () => {


  

  return `/v1/dashboard/clusterprofiles/metadata`
}

export const clusterProfilesMetadata = async ( options?: RequestInit): Promise<ClusterProfilesMetadata> => {
  
  return customFetch<ClusterProfilesMetadata>(getClusterProfilesMetadataUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a specified cluster profile summary
 */
export const getClusterProfilesUidSummaryUrl = (uid: string,) => {


  

  return `/v1/dashboard/clusterprofiles/${uid}`
}

export const clusterProfilesUidSummary = async (uid: string, options?: RequestInit): Promise<ClusterProfileSummary> => {
  
  return customFetch<ClusterProfileSummary>(getClusterProfilesUidSummaryUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Edgehosts summary with provided search filter. Supported fields as per schema /v1/dashboard/edgehosts/search/schema
 */
export const getDashboardEdgehostsSearchUrl = (params?: DashboardEdgehostsSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/edgehosts/search?${stringifiedParams}` : `/v1/dashboard/edgehosts/search`
}

export const dashboardEdgehostsSearch = async (v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody,
    params?: DashboardEdgehostsSearchParams, options?: RequestInit): Promise<EdgeHostsSearchSummary> => {
  
  return customFetch<EdgeHostsSearchSummary>(getDashboardEdgehostsSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Retrieves a schema for the Edgehost search filter
 */
export const getDashboardEdgehostsSearchSchemaGetUrl = () => {


  

  return `/v1/dashboard/edgehosts/search/schema`
}

export const dashboardEdgehostsSearchSchemaGet = async ( options?: RequestInit): Promise<SearchFilterSchemaSpec> => {
  
  return customFetch<SearchFilterSchemaSpec>(getDashboardEdgehostsSearchSchemaGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of PCG summary with provided search filter. Supported fields as per schema /v1/dashboard/pcgs/search/schema
 */
export const getDashboardPcgsSearchSummaryUrl = (params?: DashboardPcgsSearchSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/pcgs/search?${stringifiedParams}` : `/v1/dashboard/pcgs/search`
}

export const dashboardPcgsSearchSummary = async (v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody,
    params?: DashboardPcgsSearchSummaryParams, options?: RequestInit): Promise<PcgsSummary> => {
  
  return customFetch<PcgsSummary>(getDashboardPcgsSearchSummaryUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Retrieves a schema for the PCG search filter
 */
export const getDashboardPcgSearchSchemaGetUrl = () => {


  

  return `/v1/dashboard/pcgs/search/schema`
}

export const dashboardPcgSearchSchemaGet = async ( options?: RequestInit): Promise<SearchFilterSchemaSpec> => {
  
  return customFetch<SearchFilterSchemaSpec>(getDashboardPcgSearchSchemaGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getProjectsFilterSummaryUrl = (params?: ProjectsFilterSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/projects?${stringifiedParams}` : `/v1/dashboard/projects`
}

export const projectsFilterSummary = async (projectsFilterSpec: ProjectsFilterSpec,
    params?: ProjectsFilterSummaryParams, options?: RequestInit): Promise<ProjectsSummary> => {
  
  return customFetch<ProjectsSummary>(getProjectsFilterSummaryUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectsFilterSpec,)
  }
);}



/**
 * @summary Retrieves a list of projects metadata
 */
export const getProjectsMetadataUrl = (params?: ProjectsMetadataParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/projects/metadata?${stringifiedParams}` : `/v1/dashboard/projects/metadata`
}

export const projectsMetadata = async (params?: ProjectsMetadataParams, options?: RequestInit): Promise<ProjectsMetadata> => {
  
  return customFetch<ProjectsMetadata>(getProjectsMetadataUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of spc policies filter summary Supported filter fields - ["policyName", "tags", "policyType"] Supported sort fields - ["policyName", "policyType", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getSpcPoliciesFilterSummaryUrl = (params?: SpcPoliciesFilterSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spcPolicies?${stringifiedParams}` : `/v1/dashboard/spcPolicies`
}

export const spcPoliciesFilterSummary = async (spcPoliciesFilterSpec: SpcPoliciesFilterSpec,
    params?: SpcPoliciesFilterSummaryParams, options?: RequestInit): Promise<SpcPoliciesSummary> => {
  
  return customFetch<SpcPoliciesSummary>(getSpcPoliciesFilterSummaryUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spcPoliciesFilterSpec,)
  }
);}



/**
 * @summary Retrieves a list of all spc policies metadata.
 */
export const getSpcPoliciesMetadataGetUrl = () => {


  

  return `/v1/dashboard/spcPolicies/metadata`
}

export const spcPoliciesMetadataGet = async ( options?: RequestInit): Promise<SpcPoliciesMetadata> => {
  
  return customFetch<SpcPoliciesMetadata>(getSpcPoliciesMetadataGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves spectro clusters cloud cost summary information
 */
export const getDashboardSpectroClustersCostSummaryUrl = () => {


  

  return `/v1/dashboard/spectroclusters/cost`
}

export const dashboardSpectroClustersCostSummary = async (spectroClusterCloudCostSummarySpec: SpectroClusterCloudCostSummarySpec, options?: RequestInit): Promise<ResourcesCloudCostSummary> => {
  
  return customFetch<ResourcesCloudCostSummary>(getDashboardSpectroClustersCostSummaryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterCloudCostSummarySpec,)
  }
);}



/**
 * @summary Retrieves a list of running, non rbac configured clusters in a workspace
 */
export const getSpectroClustersFiltersWorkspaceUrl = (params?: SpectroClustersFiltersWorkspaceParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/filters/workspace?${stringifiedParams}` : `/v1/dashboard/spectroclusters/filters/workspace`
}

export const spectroClustersFiltersWorkspace = async (params?: SpectroClustersFiltersWorkspaceParams, options?: RequestInit): Promise<SpectroClustersSummary> => {
  
  return customFetch<SpectroClustersSummary>(getSpectroClustersFiltersWorkspaceUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns metadata information for all clusters
 * @summary Get all clusters metadata
 */
export const getSpectroClustersMetaGetUrl = () => {


  

  return `/v1/dashboard/spectroclusters/meta`
}

export const spectroClustersMetaGet = async ( options?: RequestInit): Promise<SpectroClustersMeta> => {
  
  return customFetch<SpectroClustersMeta>(getSpectroClustersMetaGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cluster summary metadata
 */
export const getSpectroClustersMetadataGetUrl = (params?: SpectroClustersMetadataGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/metadata?${stringifiedParams}` : `/v1/dashboard/spectroclusters/metadata`
}

export const spectroClustersMetadataGet = async (params?: SpectroClustersMetadataGetParams, options?: RequestInit): Promise<SpectroClustersMetadata> => {
  
  return customFetch<SpectroClustersMetadata>(getSpectroClustersMetadataGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of cluster summary
 */
export const getSpectroClustersMetadataUrl = () => {


  

  return `/v1/dashboard/spectroclusters/metadata`
}

export const spectroClustersMetadata = async (spectroClusterMetadataSpec: SpectroClusterMetadataSpec, options?: RequestInit): Promise<SpectroClustersMetadata> => {
  
  return customFetch<SpectroClustersMetadata>(getSpectroClustersMetadataUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterMetadataSpec,)
  }
);}



/**
 * @summary Retrieves a list of cluster metadata with provided search filter spec Supported sort fields - ["environment", "clusterName", "clusterState", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getSpectroClustersMetadataSearchUrl = () => {


  

  return `/v1/dashboard/spectroclusters/metadata/search`
}

export const spectroClustersMetadataSearch = async (v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody, options?: RequestInit): Promise<SpectroClustersMetadataSearch> => {
  
  return customFetch<SpectroClustersMetadataSearch>(getSpectroClustersMetadataSearchUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Retrieves a schema for the cluster metadata search filter
 */
export const getSpectroClustersMetadataSearchSchemaUrl = () => {


  

  return `/v1/dashboard/spectroclusters/metadata/search/schema`
}

export const spectroClustersMetadataSearchSchema = async ( options?: RequestInit): Promise<SearchFilterSchemaSpec> => {
  
  return customFetch<SearchFilterSchemaSpec>(getSpectroClustersMetadataSearchSchemaUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of clusters with the desired repave state
 */
export const getDashboardSpectroClustersRepaveListUrl = (params?: DashboardSpectroClustersRepaveListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/repaveStatus?${stringifiedParams}` : `/v1/dashboard/spectroclusters/repaveStatus`
}

export const dashboardSpectroClustersRepaveList = async (params?: DashboardSpectroClustersRepaveListParams, options?: RequestInit): Promise<SpectroClustersSummary> => {
  
  return customFetch<SpectroClustersSummary>(getDashboardSpectroClustersRepaveListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves spectro clusters resource consumption
 */
export const getSpectroClustersResourcesConsumptionUrl = () => {


  

  return `/v1/dashboard/spectroclusters/resources/consumption`
}

export const spectroClustersResourcesConsumption = async (v1ResourceConsumptionSpecBody: V1ResourceConsumptionSpecBody, options?: RequestInit): Promise<ResourcesConsumption> => {
  
  return customFetch<ResourcesConsumption>(getSpectroClustersResourcesConsumptionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ResourceConsumptionSpecBody,)
  }
);}



/**
 * @summary Retrieves spectro clusters resources cost summary information
 */
export const getSpectroClustersResourcesCostSummaryUrl = () => {


  

  return `/v1/dashboard/spectroclusters/resources/cost`
}

export const spectroClustersResourcesCostSummary = async (resourceCostSummarySpec: ResourceCostSummarySpec, options?: RequestInit): Promise<ResourcesCostSummary> => {
  
  return customFetch<ResourcesCostSummary>(getSpectroClustersResourcesCostSummaryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      resourceCostSummarySpec,)
  }
);}



/**
 * @summary Retrieves spectro clusters resources usage summary information
 */
export const getSpectroClustersResourcesUsageSummaryUrl = () => {


  

  return `/v1/dashboard/spectroclusters/resources/usage`
}

export const spectroClustersResourcesUsageSummary = async (resourceUsageSummarySpec: ResourceUsageSummarySpec, options?: RequestInit): Promise<ResourcesUsageSummary> => {
  
  return customFetch<ResourcesUsageSummary>(getSpectroClustersResourcesUsageSummaryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      resourceUsageSummarySpec,)
  }
);}



/**
 * @summary Retrieves a list of cluster summary with provided search filter spec Supported sort fields - ["environment", "clusterName", "memoryUsage", "healthState", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getSpectroClustersSearchFilterSummaryUrl = (params?: SpectroClustersSearchFilterSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/search?${stringifiedParams}` : `/v1/dashboard/spectroclusters/search`
}

export const spectroClustersSearchFilterSummary = async (v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody,
    params?: SpectroClustersSearchFilterSummaryParams, options?: RequestInit): Promise<SpectroClustersSummary> => {
  
  return customFetch<SpectroClustersSummary>(getSpectroClustersSearchFilterSummaryUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Export and download the list of cluster summary with matching search filter and download as a file(csv)
 */
export const getDashboardClustersSearchSummaryExportGetUrl = (params?: DashboardClustersSearchSummaryExportGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/search/export?${stringifiedParams}` : `/v1/dashboard/spectroclusters/search/export`
}

export const dashboardClustersSearchSummaryExportGet = async (params?: DashboardClustersSearchSummaryExportGetParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getDashboardClustersSearchSummaryExportGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Export the list of cluster summary with matching search filter and download as a file(csv) Supported sort fields - ["environment", "clusterName", "healthState", "creationTimestamp", "lastModifiedTimestamp"]
 */
export const getDashboardClustersSearchSummaryExportUrl = (params?: DashboardClustersSearchSummaryExportParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/search/export?${stringifiedParams}` : `/v1/dashboard/spectroclusters/search/export`
}

export const dashboardClustersSearchSummaryExport = async (v1SearchFilterSummarySpecBody: V1SearchFilterSummarySpecBody,
    params?: DashboardClustersSearchSummaryExportParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getDashboardClustersSearchSummaryExportUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SearchFilterSummarySpecBody,)
  }
);}



/**
 * @summary Retrieves a supported input values for the cluster search filter
 */
export const getDashboardSpectroClustersSearchInputUrl = () => {


  

  return `/v1/dashboard/spectroclusters/search/input`
}

export const dashboardSpectroClustersSearchInput = async ( options?: RequestInit): Promise<ClusterSearchInputSpec> => {
  
  return customFetch<ClusterSearchInputSpec>(getDashboardSpectroClustersSearchInputUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a schema for the cluster search filter
 */
export const getSpectroClustersSearchSchemaUrl = () => {


  

  return `/v1/dashboard/spectroclusters/search/schema`
}

export const spectroClustersSearchSchema = async ( options?: RequestInit): Promise<SearchFilterSchemaSpec> => {
  
  return customFetch<SearchFilterSchemaSpec>(getSpectroClustersSearchSchemaUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Virtual machine enabled clusters
 */
export const getV1DashboardVMEnabledClustersListUrl = () => {


  

  return `/v1/dashboard/spectroclusters/vms`
}

export const v1DashboardVMEnabledClustersList = async ( options?: RequestInit): Promise<VMClusters> => {
  
  return customFetch<VMClusters>(getV1DashboardVMEnabledClustersListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified cluster summary
 */
export const getSpectroClustersSummaryUidUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}`
}

export const spectroClustersSummaryUid = async (uid: string, options?: RequestInit): Promise<SpectroClusterUidSummary> => {
  
  return customFetch<SpectroClusterUidSummary>(getSpectroClustersSummaryUidUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves the specified cluster cost summary
 */
export const getSpectroClustersUidCostSummaryUrl = (uid: string,
    params?: SpectroClustersUidCostSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/dashboard/spectroclusters/${uid}/cost?${stringifiedParams}` : `/v1/dashboard/spectroclusters/${uid}/cost`
}

export const spectroClustersUidCostSummary = async (uid: string,
    params?: SpectroClustersUidCostSummaryParams, options?: RequestInit): Promise<SpectroClusterCostSummary> => {
  
  return customFetch<SpectroClusterCostSummary>(getSpectroClustersUidCostSummaryUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified cluster summary overview
 */
export const getSpectroClustersSummaryUidOverviewUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/overview`
}

export const spectroClustersSummaryUidOverview = async (uid: string, options?: RequestInit): Promise<SpectroClusterUidSummary> => {
  
  return customFetch<SpectroClusterUidSummary>(getSpectroClustersSummaryUidOverviewUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves specified spectro cluster resource consumption
 */
export const getSpectroClustersUidResourcesConsumptionUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/resources/consumption`
}

export const spectroClustersUidResourcesConsumption = async (uid: string,
    v1ResourceConsumptionSpecBody: V1ResourceConsumptionSpecBody, options?: RequestInit): Promise<ResourcesConsumption> => {
  
  return customFetch<ResourcesConsumption>(getSpectroClustersUidResourcesConsumptionUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ResourceConsumptionSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workloads
 */
export const getDashboardSpectroClustersUidWorkloadsUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads`
}

export const dashboardSpectroClustersUidWorkloads = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkload> => {
  
  return customFetch<ClusterWorkload>(getDashboardSpectroClustersUidWorkloadsUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload clusterrolebindings
 */
export const getDashboardSpectroClustersUidWorkloadsClusterRoleBindingUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/clusterrolebinding`
}

export const dashboardSpectroClustersUidWorkloadsClusterRoleBinding = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadRoleBindings> => {
  
  return customFetch<ClusterWorkloadRoleBindings>(getDashboardSpectroClustersUidWorkloadsClusterRoleBindingUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload cronjobs
 */
export const getDashboardSpectroClustersUidWorkloadsCronJobUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/cronjob`
}

export const dashboardSpectroClustersUidWorkloadsCronJob = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadCronJobs> => {
  
  return customFetch<ClusterWorkloadCronJobs>(getDashboardSpectroClustersUidWorkloadsCronJobUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload daemonsets
 */
export const getDashboardSpectroClustersUidWorkloadsDaemonSetUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/daemonset`
}

export const dashboardSpectroClustersUidWorkloadsDaemonSet = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadDaemonSets> => {
  
  return customFetch<ClusterWorkloadDaemonSets>(getDashboardSpectroClustersUidWorkloadsDaemonSetUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload deployments
 */
export const getDashboardSpectroClustersUidWorkloadsDeploymentUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/deployment`
}

export const dashboardSpectroClustersUidWorkloadsDeployment = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadDeployments> => {
  
  return customFetch<ClusterWorkloadDeployments>(getDashboardSpectroClustersUidWorkloadsDeploymentUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload jobs
 */
export const getDashboardSpectroClustersUidWorkloadsJobUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/job`
}

export const dashboardSpectroClustersUidWorkloadsJob = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadJobs> => {
  
  return customFetch<ClusterWorkloadJobs>(getDashboardSpectroClustersUidWorkloadsJobUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload namespaces
 */
export const getDashboardSpectroClustersUidWorkloadsNamespaceUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/namespace`
}

export const dashboardSpectroClustersUidWorkloadsNamespace = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadNamespaces> => {
  
  return customFetch<ClusterWorkloadNamespaces>(getDashboardSpectroClustersUidWorkloadsNamespaceUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload pods
 */
export const getDashboardSpectroClustersUidWorkloadsPodUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/pod`
}

export const dashboardSpectroClustersUidWorkloadsPod = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadPods> => {
  
  return customFetch<ClusterWorkloadPods>(getDashboardSpectroClustersUidWorkloadsPodUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload rolebindings
 */
export const getDashboardSpectroClustersUidWorkloadsRoleBindingUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/rolebinding`
}

export const dashboardSpectroClustersUidWorkloadsRoleBinding = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadRoleBindings> => {
  
  return customFetch<ClusterWorkloadRoleBindings>(getDashboardSpectroClustersUidWorkloadsRoleBindingUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified cluster workload statefulsets
 */
export const getDashboardSpectroClustersUidWorkloadsStatefulSetUrl = (uid: string,) => {


  

  return `/v1/dashboard/spectroclusters/${uid}/workloads/statefulset`
}

export const dashboardSpectroClustersUidWorkloadsStatefulSet = async (uid: string,
    v1ClusterWorkloadsSpecBody: V1ClusterWorkloadsSpecBody, options?: RequestInit): Promise<ClusterWorkloadStatefulSets> => {
  
  return customFetch<ClusterWorkloadStatefulSets>(getDashboardSpectroClustersUidWorkloadsStatefulSetUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves a list of workspace
 */
export const getDashboardWorkspacesListUrl = () => {


  

  return `/v1/dashboard/workspaces`
}

export const dashboardWorkspacesList = async ( options?: RequestInit): Promise<DashboardWorkspaces> => {
  
  return customFetch<DashboardWorkspaces>(getDashboardWorkspacesListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload clusterrolebindings
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsClusterRoleBindingUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/clusterrolebinding`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsClusterRoleBinding = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadRoleBindings> => {
  
  return customFetch<WorkspaceClustersWorkloadRoleBindings>(getDashboardWorkspacesUidSpectroClustersWorkloadsClusterRoleBindingUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload cronjobs
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsCronJobUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/cronjob`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsCronJob = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadCronJobs> => {
  
  return customFetch<WorkspaceClustersWorkloadCronJobs>(getDashboardWorkspacesUidSpectroClustersWorkloadsCronJobUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload daemonsets
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsDaemonSetUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/daemonset`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsDaemonSet = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadDaemonSets> => {
  
  return customFetch<WorkspaceClustersWorkloadDaemonSets>(getDashboardWorkspacesUidSpectroClustersWorkloadsDaemonSetUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload deployments
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsDeploymentUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/deployment`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsDeployment = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadDeployments> => {
  
  return customFetch<WorkspaceClustersWorkloadDeployments>(getDashboardWorkspacesUidSpectroClustersWorkloadsDeploymentUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload jobs
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsJobUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/job`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsJob = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadJobs> => {
  
  return customFetch<WorkspaceClustersWorkloadJobs>(getDashboardWorkspacesUidSpectroClustersWorkloadsJobUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload namespaces
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsNamespaceUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/namespace`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsNamespace = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadNamespaces> => {
  
  return customFetch<WorkspaceClustersWorkloadNamespaces>(getDashboardWorkspacesUidSpectroClustersWorkloadsNamespaceUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload pods
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsPodUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/pod`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsPod = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadPods> => {
  
  return customFetch<WorkspaceClustersWorkloadPods>(getDashboardWorkspacesUidSpectroClustersWorkloadsPodUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload rolebindings
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsRoleBindingUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/rolebinding`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsRoleBinding = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadRoleBindings> => {
  
  return customFetch<WorkspaceClustersWorkloadRoleBindings>(getDashboardWorkspacesUidSpectroClustersWorkloadsRoleBindingUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * @summary Retrieves specified workspace clusters workload statefulsets
 */
export const getDashboardWorkspacesUidSpectroClustersWorkloadsStatefulSetUrl = (uid: string,) => {


  

  return `/v1/dashboard/workspaces/${uid}/spectroclusters/workloads/statefulset`
}

export const dashboardWorkspacesUidSpectroClustersWorkloadsStatefulSet = async (uid: string,
    v1WorkspaceWorkloadsSpecBody: V1WorkspaceWorkloadsSpecBody, options?: RequestInit): Promise<WorkspaceClustersWorkloadStatefulSets> => {
  
  return customFetch<WorkspaceClustersWorkloadStatefulSets>(getDashboardWorkspacesUidSpectroClustersWorkloadsStatefulSetUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceWorkloadsSpecBody,)
  }
);}



/**
 * Sync data to cloud watch
 * @summary sync data to cloud watch
 */
export const getV1DataSinksCloudWatchSinkUrl = () => {


  

  return `/v1/datasinks/cloudwatch`
}

export const v1DataSinksCloudWatchSink = async (v1DataSinkCloudWatchConfig: V1DataSinkCloudWatchConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1DataSinksCloudWatchSinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1DataSinkCloudWatchConfig,)
  }
);}



/**
 * @summary Create the edge host device
 */
export const getEdgeHostDevicesCreateUrl = () => {


  

  return `/v1/edgehosts`
}

export const edgeHostDevicesCreate = async (edgeHostDeviceEntity: EdgeHostDeviceEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getEdgeHostDevicesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostDeviceEntity,)
  }
);}



/**
 * @summary Retrieves a list of edge hosts metadata matching the filter condition
 */
export const getEdgeHostsMetadataQuickFilterGetUrl = (params?: EdgeHostsMetadataQuickFilterGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/edgehosts/metadata?${stringifiedParams}` : `/v1/edgehosts/metadata`
}

export const edgeHostsMetadataQuickFilterGet = async (params?: EdgeHostsMetadataQuickFilterGetParams, options?: RequestInit): Promise<EdgeHostsMeta> => {
  
  return customFetch<EdgeHostsMeta>(getEdgeHostsMetadataQuickFilterGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Registers the edge host device
 */
export const getEdgeHostDevicesRegisterUrl = () => {


  

  return `/v1/edgehosts/register`
}

export const edgeHostDevicesRegister = async (v1EdgeHostDeviceBody: V1EdgeHostDeviceBody, options?: RequestInit): Promise<EdgeHostDevice> => {
  
  return customFetch<EdgeHostDevice>(getEdgeHostDevicesRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EdgeHostDeviceBody,)
  }
);}



/**
 * @summary Retrieves a list of edge hosts tags
 */
export const getEdgeHostsTagsGetUrl = () => {


  

  return `/v1/edgehosts/tags`
}

export const edgeHostsTagsGet = async ( options?: RequestInit): Promise<EdgeHostsTags> => {
  
  return customFetch<EdgeHostsTags>(getEdgeHostsTagsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of edge tokens
 */
export const getEdgeTokensListUrl = () => {


  

  return `/v1/edgehosts/tokens`
}

export const edgeTokensList = async ( options?: RequestInit): Promise<EdgeTokens> => {
  
  return customFetch<EdgeTokens>(getEdgeTokensListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create the edge token
 */
export const getEdgeTokensCreateUrl = () => {


  

  return `/v1/edgehosts/tokens`
}

export const edgeTokensCreate = async (edgeTokenEntity: EdgeTokenEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getEdgeTokensCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeTokenEntity,)
  }
);}



/**
 * @summary Deletes the specified edge token
 */
export const getEdgeTokensUidDeleteUrl = (uid: string,) => {


  

  return `/v1/edgehosts/tokens/${uid}`
}

export const edgeTokensUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeTokensUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified edge token
 */
export const getEdgeTokensUidGetUrl = (uid: string,) => {


  

  return `/v1/edgehosts/tokens/${uid}`
}

export const edgeTokensUidGet = async (uid: string, options?: RequestInit): Promise<EdgeToken> => {
  
  return customFetch<EdgeToken>(getEdgeTokensUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified edge token
 */
export const getEdgeTokensUidUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/tokens/${uid}`
}

export const edgeTokensUidUpdate = async (uid: string,
    edgeTokenUpdate: EdgeTokenUpdate, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeTokensUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeTokenUpdate,)
  }
);}



/**
 * @summary Revoke or re-activate the edge token access
 */
export const getEdgeTokensUidStateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/tokens/${uid}/state`
}

export const edgeTokensUidState = async (uid: string,
    edgeTokenActiveState: EdgeTokenActiveState, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeTokensUidStateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeTokenActiveState,)
  }
);}



/**
 * @summary Deletes the specified edge host device
 */
export const getEdgeHostDevicesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}`
}

export const edgeHostDevicesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified edge host device
 */
export const getEdgeHostDevicesUidGetUrl = (uid: string,
    params?: EdgeHostDevicesUidGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/edgehosts/${uid}?${stringifiedParams}` : `/v1/edgehosts/${uid}`
}

export const edgeHostDevicesUidGet = async (uid: string,
    params?: EdgeHostDevicesUidGetParams, options?: RequestInit): Promise<EdgeHostDevice> => {
  
  return customFetch<EdgeHostDevice>(getEdgeHostDevicesUidGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified edge host device
 */
export const getEdgeHostDevicesUidUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}`
}

export const edgeHostDevicesUidUpdate = async (uid: string,
    v1EdgeHostDeviceBody: V1EdgeHostDeviceBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EdgeHostDeviceBody,)
  }
);}



/**
 * @summary Deassociate the clusters to the edge host
 */
export const getEdgeHostDevicesUidClusterDeassociateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/cluster/associate`
}

export const edgeHostDevicesUidClusterDeassociate = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidClusterDeassociateUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Associate the clusters to the edge host
 */
export const getEdgeHostDevicesUidClusterAssociateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/cluster/associate`
}

export const edgeHostDevicesUidClusterAssociate = async (uid: string,
    edgeHostClusterEntity: EdgeHostClusterEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidClusterAssociateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostClusterEntity,)
  }
);}



/**
 * @summary Get the specified edge host device configuration
 */
export const getEdgeHostDevicesUidConfigGetUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/config`
}

export const edgeHostDevicesUidConfigGet = async (uid: string, options?: RequestInit): Promise<EdgeHostConfig> => {
  
  return customFetch<EdgeHostConfig>(getEdgeHostDevicesUidConfigGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the edge host health
 */
export const getEdgeHostDevicesHealthUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/health`
}

export const edgeHostDevicesHealthUpdate = async (uid: string,
    edgeHostHealth: EdgeHostHealth, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesHealthUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostHealth,)
  }
);}



/**
 * @summary Update the specified edge host device host check sum
 */
export const getEdgeHostDeviceHostCheckSumUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/hostCheckSum`
}

export const edgeHostDeviceHostCheckSumUpdate = async (uid: string,
    edgeHostDeviceHostCheckSum: EdgeHostDeviceHostCheckSum, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDeviceHostCheckSumUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostDeviceHostCheckSum,)
  }
);}



/**
 * @summary Update the specified edge host device host pairing key
 */
export const getEdgeHostDeviceHostPairingKeyUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/hostPairingKey`
}

export const edgeHostDeviceHostPairingKeyUpdate = async (uid: string,
    edgeHostDeviceHostPairingKey: EdgeHostDeviceHostPairingKey, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDeviceHostPairingKeyUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostDeviceHostPairingKey,)
  }
);}



/**
 * @summary Updates the specified edge host device meta
 */
export const getEdgeHostDevicesUidMetaUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/meta`
}

export const edgeHostDevicesUidMetaUpdate = async (uid: string,
    edgeHostDeviceMetaUpdateEntity: EdgeHostDeviceMetaUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidMetaUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostDeviceMetaUpdateEntity,)
  }
);}



/**
 * @summary Returns the specified edge host's manifest
 */
export const getEdgeHostDevicesUidPackManifestsUidGetUrl = (uid: string,
    manifestUid: string,
    params?: EdgeHostDevicesUidPackManifestsUidGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/edgehosts/${uid}/pack/manifests/${manifestUid}?${stringifiedParams}` : `/v1/edgehosts/${uid}/pack/manifests/${manifestUid}`
}

export const edgeHostDevicesUidPackManifestsUidGet = async (uid: string,
    manifestUid: string,
    params?: EdgeHostDevicesUidPackManifestsUidGetParams, options?: RequestInit): Promise<Manifest> => {
  
  return customFetch<Manifest>(getEdgeHostDevicesUidPackManifestsUidGetUrl(uid,manifestUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Patch update specified edge host's packs status
 */
export const getEdgeHostDevicesUidPacksStatusPatchUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/packs/status`
}

export const edgeHostDevicesUidPacksStatusPatch = async (uid: string,
    v1SpectroClusterPacksStatusEntityBody: V1SpectroClusterPacksStatusEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidPacksStatusPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterPacksStatusEntityBody,)
  }
);}



/**
 * @summary Returns the associated profiles of a specified edge host device
 */
export const getEdgeHostDevicesUidProfilesGetUrl = (uid: string,
    params?: EdgeHostDevicesUidProfilesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/edgehosts/${uid}/profiles?${stringifiedParams}` : `/v1/edgehosts/${uid}/profiles`
}

export const edgeHostDevicesUidProfilesGet = async (uid: string,
    params?: EdgeHostDevicesUidProfilesGetParams, options?: RequestInit): Promise<SpectroClusterProfileList> => {
  
  return customFetch<SpectroClusterProfileList>(getEdgeHostDevicesUidProfilesGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Associate cluster profiles to the specified edge host device
 */
export const getEdgeHostDevicesUidProfilesUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/profiles`
}

export const edgeHostDevicesUidProfilesUpdate = async (uid: string,
    v1SpectroClusterProfilesBody: V1SpectroClusterProfilesBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidProfilesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterProfilesBody,)
  }
);}



/**
 * @summary Reset the cluster through edge host
 */
export const getV1EdgeHostsUidResetUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/reset`
}

export const v1EdgeHostsUidReset = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1EdgeHostsUidResetUrl(uid),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Download the specified edge host device spc
 */
export const getEdgeHostDevicesUidSpcDownloadUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/spc/download`
}

export const edgeHostDevicesUidSpcDownload = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getEdgeHostDevicesUidSpcDownloadUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified edge host device tunnel configuration
 */
export const getEdgeHostDevicesUidTunnelConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/tunnelConfig`
}

export const edgeHostDevicesUidTunnelConfigUpdate = async (uid: string,
    spectroTunnelConfig: SpectroTunnelConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidTunnelConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroTunnelConfig,)
  }
);}



/**
 * @summary Updates the edge host tunnel status
 */
export const getEdgeHostDevicesUidTunnelStatusUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/tunnelStatus`
}

export const edgeHostDevicesUidTunnelStatusUpdate = async (uid: string,
    spectroTunnelStatus: SpectroTunnelStatus, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidTunnelStatusUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroTunnelStatus,)
  }
);}



/**
 * @summary Updates the specified edge host device vsphere properties
 */
export const getEdgeHostDevicesUidVspherePropertiesUpdateUrl = (uid: string,) => {


  

  return `/v1/edgehosts/${uid}/vsphere/properties`
}

export const edgeHostDevicesUidVspherePropertiesUpdate = async (uid: string,
    edgeHostVsphereCloudProperties: EdgeHostVsphereCloudProperties, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEdgeHostDevicesUidVspherePropertiesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      edgeHostVsphereCloudProperties,)
  }
);}



/**
 * Returns a paginated list of component events based on request parameters
 * @summary Returns a paginated list of component events based on request parameters
 */
export const getEventsComponentsListUrl = (params?: EventsComponentsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/events/components?${stringifiedParams}` : `/v1/events/components`
}

export const eventsComponentsList = async (params?: EventsComponentsListParams, options?: RequestInit): Promise<Events> => {
  
  return customFetch<Events>(getEventsComponentsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a component event
 * @summary Creates a component event
 */
export const getEventsComponentsCreateUrl = () => {


  

  return `/v1/events/components`
}

export const eventsComponentsCreate = async (event: Event, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getEventsComponentsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      event,)
  }
);}



/**
 * Creates the component events in bulk
 * @summary Creates the component events in bulk
 */
export const getEventsComponentsCreateBulkUrl = () => {


  

  return `/v1/events/components/bulk`
}

export const eventsComponentsCreateBulk = async (bulkEvents: BulkEvents, options?: RequestInit): Promise<Uids> => {
  
  return customFetch<Uids>(getEventsComponentsCreateBulkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkEvents,)
  }
);}



/**
 * @summary Delete all the components events for the specified related object
 */
export const getEventsComponentsObjTypeUidDeleteUrl = (objectKind: 'spectrocluster' | 'edgehost',
    objectUid: string,) => {


  

  return `/v1/events/components/${objectKind}/${objectUid}`
}

export const eventsComponentsObjTypeUidDelete = async (objectKind: 'spectrocluster' | 'edgehost',
    objectUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEventsComponentsObjTypeUidDeleteUrl(objectKind,objectUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Returns a list of components events for the specified related object
 * @summary Returns a list of components events for the specified related object
 */
export const getEventsComponentsObjTypeUidListUrl = (objectKind: 'spectrocluster' | 'edgehost',
    objectUid: string,
    params?: EventsComponentsObjTypeUidListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/events/components/${objectKind}/${objectUid}?${stringifiedParams}` : `/v1/events/components/${objectKind}/${objectUid}`
}

export const eventsComponentsObjTypeUidList = async (objectKind: 'spectrocluster' | 'edgehost',
    objectUid: string,
    params?: EventsComponentsObjTypeUidListParams, options?: RequestInit): Promise<Events> => {
  
  return customFetch<Events>(getEventsComponentsObjTypeUidListUrl(objectKind,objectUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves the list of features
 */
export const getFeaturesListUrl = () => {


  

  return `/v1/features`
}

export const featuresList = async ( options?: RequestInit): Promise<Features> => {
  
  return customFetch<Features>(getFeaturesListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update a feature
 */
export const getFeaturesUpdateUrl = (uid: string,) => {


  

  return `/v1/features/${uid}`
}

export const featuresUpdate = async (uid: string,
    featureUpdate: FeatureUpdate, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getFeaturesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      featureUpdate,)
  }
);}



/**
 * @summary Returns a list of Filters
 */
export const getFiltersListUrl = (params?: FiltersListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/filters?${stringifiedParams}` : `/v1/filters`
}

export const filtersList = async (params?: FiltersListParams, options?: RequestInit): Promise<FiltersSummary> => {
  
  return customFetch<FiltersSummary>(getFiltersListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns a list of Filters metadata
 */
export const getFiltersMetadataUrl = (params?: FiltersMetadataParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/filters/metadata?${stringifiedParams}` : `/v1/filters/metadata`
}

export const filtersMetadata = async (params?: FiltersMetadataParams, options?: RequestInit): Promise<FiltersMetadata> => {
  
  return customFetch<FiltersMetadata>(getFiltersMetadataUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a Tag filter
 */
export const getTagFiltersCreateUrl = () => {


  

  return `/v1/filters/tag`
}

export const tagFiltersCreate = async (v1TagFilterBody: V1TagFilterBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getTagFiltersCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1TagFilterBody,)
  }
);}



/**
 * @summary Delete the specified Filter object
 */
export const getTagFilterUidDeleteUrl = (uid: string,) => {


  

  return `/v1/filters/tag/${uid}`
}

export const tagFilterUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTagFilterUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified Filter object
 */
export const getTagFilterUidGetUrl = (uid: string,) => {


  

  return `/v1/filters/tag/${uid}`
}

export const tagFilterUidGet = async (uid: string, options?: RequestInit): Promise<TagFilterSummary> => {
  
  return customFetch<TagFilterSummary>(getTagFilterUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates a Tag filter
 */
export const getTagFilterUidUpdateUrl = (uid: string,) => {


  

  return `/v1/filters/tag/${uid}`
}

export const tagFilterUidUpdate = async (uid: string,
    v1TagFilterBody: V1TagFilterBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTagFilterUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1TagFilterBody,)
  }
);}



/**
 * Returns all the metrics for a given resource kind
 * @summary Retrieves the list of metrics for a specified resource kind
 */
export const getMetricsListUrl = (resourceKind: 'pod' | 'namespace' | 'spectrocluster' | 'machine' | 'project',
    params?: MetricsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/metrics/${resourceKind}/values?${stringifiedParams}` : `/v1/metrics/${resourceKind}/values`
}

export const metricsList = async (resourceKind: 'pod' | 'namespace' | 'spectrocluster' | 'machine' | 'project',
    params?: MetricsListParams, options?: RequestInit): Promise<MetricTimeSeriesList> => {
  
  return customFetch<MetricTimeSeriesList>(getMetricsListUrl(resourceKind,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the metrics of the specified resource
 */
export const getMetricsUidDeleteUrl = (resourceKind: 'pod' | 'namespace' | 'spectrocluster' | 'machine' | 'project',
    resourceUid: string,) => {


  

  return `/v1/metrics/${resourceKind}/${resourceUid}/values`
}

export const metricsUidDelete = async (resourceKind: 'pod' | 'namespace' | 'spectrocluster' | 'machine' | 'project',
    resourceUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getMetricsUidDeleteUrl(resourceKind,resourceUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the metrics for a specified resource uid
 */
export const getMetricsUidListUrl = (resourceKind: 'pod' | 'namespace' | 'spectrocluster' | 'machine' | 'project',
    resourceUid: string,
    params?: MetricsUidListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/metrics/${resourceKind}/${resourceUid}/values?${stringifiedParams}` : `/v1/metrics/${resourceKind}/${resourceUid}/values`
}

export const metricsUidList = async (resourceKind: 'pod' | 'namespace' | 'spectrocluster' | 'machine' | 'project',
    resourceUid: string,
    params?: MetricsUidListParams, options?: RequestInit): Promise<MetricTimeSeries> => {
  
  return customFetch<MetricTimeSeries>(getMetricsUidListUrl(resourceKind,resourceUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns a paginated list of notifications based on request parameters
 * @summary Returns a paginated list of notifications based on request parameters
 */
export const getNotificationsListUrl = (params?: NotificationsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/notifications/?${stringifiedParams}` : `/v1/notifications/`
}

export const notificationsList = async (params?: NotificationsListParams, options?: RequestInit): Promise<Notifications> => {
  
  return customFetch<Notifications>(getNotificationsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a notification event
 * @summary Creates a notification event
 */
export const getNotificationsEventCreateUrl = () => {


  

  return `/v1/notifications/events`
}

export const notificationsEventCreate = async (notificationEvent: NotificationEvent, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getNotificationsEventCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      notificationEvent,)
  }
);}



/**
 * Returns a list of notifications for the specified related object
 * @summary Returns a list of notifications for the specified related object
 */
export const getNotificationsObjTypeUidListUrl = (objectKind: 'spectrocluster' | 'clusterprofile' | 'appdeployment',
    objectUid: string,
    params?: NotificationsObjTypeUidListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/notifications/${objectKind}/${objectUid}?${stringifiedParams}` : `/v1/notifications/${objectKind}/${objectUid}`
}

export const notificationsObjTypeUidList = async (objectKind: 'spectrocluster' | 'clusterprofile' | 'appdeployment',
    objectUid: string,
    params?: NotificationsObjTypeUidListParams, options?: RequestInit): Promise<Notifications> => {
  
  return customFetch<Notifications>(getNotificationsObjTypeUidListUrl(objectKind,objectUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates the specified notification for the acknowledgment
 * @summary Updates the specified notification for the acknowledgment
 */
export const getNotificationsUidAckUrl = (uid: string,) => {


  

  return `/v1/notifications/${uid}/ack`
}

export const notificationsUidAck = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getNotificationsUidAckUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * Updates the specified notification action as done
 * @summary Updates the specified notification action as done
 */
export const getNotificationsUidDoneUrl = (uid: string,) => {


  

  return `/v1/notifications/${uid}/done`
}

export const notificationsUidDone = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getNotificationsUidDoneUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Retrieves a list of overlords owned by the tenant
 */
export const getOverlordsListUrl = (params?: OverlordsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords?${stringifiedParams}` : `/v1/overlords`
}

export const overlordsList = async (params?: OverlordsListParams, options?: RequestInit): Promise<Overlords> => {
  
  return customFetch<Overlords>(getOverlordsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the manifests required for the private gateway installation
 */
export const getOverlordsCloudStackManifestUrl = (params: OverlordsCloudStackManifestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords/apache-cloudstack/manifest?${stringifiedParams}` : `/v1/overlords/apache-cloudstack/manifest`
}

export const overlordsCloudStackManifest = async (params: OverlordsCloudStackManifestParams, options?: RequestInit): Promise<OverlordManifest> => {
  
  return customFetch<OverlordManifest>(getOverlordsCloudStackManifestUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary create the CloudStack cloudaccount for the private gateway
 */
export const getOverlordsUidCloudStackAccountCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/apache-cloudstack/${uid}/account`
}

export const overlordsUidCloudStackAccountCreate = async (uid: string,
    overlordCloudStackAccountCreate: OverlordCloudStackAccountCreate, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidCloudStackAccountCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordCloudStackAccountCreate,)
  }
);}



/**
 * @summary update the CloudStack cloudaccount for the private gateway
 */
export const getOverlordsUidCloudStackAccountUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/apache-cloudstack/${uid}/account`
}

export const overlordsUidCloudStackAccountUpdate = async (uid: string,
    overlordCloudStackAccountEntity: OverlordCloudStackAccountEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidCloudStackAccountUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordCloudStackAccountEntity,)
  }
);}



/**
 * Validates CloudStack account credentials and domain. Verifies API connectivity and that the specified domain exists.
 * @summary validate the CloudStack cloudaccount for the private gateway
 */
export const getOverlordsUidCloudStackAccountValidateUrl = (uid: string,) => {


  

  return `/v1/overlords/apache-cloudstack/${uid}/account/validate`
}

export const overlordsUidCloudStackAccountValidate = async (uid: string,
    overlordsUidCloudStackAccountValidateBody: OverlordsUidCloudStackAccountValidateBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidCloudStackAccountValidateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordsUidCloudStackAccountValidateBody,)
  }
);}



/**
 * @summary create the CloudStack cloud config for the private gateway
 */
export const getOverlordsUidCloudStackCloudConfigCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/apache-cloudstack/${uid}/cloudconfig`
}

export const overlordsUidCloudStackCloudConfigCreate = async (uid: string,
    v1OverlordCloudStackCloudConfigBody: V1OverlordCloudStackCloudConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidCloudStackCloudConfigCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordCloudStackCloudConfigBody,)
  }
);}



/**
 * @summary update the CloudStack cloud config for the private gateway
 */
export const getOverlordsUidCloudStackCloudConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/apache-cloudstack/${uid}/cloudconfig`
}

export const overlordsUidCloudStackCloudConfigUpdate = async (uid: string,
    v1OverlordCloudStackCloudConfigBody: V1OverlordCloudStackCloudConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidCloudStackCloudConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordCloudStackCloudConfigBody,)
  }
);}



/**
 * @summary Returns the specified CloudStack private gateway cluster profile
 */
export const getOverlordsUidCloudStackClusterProfileUrl = (uid: string,) => {


  

  return `/v1/overlords/apache-cloudstack/${uid}/clusterprofile`
}

export const overlordsUidCloudStackClusterProfile = async (uid: string, options?: RequestInit): Promise<ClusterProfile> => {
  
  return customFetch<ClusterProfile>(getOverlordsUidCloudStackClusterProfileUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the manifests required for the private gateway installation
 */
export const getV1OverlordsMaasManifestUrl = (params: V1OverlordsMaasManifestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords/maas/manifest?${stringifiedParams}` : `/v1/overlords/maas/manifest`
}

export const v1OverlordsMaasManifest = async (params: V1OverlordsMaasManifestParams, options?: RequestInit): Promise<OverlordManifest> => {
  
  return customFetch<OverlordManifest>(getV1OverlordsMaasManifestUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary create the maas cloudaccount for the private gateway
 */
export const getOverlordsUidMaasAccountCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/account`
}

export const overlordsUidMaasAccountCreate = async (uid: string,
    overlordMaasAccountCreate: OverlordMaasAccountCreate, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidMaasAccountCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordMaasAccountCreate,)
  }
);}



/**
 * @summary update the maas cloudaccount for the private gateway
 */
export const getOverlordsUidMaasAccountUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/account`
}

export const overlordsUidMaasAccountUpdate = async (uid: string,
    overlordMaasAccountEntity: OverlordMaasAccountEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidMaasAccountUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordMaasAccountEntity,)
  }
);}



/**
 * @summary validate the maas cloudaccount for the private gateway
 */
export const getOverlordsUidMaasAccountValidateUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/account/validate`
}

export const overlordsUidMaasAccountValidate = async (uid: string,
    overlordsUidMaasAccountValidateBody: OverlordsUidMaasAccountValidateBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidMaasAccountValidateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordsUidMaasAccountValidateBody,)
  }
);}



/**
 * @summary create the maas cloud config for the private gateway
 */
export const getV1OverlordsUidMaasCloudConfigCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/cloudconfig`
}

export const v1OverlordsUidMaasCloudConfigCreate = async (uid: string,
    v1OverlordMaasCloudConfigBody: V1OverlordMaasCloudConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1OverlordsUidMaasCloudConfigCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordMaasCloudConfigBody,)
  }
);}



/**
 * @summary update the maas cloud config for the private gateway
 */
export const getV1OverlordsUidMaasCloudConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/cloudconfig`
}

export const v1OverlordsUidMaasCloudConfigUpdate = async (uid: string,
    v1OverlordMaasCloudConfigBody: V1OverlordMaasCloudConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1OverlordsUidMaasCloudConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordMaasCloudConfigBody,)
  }
);}



/**
 * @summary Returns the specified maas private gateway cluster profile
 */
export const getOverlordsUidMaasClusterProfileUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/clusterprofile`
}

export const overlordsUidMaasClusterProfile = async (uid: string, options?: RequestInit): Promise<ClusterProfile> => {
  
  return customFetch<ClusterProfile>(getOverlordsUidMaasClusterProfileUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of IP Pools for the specified maas private gateway
 */
export const getOverlordsUidMaasPoolsListUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/pools`
}

export const overlordsUidMaasPoolsList = async (uid: string, options?: RequestInit): Promise<IpPools> => {
  
  return customFetch<IpPools>(getOverlordsUidMaasPoolsListUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates an IP pool definition for the specified maas private gateway
 */
export const getOverlordsUidMaasPoolCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/maas/${uid}/pools`
}

export const overlordsUidMaasPoolCreate = async (uid: string,
    v1IpPoolInputEntityBody: V1IpPoolInputEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidMaasPoolCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1IpPoolInputEntityBody,)
  }
);}



/**
 * @summary Deletes the maas private gateway's specified IP Pool data
 */
export const getOverlordsUidMaasPoolDeleteUrl = (uid: string,
    poolUid: string,) => {


  

  return `/v1/overlords/maas/${uid}/pools/${poolUid}`
}

export const overlordsUidMaasPoolDelete = async (uid: string,
    poolUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidMaasPoolDeleteUrl(uid,poolUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the maas private gateway's specified IP Pool data
 */
export const getOverlordsUidMaasPoolUpdateUrl = (uid: string,
    poolUid: string,) => {


  

  return `/v1/overlords/maas/${uid}/pools/${poolUid}`
}

export const overlordsUidMaasPoolUpdate = async (uid: string,
    poolUid: string,
    v1IpPoolInputEntityBody: V1IpPoolInputEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidMaasPoolUpdateUrl(uid,poolUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1IpPoolInputEntityBody,)
  }
);}



/**
 * @summary migrate all the clusters from source overlord to target overlord
 */
export const getV1OverlordsMigrateUrl = () => {


  

  return `/v1/overlords/migrate`
}

export const v1OverlordsMigrate = async (overlordMigrateEntity: OverlordMigrateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1OverlordsMigrateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordMigrateEntity,)
  }
);}



/**
 * @summary Returns the manifests required for the private gateway installation
 */
export const getOverlordsOpenStackManifestUrl = (params: OverlordsOpenStackManifestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords/openstack/manifest?${stringifiedParams}` : `/v1/overlords/openstack/manifest`
}

export const overlordsOpenStackManifest = async (params: OverlordsOpenStackManifestParams, options?: RequestInit): Promise<OverlordManifest> => {
  
  return customFetch<OverlordManifest>(getOverlordsOpenStackManifestUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary create the OpenStack cloudaccount for the private gateway
 */
export const getOverlordsUidOpenStackAccountCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/openstack/${uid}/account`
}

export const overlordsUidOpenStackAccountCreate = async (uid: string,
    overlordOpenStackAccountCreate: OverlordOpenStackAccountCreate, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidOpenStackAccountCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordOpenStackAccountCreate,)
  }
);}



/**
 * @summary update the OpenStack cloudaccount for the private gateway
 */
export const getOverlordsUidOpenStackAccountUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/openstack/${uid}/account`
}

export const overlordsUidOpenStackAccountUpdate = async (uid: string,
    overlordOpenStackAccountEntity: OverlordOpenStackAccountEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidOpenStackAccountUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordOpenStackAccountEntity,)
  }
);}



/**
 * @summary validate the OpenStack cloudaccount for the private gateway
 */
export const getOverlordsUidOpenStackAccountValidateUrl = (uid: string,) => {


  

  return `/v1/overlords/openstack/${uid}/account/validate`
}

export const overlordsUidOpenStackAccountValidate = async (uid: string,
    overlordsUidOpenStackAccountValidateBody: OverlordsUidOpenStackAccountValidateBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidOpenStackAccountValidateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordsUidOpenStackAccountValidateBody,)
  }
);}



/**
 * @summary create the OpenStack cloud config for the private gateway
 */
export const getOverlordsUidOpenStackCloudConfigCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/openstack/${uid}/cloudconfig`
}

export const overlordsUidOpenStackCloudConfigCreate = async (uid: string,
    v1OverlordOpenStackCloudConfigBody: V1OverlordOpenStackCloudConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidOpenStackCloudConfigCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordOpenStackCloudConfigBody,)
  }
);}



/**
 * @summary update the OpenStack cloud config for the private gateway
 */
export const getOverlordsUidOpenStackCloudConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/openstack/${uid}/cloudconfig`
}

export const overlordsUidOpenStackCloudConfigUpdate = async (uid: string,
    v1OverlordOpenStackCloudConfigBody: V1OverlordOpenStackCloudConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidOpenStackCloudConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordOpenStackCloudConfigBody,)
  }
);}



/**
 * @summary Returns the specified OpenStack private gateway cluster profile
 */
export const getOverlordsUidOpenStackClusterProfileUrl = (uid: string,) => {


  

  return `/v1/overlords/openstack/${uid}/clusterprofile`
}

export const overlordsUidOpenStackClusterProfile = async (uid: string, options?: RequestInit): Promise<ClusterProfile> => {
  
  return customFetch<ClusterProfile>(getOverlordsUidOpenStackClusterProfileUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the pairing code for the private gateway
 */
export const getOverlordsPairingCodeUrl = (params?: OverlordsPairingCodeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords/pairing/code?${stringifiedParams}` : `/v1/overlords/pairing/code`
}

export const overlordsPairingCode = async (params?: OverlordsPairingCodeParams, options?: RequestInit): Promise<PairingCode> => {
  
  return customFetch<PairingCode>(getOverlordsPairingCodeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the manifests required for the private gateway installation
 */
export const getOverlordsVsphereManifestUrl = (params: OverlordsVsphereManifestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords/vsphere/manifest?${stringifiedParams}` : `/v1/overlords/vsphere/manifest`
}

export const overlordsVsphereManifest = async (params: OverlordsVsphereManifestParams, options?: RequestInit): Promise<OverlordManifest> => {
  
  return customFetch<OverlordManifest>(getOverlordsVsphereManifestUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns overlord's ova information
 */
export const getOverlordsVsphereOvaGetUrl = () => {


  

  return `/v1/overlords/vsphere/ova`
}

export const overlordsVsphereOvaGet = async ( options?: RequestInit): Promise<OverloadVsphereOva> => {
  
  return customFetch<OverloadVsphereOva>(getOverlordsVsphereOvaGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary create the vSphere cloudaccount for the private gateway
 */
export const getOverlordsUidVsphereAccountCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/account`
}

export const overlordsUidVsphereAccountCreate = async (uid: string,
    overlordVsphereAccountCreate: OverlordVsphereAccountCreate, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidVsphereAccountCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordVsphereAccountCreate,)
  }
);}



/**
 * @summary update the vSphere cloudaccount for the private gateway
 */
export const getOverlordsUidVsphereAccountUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/account`
}

export const overlordsUidVsphereAccountUpdate = async (uid: string,
    overlordVsphereAccountEntity: OverlordVsphereAccountEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidVsphereAccountUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordVsphereAccountEntity,)
  }
);}



/**
 * @summary validate the vSphere cloudaccount for the private gateway
 */
export const getOverlordsUidVsphereAccountValidateUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/account/validate`
}

export const overlordsUidVsphereAccountValidate = async (uid: string,
    overlordsUidVsphereAccountValidateBody: OverlordsUidVsphereAccountValidateBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidVsphereAccountValidateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      overlordsUidVsphereAccountValidateBody,)
  }
);}



/**
 * @summary create the vSphere cloud config for the private gateway
 */
export const getOverlordsUidVsphereCloudConfigCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/cloudconfig`
}

export const overlordsUidVsphereCloudConfigCreate = async (uid: string,
    v1OverlordVsphereCloudConfigBody: V1OverlordVsphereCloudConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidVsphereCloudConfigCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordVsphereCloudConfigBody,)
  }
);}



/**
 * @summary update the vSphere cloud config for the private gateway
 */
export const getOverlordsUidVsphereCloudConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/cloudconfig`
}

export const overlordsUidVsphereCloudConfigUpdate = async (uid: string,
    v1OverlordVsphereCloudConfigBody: V1OverlordVsphereCloudConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidVsphereCloudConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1OverlordVsphereCloudConfigBody,)
  }
);}



/**
 * @summary Returns the specified vsphere private gateway cluster profile
 */
export const getOverlordsUidVsphereClusterProfileUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/clusterprofile`
}

export const overlordsUidVsphereClusterProfile = async (uid: string, options?: RequestInit): Promise<ClusterProfile> => {
  
  return customFetch<ClusterProfile>(getOverlordsUidVsphereClusterProfileUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of IP Pools for the specified private gateway
 */
export const getOverlordsUidPoolsListUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/pools`
}

export const overlordsUidPoolsList = async (uid: string, options?: RequestInit): Promise<IpPools> => {
  
  return customFetch<IpPools>(getOverlordsUidPoolsListUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates an IP pool defintion for the sepcified private gateway
 */
export const getOverlordsUidPoolCreateUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/pools`
}

export const overlordsUidPoolCreate = async (uid: string,
    v1IpPoolInputEntityBody: V1IpPoolInputEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getOverlordsUidPoolCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1IpPoolInputEntityBody,)
  }
);}



/**
 * @summary Deletes the private gateways's specified IP Pool data
 */
export const getOverlordsUidPoolDeleteUrl = (uid: string,
    poolUid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/pools/${poolUid}`
}

export const overlordsUidPoolDelete = async (uid: string,
    poolUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidPoolDeleteUrl(uid,poolUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the private gateways's specified IP Pool data
 */
export const getOverlordsUidPoolUpdateUrl = (uid: string,
    poolUid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/pools/${poolUid}`
}

export const overlordsUidPoolUpdate = async (uid: string,
    poolUid: string,
    v1IpPoolInputEntityBody: V1IpPoolInputEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidPoolUpdateUrl(uid,poolUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1IpPoolInputEntityBody,)
  }
);}



/**
 * @summary Retrieves the vSphere computecluster resources for the specified private gateway's account
 */
export const getOverlordsUidVsphereComputeclusterResUrl = (uid: string,
    params: OverlordsUidVsphereComputeclusterResParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/overlords/vsphere/${uid}/properties/computecluster/resources?${stringifiedParams}` : `/v1/overlords/vsphere/${uid}/properties/computecluster/resources`
}

export const overlordsUidVsphereComputeclusterRes = async (uid: string,
    params: OverlordsUidVsphereComputeclusterResParams, options?: RequestInit): Promise<VsphereComputeClusterResources> => {
  
  return customFetch<VsphereComputeClusterResources>(getOverlordsUidVsphereComputeclusterResUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves the vSphere datacenters & datacluster for the specified private gateway's account
 */
export const getOverlordsUidVsphereDatacentersUrl = (uid: string,) => {


  

  return `/v1/overlords/vsphere/${uid}/properties/datacenters`
}

export const overlordsUidVsphereDatacenters = async (uid: string, options?: RequestInit): Promise<VsphereDatacenters> => {
  
  return customFetch<VsphereDatacenters>(getOverlordsUidVsphereDatacentersUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary delete the private gateway
 */
export const getOverlordsUidDeleteUrl = (uid: string,) => {


  

  return `/v1/overlords/${uid}`
}

export const overlordsUidDelete = async (uid: string, options?: RequestInit): Promise<DeletedMsg> => {
  
  return customFetch<DeletedMsg>(getOverlordsUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified private gateway's for the given uid
 */
export const getOverlordsUidGetUrl = (uid: string,) => {


  

  return `/v1/overlords/${uid}`
}

export const overlordsUidGet = async (uid: string, options?: RequestInit): Promise<Overlord> => {
  
  return customFetch<Overlord>(getOverlordsUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary update the private gateway's metadata
 */
export const getOverlordsUidMetadataUpdateUrl = (uid: string,) => {


  

  return `/v1/overlords/${uid}/metadata`
}

export const overlordsUidMetadataUpdate = async (uid: string,
    v1ObjectMetaInputEntitySchemaBody: V1ObjectMetaInputEntitySchemaBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getOverlordsUidMetadataUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ObjectMetaInputEntitySchemaBody,)
  }
);}



/**
 * @summary reset the private gateway by disaaociating the private gateway's resources
 */
export const getOverlordsUidResetUrl = (uid: string,) => {


  

  return `/v1/overlords/${uid}/reset`
}

export const overlordsUidReset = async (uid: string, options?: RequestInit): Promise<UpdatedMsg> => {
  
  return customFetch<UpdatedMsg>(getOverlordsUidResetUrl(uid),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Retrieves a list of packs
 */
export const getPacksSummaryListUrl = (params?: PacksSummaryListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/packs?${stringifiedParams}` : `/v1/packs`
}

export const packsSummaryList = async (params?: PacksSummaryListParams, options?: RequestInit): Promise<PackSummaries> => {
  
  return customFetch<PackSummaries>(getPacksSummaryListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of packs based on filter
 */
export const getPacksSearchUrl = (params?: PacksSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/packs/search?${stringifiedParams}` : `/v1/packs/search`
}

export const packsSearch = async (packsFilterSpec: PacksFilterSpec,
    params?: PacksSearchParams, options?: RequestInit): Promise<PackMetadataList> => {
  
  return customFetch<PackMetadataList>(getPacksSearchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      packsFilterSpec,)
  }
);}



/**
 * @summary Retrieves a list of packs
 */
export const getPacksNameRegistryUidListUrl = (packName: string,
    registryUid: string,
    params?: PacksNameRegistryUidListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/packs/${packName}/registries/${registryUid}?${stringifiedParams}` : `/v1/packs/${packName}/registries/${registryUid}`
}

export const packsNameRegistryUidList = async (packName: string,
    registryUid: string,
    params?: PacksNameRegistryUidListParams, options?: RequestInit): Promise<PackTagEntity> => {
  
  return customFetch<PackTagEntity>(getPacksNameRegistryUidListUrl(packName,registryUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the logo for a specified pack
 */
export const getPacksPackUidLogoUrl = (packUid: string,) => {


  

  return `/v1/packs/${packUid}/logo`
}

export const packsPackUidLogo = async (packUid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getPacksPackUidLogoUrl(packUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified pack
 */
export const getPacksUidUrl = (uid: string,) => {


  

  return `/v1/packs/${uid}`
}

export const packsUid = async (uid: string, options?: RequestInit): Promise<PackTagEntity> => {
  
  return customFetch<PackTagEntity>(getPacksUidUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the readme of a specified pack
 */
export const getPacksUidReadmeUrl = (uid: string,) => {


  

  return `/v1/packs/${uid}/readme`
}

export const packsUidReadme = async (uid: string, options?: RequestInit): Promise<PackReadme> => {
  
  return customFetch<PackReadme>(getPacksUidReadmeUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the private gateway manifest link
 */
export const getPcgSelfHostedUrl = () => {


  

  return `/v1/pcg/selfHosted`
}

export const pcgSelfHosted = async (pcgSelfHostedParams: PcgSelfHostedParams, options?: RequestInit): Promise<PcgServiceKubectlCommands> => {
  
  return customFetch<PcgServiceKubectlCommands>(getPcgSelfHostedUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pcgSelfHostedParams,)
  }
);}



/**
 * @summary Registers the pcg
 */
export const getPcgUidRegisterUrl = (uid: string,) => {


  

  return `/v1/pcg/${uid}/register`
}

export const pcgUidRegister = async (uid: string,
    pairingCode: PairingCode, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getPcgUidRegisterUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pairingCode,)
  }
);}



/**
 * @summary Returns the pcg ally manifest
 */
export const getPcgUidAllyManifestGetUrl = (uid: string,) => {


  

  return `/v1/pcg/${uid}/services/ally/manifest`
}

export const pcgUidAllyManifestGet = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getPcgUidAllyManifestGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the pcg jet manifest
 */
export const getPcgUidJetManifestGetUrl = (uid: string,) => {


  

  return `/v1/pcg/${uid}/services/jet/manifest`
}

export const pcgUidJetManifestGet = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getPcgUidJetManifestGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of permissions
 */
export const getPermissionsListUrl = (params?: PermissionsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/permissions?${stringifiedParams}` : `/v1/permissions`
}

export const permissionsList = async (params?: PermissionsListParams, options?: RequestInit): Promise<Permissions> => {
  
  return customFetch<Permissions>(getPermissionsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a project
 */
export const getProjectsCreateUrl = () => {


  

  return `/v1/projects`
}

export const projectsCreate = async (v1ProjectEntityBody: V1ProjectEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getProjectsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ProjectEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of supported alerts for a project
 */
export const getProjectsAlertsUrl = () => {


  

  return `/v1/projects/alerts`
}

export const projectsAlerts = async ( options?: RequestInit): Promise<ProjectAlertComponents> => {
  
  return customFetch<ProjectAlertComponents>(getProjectsAlertsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified project
 */
export const getProjectsUidDeleteUrl = (uid: string,
    params?: ProjectsUidDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/projects/${uid}?${stringifiedParams}` : `/v1/projects/${uid}`
}

export const projectsUidDelete = async (uid: string,
    projectCleanup: ProjectCleanup,
    params?: ProjectsUidDeleteParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidDeleteUrl(uid,params),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectCleanup,)
  }
);}



/**
 * @summary Returns the specified project
 */
export const getProjectsUidGetUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}`
}

export const projectsUidGet = async (uid: string, options?: RequestInit): Promise<Project> => {
  
  return customFetch<Project>(getProjectsUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified project
 */
export const getProjectsUidUpdateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}`
}

export const projectsUidUpdate = async (uid: string,
    v1ProjectEntityBody: V1ProjectEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ProjectEntityBody,)
  }
);}



/**
 * @summary Deletes the specified alert to the specified project
 */
export const getProjectsUidAlertDeleteUrl = (uid: string,
    component: string,) => {


  

  return `/v1/projects/${uid}/alerts/${component}`
}

export const projectsUidAlertDelete = async (uid: string,
    component: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidAlertDeleteUrl(uid,component),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Create the specified alert to the specified project
 */
export const getProjectsUidAlertCreateUrl = (uid: string,
    component: string,) => {


  

  return `/v1/projects/${uid}/alerts/${component}`
}

export const projectsUidAlertCreate = async (uid: string,
    component: string,
    v1ChannelBody: V1ChannelBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getProjectsUidAlertCreateUrl(uid,component),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ChannelBody,)
  }
);}



/**
 * @summary Upsert the specified alert to the specified project
 */
export const getProjectsUidAlertUpdateUrl = (uid: string,
    component: string,) => {


  

  return `/v1/projects/${uid}/alerts/${component}`
}

export const projectsUidAlertUpdate = async (uid: string,
    component: string,
    alertEntity: AlertEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidAlertUpdateUrl(uid,component),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      alertEntity,)
  }
);}



/**
 * @summary Deletes the specified alert of the specified project
 */
export const getProjectsUidAlertsUidDeleteUrl = (uid: string,
    component: string,
    alertUid: string,) => {


  

  return `/v1/projects/${uid}/alerts/${component}/${alertUid}`
}

export const projectsUidAlertsUidDelete = async (uid: string,
    component: string,
    alertUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidAlertsUidDeleteUrl(uid,component,alertUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Get the specified alert of the specified project
 */
export const getProjectsUidAlertsUidGetUrl = (uid: string,
    component: string,
    alertUid: string,) => {


  

  return `/v1/projects/${uid}/alerts/${component}/${alertUid}`
}

export const projectsUidAlertsUidGet = async (uid: string,
    component: string,
    alertUid: string, options?: RequestInit): Promise<Channel> => {
  
  return customFetch<Channel>(getProjectsUidAlertsUidGetUrl(uid,component,alertUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the specified alert of the specified project
 */
export const getProjectsUidAlertsUidUpdateUrl = (uid: string,
    component: string,
    alertUid: string,) => {


  

  return `/v1/projects/${uid}/alerts/${component}/${alertUid}`
}

export const projectsUidAlertsUidUpdate = async (uid: string,
    component: string,
    alertUid: string,
    v1ChannelBody: V1ChannelBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidAlertsUidUpdateUrl(uid,component,alertUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ChannelBody,)
  }
);}



/**
 * @summary Delete the macros for the specified project by macro name
 */
export const getProjectsUidMacrosDeleteByMacroNameUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/macros`
}

export const projectsUidMacrosDeleteByMacroName = async (uid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidMacrosDeleteByMacroNameUrl(uid),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary List the macros of the specified project
 */
export const getProjectsUidMacrosListUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/macros`
}

export const projectsUidMacrosList = async (uid: string, options?: RequestInit): Promise<Macros> => {
  
  return customFetch<Macros>(getProjectsUidMacrosListUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the macros for the specified project by macro name
 */
export const getProjectsUidMacrosUpdateByMacroNameUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/macros`
}

export const projectsUidMacrosUpdateByMacroName = async (uid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidMacrosUpdateByMacroNameUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Create or add new macros for the specified project
 */
export const getProjectsUidMacrosCreateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/macros`
}

export const projectsUidMacrosCreate = async (uid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidMacrosCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Update the macros of the specified project
 */
export const getProjectsUidMacrosUpdateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/macros`
}

export const projectsUidMacrosUpdate = async (uid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidMacrosUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Update the metadata of the specified project
 */
export const getProjectsUidMetaUpdateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/meta`
}

export const projectsUidMetaUpdate = async (uid: string,
    v1ObjectMetaBody: V1ObjectMetaBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidMetaUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ObjectMetaBody,)
  }
);}



/**
 * @summary Get project cluster settings
 */
export const getProjectClusterSettingsGetUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/preferences/clusterSettings`
}

export const projectClusterSettingsGet = async (uid: string, options?: RequestInit): Promise<ProjectClusterSettings> => {
  
  return customFetch<ProjectClusterSettings>(getProjectClusterSettingsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update project clusters nodes auto remediation setting
 */
export const getProjectClustersNodesAutoRemediationSettingUpdateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/preferences/clusterSettings/nodesAutoRemediationSetting`
}

export const projectClustersNodesAutoRemediationSettingUpdate = async (uid: string,
    v1NodesAutoRemediationSettingsBody: V1NodesAutoRemediationSettingsBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectClustersNodesAutoRemediationSettingUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1NodesAutoRemediationSettingsBody,)
  }
);}



/**
 * @summary Update the teams association to the specified project
 */
export const getProjectsUidTeamsUpdateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/teams`
}

export const projectsUidTeamsUpdate = async (uid: string,
    projectTeamsEntity: ProjectTeamsEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidTeamsUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectTeamsEntity,)
  }
);}



/**
 * @summary Update the users association to the specified project
 */
export const getProjectsUidUsersUpdateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/users`
}

export const projectsUidUsersUpdate = async (uid: string,
    projectUsersEntity: ProjectUsersEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getProjectsUidUsersUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectUsersEntity,)
  }
);}



/**
 * @summary Validate and returns active resource of project before delete
 */
export const getProjectsUidValidateUrl = (uid: string,) => {


  

  return `/v1/projects/${uid}/validate`
}

export const projectsUidValidate = async (uid: string, options?: RequestInit): Promise<ProjectActiveResources> => {
  
  return customFetch<ProjectActiveResources>(getProjectsUidValidateUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Retrieves a list of Helm registries
 */
export const getRegistriesHelmListUrl = (params?: RegistriesHelmListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/helm?${stringifiedParams}` : `/v1/registries/helm`
}

export const registriesHelmList = async (params?: RegistriesHelmListParams, options?: RequestInit): Promise<HelmRegistries> => {
  
  return customFetch<HelmRegistries>(getRegistriesHelmListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a helm registry
 */
export const getRegistriesHelmCreateUrl = (params?: RegistriesHelmCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/helm?${stringifiedParams}` : `/v1/registries/helm`
}

export const registriesHelmCreate = async (helmRegistryEntity: HelmRegistryEntity,
    params?: RegistriesHelmCreateParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getRegistriesHelmCreateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      helmRegistryEntity,)
  }
);}



/**
 * @summary Retrieves a list of helm registries as summary
 */
export const getRegistriesHelmSummaryListUrl = (params?: RegistriesHelmSummaryListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/helm/summary?${stringifiedParams}` : `/v1/registries/helm/summary`
}

export const registriesHelmSummaryList = async (params?: RegistriesHelmSummaryListParams, options?: RequestInit): Promise<HelmRegistriesSummary> => {
  
  return customFetch<HelmRegistriesSummary>(getRegistriesHelmSummaryListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if helm registry is valid else error.
 * @summary Check if helm registry is valid
 */
export const getV1RegistriesHelmValidateUrl = () => {


  

  return `/v1/registries/helm/validate`
}

export const v1RegistriesHelmValidate = async (helmRegistrySpec: HelmRegistrySpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1RegistriesHelmValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      helmRegistrySpec,)
  }
);}



/**
 * @summary Deletes the specified helm registry
 */
export const getRegistriesHelmUidDeleteUrl = (uid: string,) => {


  

  return `/v1/registries/helm/${uid}`
}

export const registriesHelmUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesHelmUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified Helm registry
 */
export const getRegistriesHelmUidGetUrl = (uid: string,) => {


  

  return `/v1/registries/helm/${uid}`
}

export const registriesHelmUidGet = async (uid: string, options?: RequestInit): Promise<HelmRegistry> => {
  
  return customFetch<HelmRegistry>(getRegistriesHelmUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified helm registry
 */
export const getRegistriesHelmUidUpdateUrl = (uid: string,) => {


  

  return `/v1/registries/helm/${uid}`
}

export const registriesHelmUidUpdate = async (uid: string,
    helmRegistry: HelmRegistry, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesHelmUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      helmRegistry,)
  }
);}



/**
 * Sync all the helm charts from the registry
 * @summary Sync Helm registry
 */
export const getRegistriesHelmUidSyncUrl = (uid: string,
    params?: RegistriesHelmUidSyncParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/helm/${uid}/sync?${stringifiedParams}` : `/v1/registries/helm/${uid}/sync`
}

export const registriesHelmUidSync = async (uid: string,
    params?: RegistriesHelmUidSyncParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesHelmUidSyncUrl(uid,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Get the sync status for the specified helm registry
 * @summary Get helm registry sync status
 */
export const getRegistriesHelmUidSyncStatusUrl = (uid: string,) => {


  

  return `/v1/registries/helm/${uid}/sync/status`
}

export const registriesHelmUidSyncStatus = async (uid: string, options?: RequestInit): Promise<RegistrySyncStatus> => {
  
  return customFetch<RegistrySyncStatus>(getRegistriesHelmUidSyncStatusUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of registries metadata
 */
export const getRegistriesMetadataUrl = (params?: RegistriesMetadataParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/metadata?${stringifiedParams}` : `/v1/registries/metadata`
}

export const registriesMetadata = async (params?: RegistriesMetadataParams, options?: RequestInit): Promise<RegistriesMetadata> => {
  
  return customFetch<RegistriesMetadata>(getRegistriesMetadataUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a basic oci registry
 */
export const getBasicOciRegistriesCreateUrl = (params?: BasicOciRegistriesCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/oci/basic?${stringifiedParams}` : `/v1/registries/oci/basic`
}

export const basicOciRegistriesCreate = async (v1BasicOciRegistryBody: V1BasicOciRegistryBody,
    params?: BasicOciRegistriesCreateParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getBasicOciRegistriesCreateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1BasicOciRegistryBody,)
  }
);}



/**
 * Returns no contents if oci registry is valid else error.
 * @summary Check if oci registry is valid
 */
export const getBasicOciRegistriesValidateUrl = () => {


  

  return `/v1/registries/oci/basic/validate`
}

export const basicOciRegistriesValidate = async (basicOciRegistrySpec: BasicOciRegistrySpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getBasicOciRegistriesValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      basicOciRegistrySpec,)
  }
);}



/**
 * @summary Creates a ecr registry
 */
export const getEcrRegistriesCreateUrl = (params?: EcrRegistriesCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/oci/ecr?${stringifiedParams}` : `/v1/registries/oci/ecr`
}

export const ecrRegistriesCreate = async (v1EcrRegistryBody: V1EcrRegistryBody,
    params?: EcrRegistriesCreateParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getEcrRegistriesCreateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EcrRegistryBody,)
  }
);}



/**
 * Returns no contents if ecr registry is valid else error.
 * @summary Check if ecr registry is valid
 */
export const getEcrRegistriesValidateUrl = () => {


  

  return `/v1/registries/oci/ecr/validate`
}

export const ecrRegistriesValidate = async (ecrRegistrySpec: EcrRegistrySpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEcrRegistriesValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ecrRegistrySpec,)
  }
);}



/**
 * @summary Creates a image registry
 */
export const getOciImageRegistryGetUrl = () => {


  

  return `/v1/registries/oci/image`
}

export const ociImageRegistryGet = async ( options?: RequestInit): Promise<OciImageRegistry> => {
  
  return customFetch<OciImageRegistry>(getOciImageRegistryGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a oci registries summary
 */
export const getOciRegistriesSummaryUrl = () => {


  

  return `/v1/registries/oci/summary`
}

export const ociRegistriesSummary = async ( options?: RequestInit): Promise<OciRegistries> => {
  
  return customFetch<OciRegistries>(getOciRegistriesSummaryUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the information of specified oci registry
 */
export const getOciRegistriesGetUrl = (uid: string,
    params?: OciRegistriesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/oci/${uid}?${stringifiedParams}` : `/v1/registries/oci/${uid}`
}

export const ociRegistriesGet = async (uid: string,
    params?: OciRegistriesGetParams, options?: RequestInit): Promise<OciRegistryEntity> => {
  
  return customFetch<OciRegistryEntity>(getOciRegistriesGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified basic oci registry
 */
export const getBasicOciRegistriesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/basic`
}

export const basicOciRegistriesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getBasicOciRegistriesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the basic oci registry
 */
export const getBasicOciRegistriesUidGetUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/basic`
}

export const basicOciRegistriesUidGet = async (uid: string, options?: RequestInit): Promise<BasicOciRegistry> => {
  
  return customFetch<BasicOciRegistry>(getBasicOciRegistriesUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified basic oci registry
 */
export const getBasicOciRegistriesUidUpdateUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/basic`
}

export const basicOciRegistriesUidUpdate = async (uid: string,
    v1BasicOciRegistryBody: V1BasicOciRegistryBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getBasicOciRegistriesUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1BasicOciRegistryBody,)
  }
);}



/**
 * Sync all the content from the oci registry
 * @summary Sync oci registry
 */
export const getBasicOciRegistriesUidSyncUrl = (uid: string,
    params?: BasicOciRegistriesUidSyncParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/oci/${uid}/basic/sync?${stringifiedParams}` : `/v1/registries/oci/${uid}/basic/sync`
}

export const basicOciRegistriesUidSync = async (uid: string,
    params?: BasicOciRegistriesUidSyncParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getBasicOciRegistriesUidSyncUrl(uid,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Get sync status for the oci specified registry
 * @summary Get oci registry sync status
 */
export const getBasicOciRegistriesUidSyncStatusUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/basic/sync/status`
}

export const basicOciRegistriesUidSyncStatus = async (uid: string, options?: RequestInit): Promise<RegistrySyncStatus> => {
  
  return customFetch<RegistrySyncStatus>(getBasicOciRegistriesUidSyncStatusUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified ecr registry
 */
export const getEcrRegistriesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/ecr`
}

export const ecrRegistriesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEcrRegistriesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified ecr registry
 */
export const getEcrRegistriesUidGetUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/ecr`
}

export const ecrRegistriesUidGet = async (uid: string, options?: RequestInit): Promise<EcrRegistry> => {
  
  return customFetch<EcrRegistry>(getEcrRegistriesUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified ecr registry
 */
export const getEcrRegistriesUidUpdateUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/ecr`
}

export const ecrRegistriesUidUpdate = async (uid: string,
    v1EcrRegistryBody: V1EcrRegistryBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEcrRegistriesUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1EcrRegistryBody,)
  }
);}



/**
 * Sync all the content from the ecr registry
 * @summary Sync ecr registry
 */
export const getEcrRegistriesUidSyncUrl = (uid: string,
    params?: EcrRegistriesUidSyncParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/oci/${uid}/ecr/sync?${stringifiedParams}` : `/v1/registries/oci/${uid}/ecr/sync`
}

export const ecrRegistriesUidSync = async (uid: string,
    params?: EcrRegistriesUidSyncParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getEcrRegistriesUidSyncUrl(uid,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Get sync status for the ecr specified registry
 * @summary Get ecr registry sync status
 */
export const getEcrRegistriesUidSyncStatusUrl = (uid: string,) => {


  

  return `/v1/registries/oci/${uid}/ecr/sync/status`
}

export const ecrRegistriesUidSyncStatus = async (uid: string, options?: RequestInit): Promise<RegistrySyncStatus> => {
  
  return customFetch<RegistrySyncStatus>(getEcrRegistriesUidSyncStatusUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of Pack registries
 */
export const getRegistriesPackListUrl = (params?: RegistriesPackListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/pack?${stringifiedParams}` : `/v1/registries/pack`
}

export const registriesPackList = async (params?: RegistriesPackListParams, options?: RequestInit): Promise<PackRegistries> => {
  
  return customFetch<PackRegistries>(getRegistriesPackListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a pack registry
 */
export const getRegistriesPackCreateUrl = (params?: RegistriesPackCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/pack?${stringifiedParams}` : `/v1/registries/pack`
}

export const registriesPackCreate = async (v1PackRegistryBody: V1PackRegistryBody,
    params?: RegistriesPackCreateParams, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getRegistriesPackCreateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1PackRegistryBody,)
  }
);}



/**
 * @summary Retrieves a list of pack registries as summary
 */
export const getRegistriesPackSummaryListUrl = (params?: RegistriesPackSummaryListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/pack/summary?${stringifiedParams}` : `/v1/registries/pack/summary`
}

export const registriesPackSummaryList = async (params?: RegistriesPackSummaryListParams, options?: RequestInit): Promise<PackRegistriesSummary> => {
  
  return customFetch<PackRegistriesSummary>(getRegistriesPackSummaryListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns no contents if pack registry is valid else error.
 * @summary Check if pack registry is valid
 */
export const getV1RegistriesPackValidateUrl = () => {


  

  return `/v1/registries/pack/validate`
}

export const v1RegistriesPackValidate = async (packRegistrySpec: PackRegistrySpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1RegistriesPackValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      packRegistrySpec,)
  }
);}



/**
 * @summary Deletes the specified pack registry
 */
export const getRegistriesPackUidDeleteUrl = (uid: string,) => {


  

  return `/v1/registries/pack/${uid}`
}

export const registriesPackUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesPackUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified Pack registry
 */
export const getRegistriesPackUidGetUrl = (uid: string,) => {


  

  return `/v1/registries/pack/${uid}`
}

export const registriesPackUidGet = async (uid: string, options?: RequestInit): Promise<PackRegistry> => {
  
  return customFetch<PackRegistry>(getRegistriesPackUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified pack registry
 */
export const getRegistriesPackUidUpdateUrl = (uid: string,) => {


  

  return `/v1/registries/pack/${uid}`
}

export const registriesPackUidUpdate = async (uid: string,
    v1PackRegistryBody: V1PackRegistryBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesPackUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1PackRegistryBody,)
  }
);}



/**
 * Sync all the packs from the registry
 * @summary Sync Pack registry
 */
export const getRegistriesPackUidSyncUrl = (uid: string,
    params?: RegistriesPackUidSyncParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/registries/pack/${uid}/sync?${stringifiedParams}` : `/v1/registries/pack/${uid}/sync`
}

export const registriesPackUidSync = async (uid: string,
    params?: RegistriesPackUidSyncParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesPackUidSyncUrl(uid,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Get sync status for the pack specified registry
 * @summary Get pack registry sync status
 */
export const getRegistriesPackUidSyncStatusUrl = (uid: string,) => {


  

  return `/v1/registries/pack/${uid}/sync/status`
}

export const registriesPackUidSyncStatus = async (uid: string, options?: RequestInit): Promise<RegistrySyncStatus> => {
  
  return customFetch<RegistrySyncStatus>(getRegistriesPackUidSyncStatusUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified system scope registry configuration
 */
export const getRegistriesNameConfigGetUrl = (registryName: string,) => {


  

  return `/v1/registries/${registryName}/config`
}

export const registriesNameConfigGet = async (registryName: string, options?: RequestInit): Promise<RegistryConfigEntity> => {
  
  return customFetch<RegistryConfigEntity>(getRegistriesNameConfigGetUrl(registryName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified registry
 */
export const getRegistriesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/registries/${uid}`
}

export const registriesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRegistriesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Retrieves a list of roles
 */
export const getRolesListUrl = (params?: RolesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/roles?${stringifiedParams}` : `/v1/roles`
}

export const rolesList = async (params?: RolesListParams, options?: RequestInit): Promise<Roles> => {
  
  return customFetch<Roles>(getRolesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a role with specified permissions
 */
export const getRolesCreateUrl = () => {


  

  return `/v1/roles`
}

export const rolesCreate = async (v1RoleBody: V1RoleBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getRolesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1RoleBody,)
  }
);}



/**
 * @summary Deletes the specified role
 */
export const getRolesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/roles/${uid}`
}

export const rolesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRolesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified role
 */
export const getRolesUidGetUrl = (uid: string,) => {


  

  return `/v1/roles/${uid}`
}

export const rolesUidGet = async (uid: string, options?: RequestInit): Promise<Role> => {
  
  return customFetch<Role>(getRolesUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified role
 */
export const getRolesUidUpdateUrl = (uid: string,) => {


  

  return `/v1/roles/${uid}`
}

export const rolesUidUpdate = async (uid: string,
    v1RoleBody: V1RoleBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRolesUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1RoleBody,)
  }
);}



/**
 * @summary Clone the role
 */
export const getRolesCloneUrl = (uid: string,) => {


  

  return `/v1/roles/${uid}/clone`
}

export const rolesClone = async (uid: string,
    roleClone: RoleClone, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getRolesCloneUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      roleClone,)
  }
);}



/**
 * @summary Returns a latest version for a given service name
 */
export const getServiceVersionGetUrl = (serviceName: 'ally' | 'jet' | 'palette' | 'ambit' | 'ally-lite' | 'palette-lite' | 'crony' | 'tick' | 'edge' | 'lodge' | 'level' | 'edgeconfig' | 'firth' | 'stylus' | 'provider-k3s' | 'provider-kubeadm' | 'provider-rke2' | 'provider-nodeadm' | 'provider-canonical',
    params?: ServiceVersionGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/services/${serviceName}/version?${stringifiedParams}` : `/v1/services/${serviceName}/version`
}

export const serviceVersionGet = async (serviceName: 'ally' | 'jet' | 'palette' | 'ambit' | 'ally-lite' | 'palette-lite' | 'crony' | 'tick' | 'edge' | 'lodge' | 'level' | 'edgeconfig' | 'firth' | 'stylus' | 'provider-k3s' | 'provider-kubeadm' | 'provider-rke2' | 'provider-nodeadm' | 'provider-canonical',
    params?: ServiceVersionGetParams, options?: RequestInit): Promise<ServiceVersion> => {
  
  return customFetch<ServiceVersion>(getServiceVersionGetUrl(serviceName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns a service manifest for a given service name and version
 */
export const getServiceManifestGetUrl = (serviceName: 'ally' | 'jet' | 'palette' | 'ambit' | 'ally-lite' | 'palette-lite' | 'crony' | 'tick' | 'edge' | 'lodge' | 'level' | 'edgeconfig' | 'firth' | 'stylus' | 'provider-k3s' | 'provider-kubeadm' | 'provider-rke2' | 'provider-nodeadm' | 'provider-canonical',
    version: string,
    params: ServiceManifestGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/services/${serviceName}/versions/${version}/manifest?${stringifiedParams}` : `/v1/services/${serviceName}/versions/${version}/manifest`
}

export const serviceManifestGet = async (serviceName: 'ally' | 'jet' | 'palette' | 'ambit' | 'ally-lite' | 'palette-lite' | 'crony' | 'tick' | 'edge' | 'lodge' | 'level' | 'edgeconfig' | 'firth' | 'stylus' | 'provider-k3s' | 'provider-kubeadm' | 'provider-rke2' | 'provider-nodeadm' | 'provider-canonical',
    version: string,
    params: ServiceManifestGetParams, options?: RequestInit): Promise<ServiceManifest> => {
  
  return customFetch<ServiceManifest>(getServiceManifestGetUrl(serviceName,version,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create a new maintenance policy
 */
export const getV1SpcPoliciesMaintenanceCreateUrl = () => {


  

  return `/v1/spcPolicies/maintenance`
}

export const v1SpcPoliciesMaintenanceCreate = async (v1SpcPolicyEntityBody: V1SpcPolicyEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1SpcPoliciesMaintenanceCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpcPolicyEntityBody,)
  }
);}



/**
 * @summary Returns the specified maintenance policy
 */
export const getV1SpcPoliciesMaintenanceUidGetUrl = (uid: string,) => {


  

  return `/v1/spcPolicies/maintenance/${uid}`
}

export const v1SpcPoliciesMaintenanceUidGet = async (uid: string, options?: RequestInit): Promise<SpcPolicyEntity> => {
  
  return customFetch<SpcPolicyEntity>(getV1SpcPoliciesMaintenanceUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified maintenance policy
 */
export const getV1SpcPoliciesMaintenanceUidUpdateUrl = (uid: string,) => {


  

  return `/v1/spcPolicies/maintenance/${uid}`
}

export const v1SpcPoliciesMaintenanceUidUpdate = async (uid: string,
    v1SpcPolicyEntityBody: V1SpcPolicyEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1SpcPoliciesMaintenanceUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpcPolicyEntityBody,)
  }
);}



/**
 * @summary Retrieves a list of spc policy tags
 */
export const getV1SpcPoliciesTagsGetUrl = () => {


  

  return `/v1/spcPolicies/tags`
}

export const v1SpcPoliciesTagsGet = async ( options?: RequestInit): Promise<SpcPolicyTags> => {
  
  return customFetch<SpcPolicyTags>(getV1SpcPoliciesTagsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates the spc policy name
 */
export const getV1SpcPoliciesValidateNameUrl = (policyType: string,
    params?: V1SpcPoliciesValidateNameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spcPolicies/${policyType}/validate/name?${stringifiedParams}` : `/v1/spcPolicies/${policyType}/validate/name`
}

export const v1SpcPoliciesValidateName = async (policyType: string,
    params?: V1SpcPoliciesValidateNameParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1SpcPoliciesValidateNameUrl(policyType,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Delete a policy by uid
 */
export const getV1SpcPoliciesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/spcPolicies/${uid}`
}

export const v1SpcPoliciesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1SpcPoliciesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Creates an AKS cluster
 */
export const getSpectroClustersAksCreateUrl = () => {


  

  return `/v1/spectroclusters/aks`
}

export const spectroClustersAksCreate = async (v1SpectroAzureClusterEntityBody: V1SpectroAzureClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersAksCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAzureClusterEntityBody,)
  }
);}



/**
 * @summary Get AKS cluster estimated rate information
 */
export const getSpectroClustersAksRateUrl = (params?: SpectroClustersAksRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/aks/rate?${stringifiedParams}` : `/v1/spectroclusters/aks/rate`
}

export const spectroClustersAksRate = async (v1SpectroAzureClusterRateEntityBody: V1SpectroAzureClusterRateEntityBody,
    params?: SpectroClustersAksRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersAksRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAzureClusterRateEntityBody,)
  }
);}



/**
 * @summary Validates AKS cluster create operation
 */
export const getSpectroClustersAksValidateUrl = () => {


  

  return `/v1/spectroclusters/aks/validate`
}

export const spectroClustersAksValidate = async (v1SpectroAzureClusterEntityBody: V1SpectroAzureClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersAksValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAzureClusterEntityBody,)
  }
);}



/**
 * @summary Creates a CloudStack cluster
 */
export const getSpectroClustersCloudStackCreateUrl = () => {


  

  return `/v1/spectroclusters/apache-cloudstack`
}

export const spectroClustersCloudStackCreate = async (v1SpectroCloudStackClusterEntityBody: V1SpectroCloudStackClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersCloudStackCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroCloudStackClusterEntityBody,)
  }
);}



/**
 * @summary Imports a CloudStack cluster
 */
export const getSpectroClustersCloudStackImportUrl = () => {


  

  return `/v1/spectroclusters/apache-cloudstack/import`
}

export const spectroClustersCloudStackImport = async (spectroCloudStackClusterImportEntity: SpectroCloudStackClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersCloudStackImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroCloudStackClusterImportEntity,)
  }
);}



/**
 * @summary Get CloudStack cluster estimated rate information
 */
export const getSpectroClustersCloudStackRateUrl = (params?: SpectroClustersCloudStackRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/apache-cloudstack/rate?${stringifiedParams}` : `/v1/spectroclusters/apache-cloudstack/rate`
}

export const spectroClustersCloudStackRate = async (spectroCloudStackClusterRateEntity: SpectroCloudStackClusterRateEntity,
    params?: SpectroClustersCloudStackRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersCloudStackRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroCloudStackClusterRateEntity,)
  }
);}



/**
 * @summary Validates CloudStack cluster create operation
 */
export const getSpectroClustersCloudStackValidateUrl = () => {


  

  return `/v1/spectroclusters/apache-cloudstack/validate`
}

export const spectroClustersCloudStackValidate = async (v1SpectroCloudStackClusterEntityBody: V1SpectroCloudStackClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersCloudStackValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroCloudStackClusterEntityBody,)
  }
);}



/**
 * @summary Creates an AWS cluster
 */
export const getSpectroClustersAwsCreateUrl = () => {


  

  return `/v1/spectroclusters/aws`
}

export const spectroClustersAwsCreate = async (v1SpectroAwsClusterEntityBody: V1SpectroAwsClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersAwsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAwsClusterEntityBody,)
  }
);}



/**
 * @summary Imports an AWS cluster
 */
export const getSpectroClustersAwsImportUrl = () => {


  

  return `/v1/spectroclusters/aws/import`
}

export const spectroClustersAwsImport = async (spectroAwsClusterImportEntity: SpectroAwsClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersAwsImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroAwsClusterImportEntity,)
  }
);}



/**
 * @summary Get AWS cluster estimated rate information
 */
export const getSpectroClustersAwsRateUrl = (params?: SpectroClustersAwsRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/aws/rate?${stringifiedParams}` : `/v1/spectroclusters/aws/rate`
}

export const spectroClustersAwsRate = async (spectroAwsClusterRateEntity: SpectroAwsClusterRateEntity,
    params?: SpectroClustersAwsRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersAwsRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroAwsClusterRateEntity,)
  }
);}



/**
 * @summary Validates AWS cluster create operation
 */
export const getSpectroClustersAwsValidateUrl = () => {


  

  return `/v1/spectroclusters/aws/validate`
}

export const spectroClustersAwsValidate = async (v1SpectroAwsClusterEntityBody: V1SpectroAwsClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersAwsValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAwsClusterEntityBody,)
  }
);}



/**
 * @summary Creates an Azure cluster
 */
export const getSpectroClustersAzureCreateUrl = () => {


  

  return `/v1/spectroclusters/azure`
}

export const spectroClustersAzureCreate = async (v1SpectroAzureClusterEntityBody: V1SpectroAzureClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersAzureCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAzureClusterEntityBody,)
  }
);}



/**
 * @summary Imports an Azure cluster
 */
export const getSpectroClustersAzureImportUrl = () => {


  

  return `/v1/spectroclusters/azure/import`
}

export const spectroClustersAzureImport = async (spectroAzureClusterImportEntity: SpectroAzureClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersAzureImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroAzureClusterImportEntity,)
  }
);}



/**
 * @summary Get Azure cluster estimated rate information
 */
export const getSpectroClustersAzureRateUrl = (params?: SpectroClustersAzureRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/azure/rate?${stringifiedParams}` : `/v1/spectroclusters/azure/rate`
}

export const spectroClustersAzureRate = async (v1SpectroAzureClusterRateEntityBody: V1SpectroAzureClusterRateEntityBody,
    params?: SpectroClustersAzureRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersAzureRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAzureClusterRateEntityBody,)
  }
);}



/**
 * @summary Validates Azure cluster create operation
 */
export const getSpectroClustersAzureValidateUrl = () => {


  

  return `/v1/spectroclusters/azure/validate`
}

export const spectroClustersAzureValidate = async (v1SpectroAzureClusterEntityBody: V1SpectroAzureClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersAzureValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroAzureClusterEntityBody,)
  }
);}



/**
 * @summary Creates a Custom cluster
 */
export const getSpectroClustersCustomCreateUrl = (cloudType: string,) => {


  

  return `/v1/spectroclusters/cloudTypes/${cloudType}`
}

export const spectroClustersCustomCreate = async (cloudType: string,
    v1SpectroCustomClusterEntityBody: V1SpectroCustomClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersCustomCreateUrl(cloudType),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroCustomClusterEntityBody,)
  }
);}



/**
 * @summary Validates Custom cluster create operation
 */
export const getSpectroClustersCustomValidateUrl = (cloudType: string,) => {


  

  return `/v1/spectroclusters/cloudTypes/${cloudType}/validate`
}

export const spectroClustersCustomValidate = async (cloudType: string,
    v1SpectroCustomClusterEntityBody: V1SpectroCustomClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersCustomValidateUrl(cloudType),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroCustomClusterEntityBody,)
  }
);}



/**
 * @summary Upgrades clusters launched from the specified cluster template
 */
export const getV1SpectroClustersTemplatesUidClustersUpgradeUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/clusterTemplates/${uid}/clusters/upgrade`
}

export const v1SpectroClustersTemplatesUidClustersUpgrade = async (uid: string,
    clusterTemplateUpgradeSpec: ClusterTemplateUpgradeSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1SpectroClustersTemplatesUidClustersUpgradeUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterTemplateUpgradeSpec,)
  }
);}



/**
 * @summary Returns the associated profiles for all the cluster of launched from the specified cluster template
 */
export const getV1SpectroClustersClusterTemplatesUIDProfilesGetUrl = (uid: string,
    params?: V1SpectroClustersClusterTemplatesUIDProfilesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/clusterTemplates/${uid}/profiles?${stringifiedParams}` : `/v1/spectroclusters/clusterTemplates/${uid}/profiles`
}

export const v1SpectroClustersClusterTemplatesUIDProfilesGet = async (uid: string,
    params?: V1SpectroClustersClusterTemplatesUIDProfilesGetParams, options?: RequestInit): Promise<SpectroClusterProfileList> => {
  
  return customFetch<SpectroClusterProfileList>(getV1SpectroClustersClusterTemplatesUIDProfilesGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Cluster configuration for the edge installer
 */
export const getSpectroClustersConfigEdgeInstallerUrl = () => {


  

  return `/v1/spectroclusters/config/edgeInstaller`
}

export const spectroClustersConfigEdgeInstaller = async ( options?: RequestInit): Promise<ClusterEdgeInstallerConfig> => {
  
  return customFetch<ClusterEdgeInstallerConfig>(getSpectroClustersConfigEdgeInstallerUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates an EdgeNative cluster
 */
export const getSpectroClustersEdgeNativeCreateUrl = () => {


  

  return `/v1/spectroclusters/edge-native`
}

export const spectroClustersEdgeNativeCreate = async (v1SpectroEdgeNativeClusterEntityBody: V1SpectroEdgeNativeClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersEdgeNativeCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroEdgeNativeClusterEntityBody,)
  }
);}



/**
 * @summary Imports an EdgeNative cluster
 */
export const getSpectroClustersEdgeNativeImportUrl = () => {


  

  return `/v1/spectroclusters/edge-native/import`
}

export const spectroClustersEdgeNativeImport = async (spectroEdgeNativeClusterImportEntity: SpectroEdgeNativeClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersEdgeNativeImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroEdgeNativeClusterImportEntity,)
  }
);}



/**
 * @summary Get edge-native cluster estimated rate information
 */
export const getSpectroClustersEdgeNativeRateUrl = (params?: SpectroClustersEdgeNativeRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/edge-native/rate?${stringifiedParams}` : `/v1/spectroclusters/edge-native/rate`
}

export const spectroClustersEdgeNativeRate = async (spectroEdgeNativeClusterRateEntity: SpectroEdgeNativeClusterRateEntity,
    params?: SpectroClustersEdgeNativeRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersEdgeNativeRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroEdgeNativeClusterRateEntity,)
  }
);}



/**
 * @summary Validates edge-native cluster create operation
 */
export const getSpectroClustersEdgeNativeValidateUrl = () => {


  

  return `/v1/spectroclusters/edge-native/validate`
}

export const spectroClustersEdgeNativeValidate = async (v1SpectroEdgeNativeClusterEntityBody: V1SpectroEdgeNativeClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersEdgeNativeValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroEdgeNativeClusterEntityBody,)
  }
);}



/**
 * @summary Creates an EKS cluster
 */
export const getSpectroClustersEksCreateUrl = () => {


  

  return `/v1/spectroclusters/eks`
}

export const spectroClustersEksCreate = async (v1SpectroEksClusterEntityBody: V1SpectroEksClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersEksCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroEksClusterEntityBody,)
  }
);}



/**
 * @summary Get EKS cluster estimated rate information
 */
export const getSpectroClustersEksRateUrl = (params?: SpectroClustersEksRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/eks/rate?${stringifiedParams}` : `/v1/spectroclusters/eks/rate`
}

export const spectroClustersEksRate = async (spectroEksClusterRateEntity: SpectroEksClusterRateEntity,
    params?: SpectroClustersEksRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersEksRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroEksClusterRateEntity,)
  }
);}



/**
 * @summary Validates EKS cluster create operation
 */
export const getSpectroClustersEksValidateUrl = () => {


  

  return `/v1/spectroclusters/eks/validate`
}

export const spectroClustersEksValidate = async (v1SpectroEksClusterEntityBody: V1SpectroEksClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersEksValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroEksClusterEntityBody,)
  }
);}



/**
 * @summary Returns the cluster object references based on locationUid
 */
export const getV1ClusterFeatureBackupLocationUidGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/features/backup/locations/${uid}`
}

export const v1ClusterFeatureBackupLocationUidGet = async (uid: string, options?: RequestInit): Promise<ClusterRefs> => {
  
  return customFetch<ClusterRefs>(getV1ClusterFeatureBackupLocationUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Change cluster backup location
 */
export const getV1ClusterFeatureBackupLocationUidChangeUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/features/backup/locations/${uid}`
}

export const v1ClusterFeatureBackupLocationUidChange = async (uid: string,
    clusterBackupLocationType: ClusterBackupLocationType, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ClusterFeatureBackupLocationUidChangeUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterBackupLocationType,)
  }
);}



/**
 * @summary Download log fetcher logs for cluster by log fetcher uid
 */
export const getClusterFeatureLogFetcherLogDownloadUrl = (uid: string,
    params?: ClusterFeatureLogFetcherLogDownloadParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/features/logFetcher/${uid}/download?${stringifiedParams}` : `/v1/spectroclusters/features/logFetcher/${uid}/download`
}

export const clusterFeatureLogFetcherLogDownload = async (uid: string,
    params?: ClusterFeatureLogFetcherLogDownloadParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getClusterFeatureLogFetcherLogDownloadUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update log fetcher logs by log fetcher uid
 */
export const getClusterFeatureLogFetcherLogUpdateUrl = (uid: string,
    params?: ClusterFeatureLogFetcherLogUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/features/logFetcher/${uid}/log?${stringifiedParams}` : `/v1/spectroclusters/features/logFetcher/${uid}/log`
}

export const clusterFeatureLogFetcherLogUpdate = async (uid: string,
    clusterFeatureLogFetcherLogUpdateBody: ClusterFeatureLogFetcherLogUpdateBody,
    params?: ClusterFeatureLogFetcherLogUpdateParams, options?: RequestInit): Promise<void> => {
    const formData = new FormData();
if(clusterFeatureLogFetcherLogUpdateBody.fileName !== undefined) {
 formData.append(`fileName`, clusterFeatureLogFetcherLogUpdateBody.fileName)
 }

  return customFetch<void>(getClusterFeatureLogFetcherLogUpdateUrl(uid,params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}



/**
 * @summary Creates a GCP cluster
 */
export const getSpectroClustersGcpCreateUrl = () => {


  

  return `/v1/spectroclusters/gcp`
}

export const spectroClustersGcpCreate = async (v1SpectroGcpClusterEntityBody: V1SpectroGcpClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersGcpCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroGcpClusterEntityBody,)
  }
);}



/**
 * @summary Imports a GCP cluster
 */
export const getSpectroClustersGcpImportUrl = () => {


  

  return `/v1/spectroclusters/gcp/import`
}

export const spectroClustersGcpImport = async (spectroGcpClusterImportEntity: SpectroGcpClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersGcpImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroGcpClusterImportEntity,)
  }
);}



/**
 * @summary Get GCP cluster estimated rate information
 */
export const getSpectroClustersGcpRateUrl = (params?: SpectroClustersGcpRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/gcp/rate?${stringifiedParams}` : `/v1/spectroclusters/gcp/rate`
}

export const spectroClustersGcpRate = async (v1SpectroGcpClusterRateEntityBody: V1SpectroGcpClusterRateEntityBody,
    params?: SpectroClustersGcpRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersGcpRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroGcpClusterRateEntityBody,)
  }
);}



/**
 * @summary Validates GCP cluster create operation
 */
export const getSpectroClustersGcpValidateUrl = () => {


  

  return `/v1/spectroclusters/gcp/validate`
}

export const spectroClustersGcpValidate = async (v1SpectroGcpClusterEntityBody: V1SpectroGcpClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersGcpValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroGcpClusterEntityBody,)
  }
);}



/**
 * The machines information will be captured, whereas the cloud specific configuration info will not be retrieved
 * @summary Imports a cluster of any cloud type in generic way
 */
export const getSpectroClustersGenericImportUrl = () => {


  

  return `/v1/spectroclusters/generic/import`
}

export const spectroClustersGenericImport = async (spectroGenericClusterImportEntity: SpectroGenericClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersGenericImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroGenericClusterImportEntity,)
  }
);}



/**
 * @summary Get generic cluster estimated rate information
 */
export const getSpectroClustersGenericRateUrl = (params?: SpectroClustersGenericRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/generic/rate?${stringifiedParams}` : `/v1/spectroclusters/generic/rate`
}

export const spectroClustersGenericRate = async (spectroGenericClusterRateEntity: SpectroGenericClusterRateEntity,
    params?: SpectroClustersGenericRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersGenericRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroGenericClusterRateEntity,)
  }
);}



/**
 * @summary Creates an GKE cluster
 */
export const getSpectroClustersGkeCreateUrl = () => {


  

  return `/v1/spectroclusters/gke`
}

export const spectroClustersGkeCreate = async (v1SpectroGcpClusterEntityBody: V1SpectroGcpClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersGkeCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroGcpClusterEntityBody,)
  }
);}



/**
 * @summary Get GKE cluster estimated rate information
 */
export const getSpectroClustersGkeRateUrl = (params?: SpectroClustersGkeRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/gke/rate?${stringifiedParams}` : `/v1/spectroclusters/gke/rate`
}

export const spectroClustersGkeRate = async (v1SpectroGcpClusterRateEntityBody: V1SpectroGcpClusterRateEntityBody,
    params?: SpectroClustersGkeRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersGkeRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroGcpClusterRateEntityBody,)
  }
);}



/**
 * @summary Validates GKE cluster create operation
 */
export const getSpectroClustersGkeValidateUrl = () => {


  

  return `/v1/spectroclusters/gke/validate`
}

export const spectroClustersGkeValidate = async (v1SpectroGcpClusterEntityBody: V1SpectroGcpClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersGkeValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroGcpClusterEntityBody,)
  }
);}



/**
 * @summary Creates a MAAS cluster
 */
export const getSpectroClustersMaasCreateUrl = () => {


  

  return `/v1/spectroclusters/maas`
}

export const spectroClustersMaasCreate = async (v1SpectroMaasClusterEntityBody: V1SpectroMaasClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersMaasCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroMaasClusterEntityBody,)
  }
);}



/**
 * @summary Imports a Maas cluster
 */
export const getSpectroClustersMaasImportUrl = () => {


  

  return `/v1/spectroclusters/maas/import`
}

export const spectroClustersMaasImport = async (spectroMaasClusterImportEntity: SpectroMaasClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersMaasImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroMaasClusterImportEntity,)
  }
);}



/**
 * @summary Get maas cluster estimated rate information
 */
export const getSpectroClustersMaasRateUrl = (params?: SpectroClustersMaasRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/maas/rate?${stringifiedParams}` : `/v1/spectroclusters/maas/rate`
}

export const spectroClustersMaasRate = async (spectroMaasClusterRateEntity: SpectroMaasClusterRateEntity,
    params?: SpectroClustersMaasRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersMaasRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroMaasClusterRateEntity,)
  }
);}



/**
 * @summary Validates MAAS cluster create operation
 */
export const getSpectroClustersMaasValidateUrl = () => {


  

  return `/v1/spectroclusters/maas/validate`
}

export const spectroClustersMaasValidate = async (v1SpectroMaasClusterEntityBody: V1SpectroMaasClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersMaasValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroMaasClusterEntityBody,)
  }
);}



/**
 * @summary Creates a OpenStack cluster
 */
export const getSpectroClustersOpenStackCreateUrl = () => {


  

  return `/v1/spectroclusters/openstack`
}

export const spectroClustersOpenStackCreate = async (v1SpectroOpenStackClusterEntityBody: V1SpectroOpenStackClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersOpenStackCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroOpenStackClusterEntityBody,)
  }
);}



/**
 * @summary Imports an OpenStack cluster
 */
export const getSpectroClustersOpenStackImportUrl = () => {


  

  return `/v1/spectroclusters/openstack/import`
}

export const spectroClustersOpenStackImport = async (spectroOpenStackClusterImportEntity: SpectroOpenStackClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersOpenStackImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroOpenStackClusterImportEntity,)
  }
);}



/**
 * @summary Get openstack cluster estimated rate information
 */
export const getSpectroClustersOpenStackRateUrl = (params?: SpectroClustersOpenStackRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/openstack/rate?${stringifiedParams}` : `/v1/spectroclusters/openstack/rate`
}

export const spectroClustersOpenStackRate = async (spectroOpenStackClusterRateEntity: SpectroOpenStackClusterRateEntity,
    params?: SpectroClustersOpenStackRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersOpenStackRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroOpenStackClusterRateEntity,)
  }
);}



/**
 * @summary Validates OpenStack cluster create operation
 */
export const getSpectroClustersOpenStackValidateUrl = () => {


  

  return `/v1/spectroclusters/openstack/validate`
}

export const spectroClustersOpenStackValidate = async (v1SpectroOpenStackClusterEntityBody: V1SpectroOpenStackClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersOpenStackValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroOpenStackClusterEntityBody,)
  }
);}



/**
 * @summary Downloads the cluster definition archive file
 */
export const getSpectroClustersSpcDownloadUrl = () => {


  

  return `/v1/spectroclusters/spc/download`
}

export const spectroClustersSpcDownload = async (clusterDefinitionEntity: ClusterDefinitionEntity, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersSpcDownloadUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterDefinitionEntity,)
  }
);}



/**
 * @summary Retrieves a list of spectrocluster tags
 */
export const getSpectroClustersTagsGetUrl = () => {


  

  return `/v1/spectroclusters/tags`
}

export const spectroClustersTagsGet = async ( options?: RequestInit): Promise<SpectroClusterTags> => {
  
  return customFetch<SpectroClusterTags>(getSpectroClustersTagsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get cluster settings by context
 */
export const getSpectroClustersUpgradeSettingsGetUrl = () => {


  

  return `/v1/spectroclusters/upgrade/settings`
}

export const spectroClustersUpgradeSettingsGet = async ( options?: RequestInit): Promise<ClusterUpgradeSettingsEntity> => {
  
  return customFetch<ClusterUpgradeSettingsEntity>(getSpectroClustersUpgradeSettingsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update all clusters upgrade settings
 */
export const getSpectroClustersUpgradeSettingsUrl = () => {


  

  return `/v1/spectroclusters/upgrade/settings`
}

export const spectroClustersUpgradeSettings = async (v1ClusterUpgradeSettingsEntityBody: V1ClusterUpgradeSettingsEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpgradeSettingsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterUpgradeSettingsEntityBody,)
  }
);}



/**
 * @summary Validates the cluster name
 */
export const getSpectroClustersValidateNameUrl = (params?: SpectroClustersValidateNameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/validate/name?${stringifiedParams}` : `/v1/spectroclusters/validate/name`
}

export const spectroClustersValidateName = async (params?: SpectroClustersValidateNameParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersValidateNameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates spectro cluster packs
 */
export const getSpectroClustersValidatePacksUrl = () => {


  

  return `/v1/spectroclusters/validate/packs`
}

export const spectroClustersValidatePacks = async (v1SpectroClusterPacksEntityBody: V1SpectroClusterPacksEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersValidatePacksUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterPacksEntityBody,)
  }
);}



/**
 * @summary Creates a virtual cluster
 */
export const getSpectroClustersVirtualCreateUrl = () => {


  

  return `/v1/spectroclusters/virtual`
}

export const spectroClustersVirtualCreate = async (v1SpectroVirtualClusterEntityBody: V1SpectroVirtualClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersVirtualCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroVirtualClusterEntityBody,)
  }
);}



/**
 * @summary Get the cluster pack values yaml
 */
export const getVirtualClustersPacksValuesUrl = (params?: VirtualClustersPacksValuesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/virtual/packs/values?${stringifiedParams}` : `/v1/spectroclusters/virtual/packs/values`
}

export const virtualClustersPacksValues = async (params?: VirtualClustersPacksValuesParams, options?: RequestInit): Promise<ClusterVirtualPacksValues> => {
  
  return customFetch<ClusterVirtualPacksValues>(getVirtualClustersPacksValuesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Validates virtual cluster create operation
 */
export const getSpectroClustersVirtualValidateUrl = () => {


  

  return `/v1/spectroclusters/virtual/validate`
}

export const spectroClustersVirtualValidate = async (v1SpectroVirtualClusterEntityBody: V1SpectroVirtualClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersVirtualValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroVirtualClusterEntityBody,)
  }
);}



/**
 * @summary Creates a vSphere cluster
 */
export const getSpectroClustersVsphereCreateUrl = () => {


  

  return `/v1/spectroclusters/vsphere`
}

export const spectroClustersVsphereCreate = async (v1SpectroVsphereClusterEntityBody: V1SpectroVsphereClusterEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersVsphereCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroVsphereClusterEntityBody,)
  }
);}



/**
 * @summary Imports a vSphere cluster
 */
export const getSpectroClustersVsphereImportUrl = () => {


  

  return `/v1/spectroclusters/vsphere/import`
}

export const spectroClustersVsphereImport = async (spectroVsphereClusterImportEntity: SpectroVsphereClusterImportEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getSpectroClustersVsphereImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroVsphereClusterImportEntity,)
  }
);}



/**
 * @summary Get vSphere cluster estimated rate information
 */
export const getSpectroClustersVsphereRateUrl = (params?: SpectroClustersVsphereRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/vsphere/rate?${stringifiedParams}` : `/v1/spectroclusters/vsphere/rate`
}

export const spectroClustersVsphereRate = async (spectroVsphereClusterRateEntity: SpectroVsphereClusterRateEntity,
    params?: SpectroClustersVsphereRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersVsphereRateUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroVsphereClusterRateEntity,)
  }
);}



/**
 * @summary Validates vSphere cluster create operation
 */
export const getSpectroClustersVsphereValidateUrl = () => {


  

  return `/v1/spectroclusters/vsphere/validate`
}

export const spectroClustersVsphereValidate = async (v1SpectroVsphereClusterEntityBody: V1SpectroVsphereClusterEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersVsphereValidateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroVsphereClusterEntityBody,)
  }
);}



/**
 * @summary Deletes the specified cluster
 */
export const getSpectroClustersDeleteUrl = (uid: string,
    params?: SpectroClustersDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}?${stringifiedParams}` : `/v1/spectroclusters/${uid}`
}

export const spectroClustersDelete = async (uid: string,
    params?: SpectroClustersDeleteParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersDeleteUrl(uid,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster
 */
export const getSpectroClustersGetUrl = (uid: string,
    params?: SpectroClustersGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}?${stringifiedParams}` : `/v1/spectroclusters/${uid}`
}

export const spectroClustersGet = async (uid: string,
    params?: SpectroClustersGetParams, options?: RequestInit): Promise<SpectroCluster> => {
  
  return customFetch<SpectroCluster>(getSpectroClustersGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the cluster asset doc
 */
export const getSpectroClustersUidAssetsGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets`
}

export const spectroClustersUidAssetsGet = async (uid: string, options?: RequestInit): Promise<SpectroClusterAssetEntity> => {
  
  return customFetch<SpectroClusterAssetEntity>(getSpectroClustersUidAssetsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Associate the assets for the cluster
 */
export const getSpectroClustersUidAssetsUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets`
}

export const spectroClustersUidAssets = async (uid: string,
    spectroClusterAssetEntity: SpectroClusterAssetEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidAssetsUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterAssetEntity,)
  }
);}



/**
 * @summary Returns the specified cluster's kube config file
 */
export const getSpectroClustersUidAdminKubeConfigUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/adminKubeconfig`
}

export const spectroClustersUidAdminKubeConfig = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidAdminKubeConfigUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the cluster's token kube config data
 */
export const getSpectroClustersUidTokenKubeConfigDeleteUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/adminTokenKubeconfig`
}

export const spectroClustersUidTokenKubeConfigDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidTokenKubeConfigDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster's token kube config file
 */
export const getSpectroClustersUidTokenKubeConfigGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/adminTokenKubeconfig`
}

export const spectroClustersUidTokenKubeConfigGet = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidTokenKubeConfigGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster's token kube config data
 */
export const getSpectroClustersUidTokenKubeConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/adminTokenKubeconfig`
}

export const spectroClustersUidTokenKubeConfigUpdate = async (uid: string,
    spectroClusterAssetTokenKubeConfig: SpectroClusterAssetTokenKubeConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidTokenKubeConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterAssetTokenKubeConfig,)
  }
);}



/**
 * @summary Deletes the cluster's frp kube config client data
 */
export const getSpectroClustersUidFrpKubeConfigDeleteUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/frpKubeconfig`
}

export const spectroClustersUidFrpKubeConfigDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidFrpKubeConfigDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster's frp kube config file
 */
export const getSpectroClustersUidFrpKubeConfigGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/frpKubeconfig`
}

export const spectroClustersUidFrpKubeConfigGet = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidFrpKubeConfigGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster's frp kube config data
 */
export const getSpectroClustersUidFrpKubeConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/frpKubeconfig`
}

export const spectroClustersUidFrpKubeConfigUpdate = async (uid: string,
    spectroClusterAssetFrpKubeConfig: SpectroClusterAssetFrpKubeConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidFrpKubeConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterAssetFrpKubeConfig,)
  }
);}



/**
 * @summary Returns the specified cluster's kube config file
 */
export const getSpectroClustersUidKubeConfigUrl = (uid: string,
    params?: SpectroClustersUidKubeConfigParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/assets/kubeconfig?${stringifiedParams}` : `/v1/spectroclusters/${uid}/assets/kubeconfig`
}

export const spectroClustersUidKubeConfig = async (uid: string,
    params?: SpectroClustersUidKubeConfigParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidKubeConfigUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster's manifest data
 */
export const getSpectroClustersUidKubeConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/kubeconfig`
}

export const spectroClustersUidKubeConfigUpdate = async (uid: string,
    spectroClusterAssetKubeConfig: SpectroClusterAssetKubeConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidKubeConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterAssetKubeConfig,)
  }
);}



/**
 * @summary Deletes the cluster's kube config client data
 */
export const getSpectroClustersUidKubeConfigClientDeleteUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/kubeconfigclient`
}

export const spectroClustersUidKubeConfigClientDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidKubeConfigClientDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified cluster's kube config client file
 */
export const getSpectroClustersUidKubeConfigClientGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/kubeconfigclient`
}

export const spectroClustersUidKubeConfigClientGet = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidKubeConfigClientGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster's kube config client data
 */
export const getSpectroClustersUidKubeConfigClientUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/kubeconfigclient`
}

export const spectroClustersUidKubeConfigClientUpdate = async (uid: string,
    spectroClusterAssetKubeConfigClient: SpectroClusterAssetKubeConfigClient, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidKubeConfigClientUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterAssetKubeConfigClient,)
  }
);}



/**
 * @summary Returns the specified cluster's manifest data
 */
export const getSpectroClustersUidManifestGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/manifest`
}

export const spectroClustersUidManifestGet = async (uid: string, options?: RequestInit): Promise<string> => {
  
  return customFetch<string>(getSpectroClustersUidManifestGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified cluster's manifest data
 */
export const getSpectroClustersUidManifestUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/assets/manifest`
}

export const spectroClustersUidManifestUpdate = async (uid: string,
    spectroClusterAssetManifest: SpectroClusterAssetManifest, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidManifestUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterAssetManifest,)
  }
);}



/**
 * @summary Updates the specified cluster meta attribute
 */
export const getSpectroClustersUidClusterMetaAttributeUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/clusterConfig/clusterMetaAttribute`
}

export const spectroClustersUidClusterMetaAttributeUpdate = async (uid: string,
    clusterMetaAttributeEntity: ClusterMetaAttributeEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidClusterMetaAttributeUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterMetaAttributeEntity,)
  }
);}



/**
 * @summary Updates the specified cluster controlPlane health check timeout
 */
export const getV1ControlPlaneHealthCheckTimeoutUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/clusterConfig/controlPlaneHealthCheckTimeout`
}

export const v1ControlPlaneHealthCheckTimeoutUpdate = async (uid: string,
    controlPlaneHealthCheckTimeoutEntity: ControlPlaneHealthCheckTimeoutEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1ControlPlaneHealthCheckTimeoutUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      controlPlaneHealthCheckTimeoutEntity,)
  }
);}



/**
 * @summary Updates the specified cluster host config
 */
export const getV1HostClusterConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/clusterConfig/hostCluster`
}

export const v1HostClusterConfigUpdate = async (uid: string,
    hostClusterConfigEntity: HostClusterConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1HostClusterConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hostClusterConfigEntity,)
  }
);}



/**
 * @summary Updates the specified cluster Life cycle configuration
 */
export const getSpectroClustersUidLifecycleConfigUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/clusterConfig/lifecycleConfig`
}

export const spectroClustersUidLifecycleConfigUpdate = async (uid: string,
    lifecycleConfigEntity: LifecycleConfigEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidLifecycleConfigUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      lifecycleConfigEntity,)
  }
);}



/**
 * @summary Updates the specified cluster OS patch configuration
 */
export const getSpectroClustersUidOsPatchUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/clusterConfig/osPatch`
}

export const spectroClustersUidOsPatchUpdate = async (uid: string,
    osPatchEntity: OsPatchEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidOsPatchUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      osPatchEntity,)
  }
);}



/**
 * @summary Updates the specified cluster's timezone configuration
 */
export const getSpectroClustersUidTimezoneUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/clusterConfig/timezone`
}

export const spectroClustersUidTimezoneUpdate = async (uid: string,
    timezoneUpdateEntity: TimezoneUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidTimezoneUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      timezoneUpdateEntity,)
  }
);}



/**
 * @summary Retrieves namespaces for the specified cluster
 */
export const getSpectroClustersUidConfigNamespacesGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/namespaces`
}

export const spectroClustersUidConfigNamespacesGet = async (uid: string, options?: RequestInit): Promise<ClusterNamespaceResources> => {
  
  return customFetch<ClusterNamespaceResources>(getSpectroClustersUidConfigNamespacesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates namespaces for the specified cluster
 */
export const getSpectroClustersUidConfigNamespacesUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/namespaces`
}

export const spectroClustersUidConfigNamespacesUpdate = async (uid: string,
    clusterNamespaceResourcesUpdateEntity: ClusterNamespaceResourcesUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidConfigNamespacesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterNamespaceResourcesUpdateEntity,)
  }
);}



/**
 * @summary Retrieves the specified namespace of the cluster
 */
export const getSpectroClustersUidConfigNamespacesUidGetUrl = (uid: string,
    namespaceUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/namespaces/${namespaceUid}`
}

export const spectroClustersUidConfigNamespacesUidGet = async (uid: string,
    namespaceUid: string, options?: RequestInit): Promise<ClusterNamespaceResource> => {
  
  return customFetch<ClusterNamespaceResource>(getSpectroClustersUidConfigNamespacesUidGetUrl(uid,namespaceUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified namespace of the cluster
 */
export const getSpectroClustersUidConfigNamespacesUidUpdateUrl = (uid: string,
    namespaceUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/namespaces/${namespaceUid}`
}

export const spectroClustersUidConfigNamespacesUidUpdate = async (uid: string,
    namespaceUid: string,
    clusterNamespaceResourceInputEntity: ClusterNamespaceResourceInputEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidConfigNamespacesUidUpdateUrl(uid,namespaceUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterNamespaceResourceInputEntity,)
  }
);}



/**
 * @summary Retrieves RBAC information for the specified cluster
 */
export const getSpectroClustersUidConfigRbacsGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/rbacs`
}

export const spectroClustersUidConfigRbacsGet = async (uid: string, options?: RequestInit): Promise<ClusterRbacs> => {
  
  return customFetch<ClusterRbacs>(getSpectroClustersUidConfigRbacsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates RBAC information for the specified cluster
 */
export const getSpectroClustersUidConfigRbacsUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/rbacs`
}

export const spectroClustersUidConfigRbacsUpdate = async (uid: string,
    clusterRbacResourcesUpdateEntity: ClusterRbacResourcesUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidConfigRbacsUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterRbacResourcesUpdateEntity,)
  }
);}



/**
 * @summary Retrieves the specified RBAC of the cluster
 */
export const getSpectroClustersUidConfigRbacsUidGetUrl = (uid: string,
    rbacUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/rbacs/${rbacUid}`
}

export const spectroClustersUidConfigRbacsUidGet = async (uid: string,
    rbacUid: string, options?: RequestInit): Promise<ClusterRbac> => {
  
  return customFetch<ClusterRbac>(getSpectroClustersUidConfigRbacsUidGetUrl(uid,rbacUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified RBAC of the cluster
 */
export const getSpectroClustersUidConfigRbacsUidUpdateUrl = (uid: string,
    rbacUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/config/rbacs/${rbacUid}`
}

export const spectroClustersUidConfigRbacsUidUpdate = async (uid: string,
    rbacUid: string,
    clusterRbacInputEntity: ClusterRbacInputEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidConfigRbacsUidUpdateUrl(uid,rbacUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterRbacInputEntity,)
  }
);}



/**
 * @summary Download the specified cluster
 */
export const getSpectroClustersUidDownloadUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/download`
}

export const spectroClustersUidDownload = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidDownloadUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of edge host of edge-native cluster
 */
export const getEdgeNativeClustersHostsListUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/edge-native/edgeHosts`
}

export const edgeNativeClustersHostsList = async (uid: string, options?: RequestInit): Promise<EdgeHostDevices> => {
  
  return customFetch<EdgeHostDevices>(getEdgeNativeClustersHostsListUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary reset the edge clusters by deleting machine pools and conditions
 */
export const getV1SpectroClustersUidEdgeResetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/edge/reset`
}

export const v1SpectroClustersUidEdgeReset = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1SpectroClustersUidEdgeResetUrl(uid),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * @summary Reset cluster backup schedule settings
 */
export const getClusterFeatureBackupScheduleResetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/backup`
}

export const clusterFeatureBackupScheduleReset = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureBackupScheduleResetUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the cluster backup result
 */
export const getClusterFeatureBackupGetUrl = (uid: string,
    params?: ClusterFeatureBackupGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/backup?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/backup`
}

export const clusterFeatureBackupGet = async (uid: string,
    params?: ClusterFeatureBackupGetParams, options?: RequestInit): Promise<ClusterBackup> => {
  
  return customFetch<ClusterBackup>(getClusterFeatureBackupGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create cluster backup settings
 */
export const getClusterFeatureBackupCreateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/backup`
}

export const clusterFeatureBackupCreate = async (uid: string,
    v1ClusterBackupConfigBody: V1ClusterBackupConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterFeatureBackupCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterBackupConfigBody,)
  }
);}



/**
 * @summary Update cluster backup settings
 */
export const getClusterFeatureBackupUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/backup`
}

export const clusterFeatureBackupUpdate = async (uid: string,
    v1ClusterBackupConfigBody: V1ClusterBackupConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureBackupUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterBackupConfigBody,)
  }
);}



/**
 * @summary Create on demand cluster backup
 */
export const getClusterFeatureBackupOnDemandCreateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/backup/onDemand`
}

export const clusterFeatureBackupOnDemandCreate = async (uid: string,
    v1ClusterBackupConfigBody: V1ClusterBackupConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterFeatureBackupOnDemandCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterBackupConfigBody,)
  }
);}



/**
 * @summary Delete cluster backup
 */
export const getClusterFeatureBackupDeleteUrl = (uid: string,
    backupName: string,
    requestUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/backup/${backupName}/request/${requestUid}`
}

export const clusterFeatureBackupDelete = async (uid: string,
    backupName: string,
    requestUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureBackupDeleteUrl(uid,backupName,requestUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the compliance scan of cluster, if driverType is provided then specific status of driverType will be returned
 */
export const getClusterFeatureComplianceScanGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan`
}

export const clusterFeatureComplianceScanGet = async (uid: string, options?: RequestInit): Promise<ClusterComplianceScan> => {
  
  return customFetch<ClusterComplianceScan>(getClusterFeatureComplianceScanGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create cluster compliance scan
 */
export const getClusterFeatureComplianceScanCreateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan`
}

export const clusterFeatureComplianceScanCreate = async (uid: string,
    v1ClusterComplianceScheduleConfigBody: V1ClusterComplianceScheduleConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterFeatureComplianceScanCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterComplianceScheduleConfigBody,)
  }
);}



/**
 * @summary Update cluster compliance scan settings
 */
export const getClusterFeatureComplianceScanUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan`
}

export const clusterFeatureComplianceScanUpdate = async (uid: string,
    v1ClusterComplianceScheduleConfigBody: V1ClusterComplianceScheduleConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureComplianceScanUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterComplianceScheduleConfigBody,)
  }
);}



/**
 * @summary Returns the compliance scan log by cluster uid and driver type
 */
export const getClusterFeatureComplianceScanLogsGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/drivers`
}

export const clusterFeatureComplianceScanLogsGet = async (uid: string, options?: RequestInit): Promise<ClusterComplianceScanLogs> => {
  
  return customFetch<ClusterComplianceScanLogs>(getClusterFeatureComplianceScanLogsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the KubeBench compliance scan log by uid
 */
export const getClusterFeatureScanKubeBenchLogUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/drivers/kubeBench`
}

export const clusterFeatureScanKubeBenchLogUpdate = async (uid: string,
    kubeBenchEntity: KubeBenchEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureScanKubeBenchLogUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      kubeBenchEntity,)
  }
);}



/**
 * @summary Update the KubeHunter compliance scan log by uid
 */
export const getClusterFeatureScanKubeHunterLogUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/drivers/kubeHunter`
}

export const clusterFeatureScanKubeHunterLogUpdate = async (uid: string,
    kubeHunterEntity: KubeHunterEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureScanKubeHunterLogUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      kubeHunterEntity,)
  }
);}



/**
 * @summary Update the Sonobuoy compliance scan log by uid
 */
export const getClusterFeatureScanSonobuoyLogUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/drivers/sonobuoy`
}

export const clusterFeatureScanSonobuoyLogUpdate = async (uid: string,
    sonobuoyEntity: SonobuoyEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureScanSonobuoyLogUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sonobuoyEntity,)
  }
);}



/**
 * @summary Update the Syft compliance scan log by uid
 */
export const getClusterFeatureScanSyftLogUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/drivers/syft`
}

export const clusterFeatureScanSyftLogUpdate = async (uid: string,
    syftEntity: SyftEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureScanSyftLogUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      syftEntity,)
  }
);}



/**
 * @summary Delete the compliance scan log by uid
 */
export const getClusterFeatureComplianceScanLogDeleteUrl = (uid: string,
    logUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}`
}

export const clusterFeatureComplianceScanLogDelete = async (uid: string,
    logUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getClusterFeatureComplianceScanLogDeleteUrl(uid,logUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the KubeBench compliance scan log by uid
 */
export const getClusterFeatureKubeBenchLogGetUrl = (uid: string,
    logUid: string,
    params?: ClusterFeatureKubeBenchLogGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/kubeBench?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/kubeBench`
}

export const clusterFeatureKubeBenchLogGet = async (uid: string,
    logUid: string,
    params?: ClusterFeatureKubeBenchLogGetParams, options?: RequestInit): Promise<ClusterScanLogKubeBench> => {
  
  return customFetch<ClusterScanLogKubeBench>(getClusterFeatureKubeBenchLogGetUrl(uid,logUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the KubeHunter compliance scan log by uid
 */
export const getClusterFeatureKubeHunterLogGetUrl = (uid: string,
    logUid: string,
    params?: ClusterFeatureKubeHunterLogGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/kubeHunter?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/kubeHunter`
}

export const clusterFeatureKubeHunterLogGet = async (uid: string,
    logUid: string,
    params?: ClusterFeatureKubeHunterLogGetParams, options?: RequestInit): Promise<ClusterScanLogKubeHunter> => {
  
  return customFetch<ClusterScanLogKubeHunter>(getClusterFeatureKubeHunterLogGetUrl(uid,logUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the Sonobuoy compliance scan log by uid
 */
export const getClusterFeatureSonobuoyLogGetUrl = (uid: string,
    logUid: string,
    params?: ClusterFeatureSonobuoyLogGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/sonobuoy?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/sonobuoy`
}

export const clusterFeatureSonobuoyLogGet = async (uid: string,
    logUid: string,
    params?: ClusterFeatureSonobuoyLogGetParams, options?: RequestInit): Promise<ClusterScanLogSonobuoy> => {
  
  return customFetch<ClusterScanLogSonobuoy>(getClusterFeatureSonobuoyLogGetUrl(uid,logUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the Syft compliance scan log by uid
 */
export const getClusterFeatureSyftLogGetUrl = (uid: string,
    logUid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/syft`
}

export const clusterFeatureSyftLogGet = async (uid: string,
    logUid: string, options?: RequestInit): Promise<ClusterScanLogSyft> => {
  
  return customFetch<ClusterScanLogSyft>(getClusterFeatureSyftLogGetUrl(uid,logUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the image sbom of syft scan log of cluster
 */
export const getSyftScanLogImageSBOMGetUrl = (uid: string,
    logUid: string,
    params: SyftScanLogImageSBOMGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/syft/sbom?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/syft/sbom`
}

export const syftScanLogImageSBOMGet = async (uid: string,
    logUid: string,
    params: SyftScanLogImageSBOMGetParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSyftScanLogImageSBOMGetUrl(uid,logUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Downloads the driver cluster logs
 */
export const getClusterFeatureDriverLogDownloadUrl = (uid: string,
    logUid: string,
    driver: 'kubeBench' | 'kubeHunter' | 'sonobuoy' | 'syft',
    params?: ClusterFeatureDriverLogDownloadParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/${driver}/download?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/complianceScan/logs/${logUid}/drivers/${driver}/download`
}

export const clusterFeatureDriverLogDownload = async (uid: string,
    logUid: string,
    driver: 'kubeBench' | 'kubeHunter' | 'sonobuoy' | 'syft',
    params?: ClusterFeatureDriverLogDownloadParams, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getClusterFeatureDriverLogDownloadUrl(uid,logUid,driver,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create on demand cluster compliance scan
 */
export const getClusterFeatureComplianceScanOnDemandCreateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/complianceScan/onDemand`
}

export const clusterFeatureComplianceScanOnDemandCreate = async (uid: string,
    clusterComplianceOnDemandConfig: ClusterComplianceOnDemandConfig, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterFeatureComplianceScanOnDemandCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterComplianceOnDemandConfig,)
  }
);}



/**
 * @summary Get the installed helm charts of a specified cluster
 */
export const getClusterFeatureHelmChartsGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/helmCharts`
}

export const clusterFeatureHelmChartsGet = async (uid: string, options?: RequestInit): Promise<ClusterHelmCharts> => {
  
  return customFetch<ClusterHelmCharts>(getClusterFeatureHelmChartsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get the log fetcher for cluster
 */
export const getClusterFeatureLogFetcherGetUrl = (uid: string,
    params?: ClusterFeatureLogFetcherGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/logFetcher?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/logFetcher`
}

export const clusterFeatureLogFetcherGet = async (uid: string,
    params?: ClusterFeatureLogFetcherGetParams, options?: RequestInit): Promise<ClusterLogFetcher> => {
  
  return customFetch<ClusterLogFetcher>(getClusterFeatureLogFetcherGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create the log fetcher for cluster
 */
export const getClusterFeatureLogFetcherCreateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/logFetcher`
}

export const clusterFeatureLogFetcherCreate = async (uid: string,
    clusterLogFetcherRequest: ClusterLogFetcherRequest, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterFeatureLogFetcherCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterLogFetcherRequest,)
  }
);}



/**
 * @summary Get the installed manifests of a specified cluster
 */
export const getClusterFeatureManifestsGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/manifests`
}

export const clusterFeatureManifestsGet = async (uid: string, options?: RequestInit): Promise<ClusterManifests> => {
  
  return customFetch<ClusterManifests>(getClusterFeatureManifestsGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the cluster restore of cluster
 */
export const getClusterFeatureRestoreGetUrl = (uid: string,
    params?: ClusterFeatureRestoreGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/features/restore?${stringifiedParams}` : `/v1/spectroclusters/${uid}/features/restore`
}

export const clusterFeatureRestoreGet = async (uid: string,
    params?: ClusterFeatureRestoreGetParams, options?: RequestInit): Promise<ClusterRestore> => {
  
  return customFetch<ClusterRestore>(getClusterFeatureRestoreGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create on demand cluster restore
 */
export const getClusterFeatureRestoreOnDemandCreateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/features/restore/onDemand`
}

export const clusterFeatureRestoreOnDemandCreate = async (uid: string,
    clusterRestoreConfig: ClusterRestoreConfig, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getClusterFeatureRestoreOnDemandCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterRestoreConfig,)
  }
);}



/**
 * @summary Update specific cluster heartbeat
 */
export const getSpectroClustersUidHeartbeatUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/heartbeat`
}

export const spectroClustersUidHeartbeatUpdate = async (uid: string,
    spectroClusterHeartbeat: SpectroClusterHeartbeat, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidHeartbeatUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterHeartbeat,)
  }
);}



/**
 * @summary Returns the metadata of all hybrid pools associated with the specified cluster
 */
export const getSpectroClustersGetHybridPoolsMetadataUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/hybridPools/metadata`
}

export const spectroClustersGetHybridPoolsMetadata = async (uid: string, options?: RequestInit): Promise<SpectroClusterHybridPoolsMetadata> => {
  
  return customFetch<SpectroClusterHybridPoolsMetadata>(getSpectroClustersGetHybridPoolsMetadataUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update specific cluster hybrid settings
 */
export const getSpectroClustersUidHybridSettingsUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/hybridSettings`
}

export const spectroClustersUidHybridSettings = async (uid: string,
    clusterHybridSettingsEntity: ClusterHybridSettingsEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidHybridSettingsUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterHybridSettingsEntity,)
  }
);}



/**
 * @summary Returns the specified cluster's import manifest file
 */
export const getSpectroClustersUidImportManifestUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/import/manifest`
}

export const spectroClustersUidImportManifest = async (uid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getSpectroClustersUidImportManifestUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Upgrade the specified imported read only cluster with full permissions
 */
export const getSpectroClustersUidImportUpgradePatchUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/import/upgrade`
}

export const spectroClustersUidImportUpgradePatch = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidImportUpgradePatchUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Get K8Certificate for spectro cluster
 */
export const getSpectroClustersK8CertificateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/k8certificates`
}

export const spectroClustersK8Certificate = async (uid: string, options?: RequestInit): Promise<MachineCertificates> => {
  
  return customFetch<MachineCertificates>(getSpectroClustersK8CertificateUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update K8Certificate for spectro cluster
 */
export const getSpectroClustersK8CertificateUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/k8certificates`
}

export const spectroClustersK8CertificateUpdate = async (uid: string,
    spectroClusterK8sCertificate: SpectroClusterK8sCertificate, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersK8CertificateUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterK8sCertificate,)
  }
);}



/**
 * @summary Sets the cluster control plane nodes Kubernetes certificates for renewal
 */
export const getSpectroClustersCertificatesRenewUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/k8certificates/renew`
}

export const spectroClustersCertificatesRenew = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersCertificatesRenewUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Returns the specified cluster's kube config file
 */
export const getV1SpectroClustersUidKubeCtlRedirectUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/kubectl/redirect`
}

export const v1SpectroClustersUidKubeCtlRedirect = async (uid: string, options?: RequestInit): Promise<SpectroClusterKubeCtlRedirect> => {
  
  return customFetch<SpectroClusterKubeCtlRedirect>(getV1SpectroClustersUidKubeCtlRedirectUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Associate the assets for the cluster
 */
export const getSpectroClustersUidLocationPutUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/location`
}

export const spectroClustersUidLocationPut = async (uid: string,
    spectroClusterLocationInputEntity: SpectroClusterLocationInputEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidLocationPutUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterLocationInputEntity,)
  }
);}



/**
 * @summary Update the specified spectro cluster metadata
 */
export const getSpectroClustersUidMetadataUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/metadata`
}

export const spectroClustersUidMetadataUpdate = async (uid: string,
    v1ObjectMetaInputEntitySchemaBody: V1ObjectMetaInputEntitySchemaBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidMetadataUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ObjectMetaInputEntitySchemaBody,)
  }
);}



/**
 * @summary Returns available namespaces for the cluster
 */
export const getClusterNamespacesGetUrl = (uid: string,
    params?: ClusterNamespacesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/namespaces?${stringifiedParams}` : `/v1/spectroclusters/${uid}/namespaces`
}

export const clusterNamespacesGet = async (uid: string,
    params?: ClusterNamespacesGetParams, options?: RequestInit): Promise<ClusterNamespaces> => {
  
  return customFetch<ClusterNamespaces>(getClusterNamespacesGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns k8s spectrocluster oidc
 */
export const getV1SpectroClustersUidOIDCUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/oidc`
}

export const v1SpectroClustersUidOIDC = async (uid: string, options?: RequestInit): Promise<SpectroClusterOidcSpec> => {
  
  return customFetch<SpectroClusterOidcSpec>(getV1SpectroClustersUidOIDCUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns k8s dashboard url
 */
export const getV1SpectroClustersUidOIDCDashboardUrlUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/oidc/dashboard/url`
}

export const v1SpectroClustersUidOIDCDashboardUrl = async (uid: string, options?: RequestInit): Promise<SectroClusterK8sDashboardUrl> => {
  
  return customFetch<SectroClusterK8sDashboardUrl>(getV1SpectroClustersUidOIDCDashboardUrlUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified cluster's manifest
 */
export const getSpectroClustersUidPackManifestsUidGetUrl = (uid: string,
    manifestUid: string,
    params?: SpectroClustersUidPackManifestsUidGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/pack/manifests/${manifestUid}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/pack/manifests/${manifestUid}`
}

export const spectroClustersUidPackManifestsUidGet = async (uid: string,
    manifestUid: string,
    params?: SpectroClustersUidPackManifestsUidGetParams, options?: RequestInit): Promise<Manifest> => {
  
  return customFetch<Manifest>(getSpectroClustersUidPackManifestsUidGetUrl(uid,manifestUid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get specified cluster pack properties
 */
export const getSpectroClustersUidPackPropertiesUrl = (uid: string,
    params: SpectroClustersUidPackPropertiesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/pack/properties?${stringifiedParams}` : `/v1/spectroclusters/${uid}/pack/properties`
}

export const spectroClustersUidPackProperties = async (uid: string,
    params: SpectroClustersUidPackPropertiesParams, options?: RequestInit): Promise<SpectroClusterPackProperties> => {
  
  return customFetch<SpectroClusterPackProperties>(getSpectroClustersUidPackPropertiesUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the cluster's pack references
 */
export const getSpectroClustersPacksRefUpdateUrl = (uid: string,
    params?: SpectroClustersPacksRefUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/packRefs?${stringifiedParams}` : `/v1/spectroclusters/${uid}/packRefs`
}

export const spectroClustersPacksRefUpdate = async (uid: string,
    clusterNotificationUpdateEntity: ClusterNotificationUpdateEntity,
    params?: SpectroClustersPacksRefUpdateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersPacksRefUpdateUrl(uid,params),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterNotificationUpdateEntity,)
  }
);}



/**
 * @summary Returns the specified cluster's packs resolved values
 */
export const getSpectroClustersUidPacksResolvedValuesGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/packs/resolvedValues`
}

export const spectroClustersUidPacksResolvedValuesGet = async (uid: string, options?: RequestInit): Promise<SpectroClusterProfilesResolvedValues> => {
  
  return customFetch<SpectroClusterProfilesResolvedValues>(getSpectroClustersUidPacksResolvedValuesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Patch update specified cluster's packs status
 */
export const getSpectroClustersUidPacksStatusPatchUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/packs/status`
}

export const spectroClustersUidPacksStatusPatch = async (uid: string,
    v1SpectroClusterPacksStatusEntityBody: V1SpectroClusterPacksStatusEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidPacksStatusPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterPacksStatusEntityBody,)
  }
);}



/**
 * @summary Returns the profile updates of a specified cluster
 */
export const getSpectroClustersGetProfileUpdatesUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/profileUpdates`
}

export const spectroClustersGetProfileUpdates = async (uid: string, options?: RequestInit): Promise<SpectroClusterProfileUpdates> => {
  
  return customFetch<SpectroClusterProfileUpdates>(getSpectroClustersGetProfileUpdatesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Remove cluster profiles from the specified cluster
 */
export const getSpectroClustersDeleteProfilesUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/profiles`
}

export const spectroClustersDeleteProfiles = async (uid: string,
    spectroClusterProfilesDeleteEntity: SpectroClusterProfilesDeleteEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersDeleteProfilesUrl(uid),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterProfilesDeleteEntity,)
  }
);}



/**
 * @summary Returns the associated profiles of a specified cluster
 */
export const getSpectroClustersGetProfilesUrl = (uid: string,
    params?: SpectroClustersGetProfilesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/profiles?${stringifiedParams}` : `/v1/spectroclusters/${uid}/profiles`
}

export const spectroClustersGetProfiles = async (uid: string,
    params?: SpectroClustersGetProfilesParams, options?: RequestInit): Promise<SpectroClusterProfileList> => {
  
  return customFetch<SpectroClusterProfileList>(getSpectroClustersGetProfilesUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Patch cluster profiles to the specified cluster
 */
export const getSpectroClustersPatchProfilesUrl = (uid: string,
    params?: SpectroClustersPatchProfilesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/profiles?${stringifiedParams}` : `/v1/spectroclusters/${uid}/profiles`
}

export const spectroClustersPatchProfiles = async (uid: string,
    v1SpectroClusterProfilesBody: V1SpectroClusterProfilesBody,
    params?: SpectroClustersPatchProfilesParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersPatchProfilesUrl(uid,params),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterProfilesBody,)
  }
);}



/**
 * @summary Associate cluster profiles to the specified cluster
 */
export const getSpectroClustersUpdateProfilesUrl = (uid: string,
    params?: SpectroClustersUpdateProfilesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/profiles?${stringifiedParams}` : `/v1/spectroclusters/${uid}/profiles`
}

export const spectroClustersUpdateProfiles = async (uid: string,
    v1SpectroClusterProfilesBody: V1SpectroClusterProfilesBody,
    params?: SpectroClustersUpdateProfilesParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpdateProfilesUrl(uid,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterProfilesBody,)
  }
);}



/**
 * @summary Returns the associated profile's pack manifests of a specified cluster
 */
export const getSpectroClustersGetProfilesPacksManifestsUrl = (uid: string,
    params?: SpectroClustersGetProfilesPacksManifestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/profiles/packs/manifests?${stringifiedParams}` : `/v1/spectroclusters/${uid}/profiles/packs/manifests`
}

export const spectroClustersGetProfilesPacksManifests = async (uid: string,
    params?: SpectroClustersGetProfilesPacksManifestsParams, options?: RequestInit): Promise<SpectroClusterProfilesPacksManifests> => {
  
  return customFetch<SpectroClusterProfilesPacksManifests>(getSpectroClustersGetProfilesPacksManifestsUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified cluster's profile pack configuration
 */
export const getSpectroClustersUidProfilesUidPacksConfigGetUrl = (uid: string,
    profileUid: string,
    packName: string,) => {


  

  return `/v1/spectroclusters/${uid}/profiles/${profileUid}/packs/${packName}/config`
}

export const spectroClustersUidProfilesUidPacksConfigGet = async (uid: string,
    profileUid: string,
    packName: string, options?: RequestInit): Promise<SpectroClusterPackConfigList> => {
  
  return customFetch<SpectroClusterPackConfigList>(getSpectroClustersUidProfilesUidPacksConfigGetUrl(uid,profileUid,packName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the associated profiles pack manifests of the specified cluster
 */
export const getSpectroClustersProfilesUidPackManifestsGetUrl = (uid: string,
    profileUid: string,
    packName: string,) => {


  

  return `/v1/spectroclusters/${uid}/profiles/${profileUid}/packs/${packName}/manifests`
}

export const spectroClustersProfilesUidPackManifestsGet = async (uid: string,
    profileUid: string,
    packName: string, options?: RequestInit): Promise<PackManifests> => {
  
  return customFetch<PackManifests>(getSpectroClustersProfilesUidPackManifestsGetUrl(uid,profileUid,packName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates cluster profiles pack manifests to the specified cluster
 */
export const getSpectroClustersProfilesUidPackManifestsUpdateUrl = (uid: string,
    profileUid: string,
    packName: string,) => {


  

  return `/v1/spectroclusters/${uid}/profiles/${profileUid}/packs/${packName}/manifests`
}

export const spectroClustersProfilesUidPackManifestsUpdate = async (uid: string,
    profileUid: string,
    packName: string,
    manifestRefInputEntities: ManifestRefInputEntities, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersProfilesUidPackManifestsUpdateUrl(uid,profileUid,packName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      manifestRefInputEntities,)
  }
);}



/**
 * @summary Returns the estimated rate of the specified cluster
 */
export const getSpectroClustersUidRateUrl = (uid: string,
    params?: SpectroClustersUidRateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/rate?${stringifiedParams}` : `/v1/spectroclusters/${uid}/rate`
}

export const spectroClustersUidRate = async (uid: string,
    params?: SpectroClustersUidRateParams, options?: RequestInit): Promise<SpectroClusterRate> => {
  
  return customFetch<SpectroClusterRate>(getSpectroClustersUidRateUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the spectrocluster repave approve update
 */
export const getSpectroClustersUidRepaveApproveUpdateUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/repave/approve`
}

export const spectroClustersUidRepaveApproveUpdate = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidRepaveApproveUpdateUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Returns the spectrocluster repave
 */
export const getSpectroClustersUidRepaveGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/repave/status`
}

export const spectroClustersUidRepaveGet = async (uid: string, options?: RequestInit): Promise<SpectroClusterRepave> => {
  
  return customFetch<SpectroClusterRepave>(getSpectroClustersUidRepaveGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary reset the cluster s by deleting machine pools and condtions
 */
export const getV1SpectroClustersUidResetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/reset`
}

export const v1SpectroClustersUidReset = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1SpectroClustersUidResetUrl(uid),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Get the cluster's status
 */
export const getSpectroClustersUidStatusUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status`
}

export const spectroClustersUidStatus = async (uid: string, options?: RequestInit): Promise<SpectroClusterStatusEntity> => {
  
  return customFetch<SpectroClusterStatusEntity>(getSpectroClustersUidStatusUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified cluster status condition
 */
export const getSpectroClustersUpdateStatusConditionUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/condition`
}

export const spectroClustersUpdateStatusCondition = async (uid: string,
    clusterCondition: ClusterCondition, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpdateStatusConditionUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterCondition,)
  }
);}



/**
 * @summary Updates the specified cluster status conditions
 */
export const getSpectroClustersUpdateStatusConditionsUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/conditions`
}

export const spectroClustersUpdateStatusConditions = async (uid: string,
    clusterCondition: ClusterCondition[], options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpdateStatusConditionsUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      clusterCondition,)
  }
);}



/**
 * @summary Updates the specified cluster's service endpoints information
 */
export const getSpectroClustersUpdateStatusEndpointsUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/endpoints`
}

export const spectroClustersUpdateStatusEndpoints = async (uid: string,
    aPIEndpoint: APIEndpoint[], options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpdateStatusEndpointsUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      aPIEndpoint,)
  }
);}



/**
 * @summary Updates the specified cluster status as imported
 */
export const getSpectroClustersUpdateStatusImportedUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/imported`
}

export const spectroClustersUpdateStatusImported = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpdateStatusImportedUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Updates the specified cluster's services information
 */
export const getSpectroClustersUpdateStatusServicesUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/services`
}

export const spectroClustersUpdateStatusServices = async (uid: string,
    loadBalancerService: LoadBalancerService[], options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUpdateStatusServicesUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loadBalancerService,)
  }
);}



/**
 * @summary Returns the SPC apply information for the agent
 */
export const getSpectroClustersUidStatusSpcApplyGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/spcApply`
}

export const spectroClustersUidStatusSpcApplyGet = async (uid: string, options?: RequestInit): Promise<SpcApply> => {
  
  return customFetch<SpcApply>(getSpectroClustersUidStatusSpcApplyGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Set the CanBeApplied to true on the spcApply status. CanBeApplied indicates the agent to orchestrate the spc changes
 */
export const getSpectroClustersUidStatusSpcApplyUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/spcApply`
}

export const spectroClustersUidStatusSpcApply = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidStatusSpcApplyUrl(uid),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * @summary Updates the agent patch time for the SPC changes
 */
export const getSpectroClustersUidStatusSpcPatchTimeUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/spcApply/patchTime`
}

export const spectroClustersUidStatusSpcPatchTime = async (uid: string,
    spcPatchTimeEntity: SpcPatchTimeEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidStatusSpcPatchTimeUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spcPatchTimeEntity,)
  }
);}



/**
 * @summary Updates the cluster's upgrade status
 */
export const getSpectroClustersUidUpgradesPutUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/status/upgrades`
}

export const spectroClustersUidUpgradesPut = async (uid: string,
    spectroClusterUidUpgrades: SpectroClusterUidUpgrades, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidUpgradesPutUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterUidUpgrades,)
  }
);}



/**
 * @summary Update specific cluster upgrade settings
 */
export const getSpectroClustersUidUpgradeSettingsUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/upgrade/settings`
}

export const spectroClustersUidUpgradeSettings = async (uid: string,
    v1ClusterUpgradeSettingsEntityBody: V1ClusterUpgradeSettingsEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidUpgradeSettingsUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterUpgradeSettingsEntityBody,)
  }
);}



/**
 * @summary Validates cluster packs
 */
export const getSpectroClustersUidValidatePacksUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/validate/packs`
}

export const spectroClustersUidValidatePacks = async (uid: string,
    v1SpectroClusterPacksEntityBody: V1SpectroClusterPacksEntityBody, options?: RequestInit): Promise<SpectroClusterValidatorResponse> => {
  
  return customFetch<SpectroClusterValidatorResponse>(getSpectroClustersUidValidatePacksUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterPacksEntityBody,)
  }
);}



/**
 * @summary Validates if cluster gets repaved for the specified packs
 */
export const getSpectroClustersUidValidateRepaveUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/validate/repave`
}

export const spectroClustersUidValidateRepave = async (uid: string,
    v1SpectroClusterPacksEntityBody: V1SpectroClusterPacksEntityBody, options?: RequestInit): Promise<SpectroClusterRepaveValidationResponse> => {
  
  return customFetch<SpectroClusterRepaveValidationResponse>(getSpectroClustersUidValidateRepaveUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1SpectroClusterPacksEntityBody,)
  }
);}



/**
 * @summary Retrieve a list of variables associated with the cluster
 */
export const getSpectroClustersUidVariablesGetUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/variables`
}

export const spectroClustersUidVariablesGet = async (uid: string, options?: RequestInit): Promise<SpectroClusterVariables[]> => {
  
  return customFetch<SpectroClusterVariables[]>(getSpectroClustersUidVariablesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update cluster variable values for specified cluster
 */
export const getSpectroClustersUidVariablesPatchUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/variables`
}

export const spectroClustersUidVariablesPatch = async (uid: string,
    spectroClusterVariableUpdateEntity: SpectroClusterVariableUpdateEntity[], options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidVariablesPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterVariableUpdateEntity,)
  }
);}



/**
 * @summary Returns the list of virtual machines
 */
export const getSpectroClustersVMListUrl = (uid: string,
    params?: SpectroClustersVMListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["namespace"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms`
}

export const spectroClustersVMList = async (uid: string,
    params?: SpectroClustersVMListParams, options?: RequestInit): Promise<ClusterVirtualMachineList> => {
  
  return customFetch<ClusterVirtualMachineList>(getSpectroClustersVMListUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create virtual machine
 */
export const getSpectroClustersVMCreateUrl = (uid: string,
    params: SpectroClustersVMCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms`
}

export const spectroClustersVMCreate = async (uid: string,
    v1ClusterVirtualMachineBody: V1ClusterVirtualMachineBody,
    params: SpectroClustersVMCreateParams, options?: RequestInit): Promise<ClusterVirtualMachine> => {
  
  return customFetch<ClusterVirtualMachine>(getSpectroClustersVMCreateUrl(uid,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterVirtualMachineBody,)
  }
);}



/**
 * @summary Returns the list of snapshots of given namespaces
 */
export const getClusterVMSnapshotsListUrl = (uid: string,
    params?: ClusterVMSnapshotsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["vmName","namespace"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/snapshot?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/snapshot`
}

export const clusterVMSnapshotsList = async (uid: string,
    params?: ClusterVMSnapshotsListParams, options?: RequestInit): Promise<VirtualMachineSnapshotList> => {
  
  return customFetch<VirtualMachineSnapshotList>(getClusterVMSnapshotsListUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the virtual machine
 */
export const getSpectroClustersVMDeleteUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}`
}

export const spectroClustersVMDelete = async (uid: string,
    vmName: string,
    params: SpectroClustersVMDeleteParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMDeleteUrl(uid,vmName,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Get virtual machine
 */
export const getSpectroClustersVMGetUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}`
}

export const spectroClustersVMGet = async (uid: string,
    vmName: string,
    params: SpectroClustersVMGetParams, options?: RequestInit): Promise<ClusterVirtualMachine> => {
  
  return customFetch<ClusterVirtualMachine>(getSpectroClustersVMGetUrl(uid,vmName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified virtual machine of the cluster
 */
export const getSpectroClustersVMUpdateUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}`
}

export const spectroClustersVMUpdate = async (uid: string,
    vmName: string,
    v1ClusterVirtualMachineBody: V1ClusterVirtualMachineBody,
    params: SpectroClustersVMUpdateParams, options?: RequestInit): Promise<ClusterVirtualMachine> => {
  
  return customFetch<ClusterVirtualMachine>(getSpectroClustersVMUpdateUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterVirtualMachineBody,)
  }
);}



/**
 * @summary Add volume to the virtual machine instance
 */
export const getSpectroClustersVMAddVolumeUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMAddVolumeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/addVolume?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/addVolume`
}

export const spectroClustersVMAddVolume = async (uid: string,
    vmName: string,
    vMAddVolumeEntity: VMAddVolumeEntity,
    params: SpectroClustersVMAddVolumeParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMAddVolumeUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vMAddVolumeEntity,)
  }
);}



/**
 * @summary Clone virtual machine
 */
export const getSpectroClustersVMCloneUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMCloneParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/clone?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/clone`
}

export const spectroClustersVMClone = async (uid: string,
    vmName: string,
    spectroClusterVMCloneEntity: SpectroClusterVMCloneEntity,
    params: SpectroClustersVMCloneParams, options?: RequestInit): Promise<ClusterVirtualMachine> => {
  
  return customFetch<ClusterVirtualMachine>(getSpectroClustersVMCloneUrl(uid,vmName,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      spectroClusterVMCloneEntity,)
  }
);}



/**
 * @summary Migrate the virtual machine
 */
export const getSpectroClustersVMMigrateUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMMigrateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/migrate?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/migrate`
}

export const spectroClustersVMMigrate = async (uid: string,
    vmName: string,
    params: SpectroClustersVMMigrateParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMMigrateUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Pause the virtual machine instance
 */
export const getSpectroClustersVMPauseUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMPauseParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/pause?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/pause`
}

export const spectroClustersVMPause = async (uid: string,
    vmName: string,
    params: SpectroClustersVMPauseParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMPauseUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Remove volume from the virtual machine instance
 */
export const getSpectroClustersVMRemoveVolumeUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMRemoveVolumeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/removeVolume?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/removeVolume`
}

export const spectroClustersVMRemoveVolume = async (uid: string,
    vmName: string,
    vMRemoveVolumeEntity: VMRemoveVolumeEntity,
    params: SpectroClustersVMRemoveVolumeParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMRemoveVolumeUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vMRemoveVolumeEntity,)
  }
);}



/**
 * @summary Restart the virtual machine
 */
export const getSpectroClustersVMRestartUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMRestartParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/restart?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/restart`
}

export const spectroClustersVMRestart = async (uid: string,
    vmName: string,
    params: SpectroClustersVMRestartParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMRestartUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Resume the virtual machine instance
 */
export const getSpectroClustersVMResumeUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMResumeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/resume?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/resume`
}

export const spectroClustersVMResume = async (uid: string,
    vmName: string,
    params: SpectroClustersVMResumeParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMResumeUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Create snapshot of virtual machine
 */
export const getVMSnapshotCreateUrl = (uid: string,
    vmName: string,
    params: VMSnapshotCreateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot`
}

export const vMSnapshotCreate = async (uid: string,
    vmName: string,
    v1VirtualMachineSnapshotBody: V1VirtualMachineSnapshotBody,
    params: VMSnapshotCreateParams, options?: RequestInit): Promise<VirtualMachineSnapshot> => {
  
  return customFetch<VirtualMachineSnapshot>(getVMSnapshotCreateUrl(uid,vmName,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VirtualMachineSnapshotBody,)
  }
);}



/**
 * @summary Delete the snapshot of virtual machine
 */
export const getVMSnapshotDeleteUrl = (uid: string,
    vmName: string,
    snapshotName: string,
    params: VMSnapshotDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot/${snapshotName}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot/${snapshotName}`
}

export const vMSnapshotDelete = async (uid: string,
    vmName: string,
    snapshotName: string,
    params: VMSnapshotDeleteParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getVMSnapshotDeleteUrl(uid,vmName,snapshotName,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Get virtual machine snapshot
 */
export const getVMSnapshotGetUrl = (uid: string,
    vmName: string,
    snapshotName: string,
    params: VMSnapshotGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot/${snapshotName}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot/${snapshotName}`
}

export const vMSnapshotGet = async (uid: string,
    vmName: string,
    snapshotName: string,
    params: VMSnapshotGetParams, options?: RequestInit): Promise<VirtualMachineSnapshot> => {
  
  return customFetch<VirtualMachineSnapshot>(getVMSnapshotGetUrl(uid,vmName,snapshotName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified snapshot of a virtual machine
 */
export const getVMSnapshotUpdateUrl = (uid: string,
    vmName: string,
    snapshotName: string,
    params: VMSnapshotUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot/${snapshotName}?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/snapshot/${snapshotName}`
}

export const vMSnapshotUpdate = async (uid: string,
    vmName: string,
    snapshotName: string,
    v1VirtualMachineSnapshotBody: V1VirtualMachineSnapshotBody,
    params: VMSnapshotUpdateParams, options?: RequestInit): Promise<VirtualMachineSnapshot> => {
  
  return customFetch<VirtualMachineSnapshot>(getVMSnapshotUpdateUrl(uid,vmName,snapshotName,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VirtualMachineSnapshotBody,)
  }
);}



/**
 * @summary Start the virtual machine
 */
export const getSpectroClustersVMStartUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMStartParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/start?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/start`
}

export const spectroClustersVMStart = async (uid: string,
    vmName: string,
    params: SpectroClustersVMStartParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMStartUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * @summary Stop the virtual machine
 */
export const getSpectroClustersVMStopUrl = (uid: string,
    vmName: string,
    params: SpectroClustersVMStopParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/spectroclusters/${uid}/vms/${vmName}/stop?${stringifiedParams}` : `/v1/spectroclusters/${uid}/vms/${vmName}/stop`
}

export const spectroClustersVMStop = async (uid: string,
    vmName: string,
    params: SpectroClustersVMStopParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersVMStopUrl(uid,vmName,params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}



/**
 * Sync specified cluster workload
 * @summary Sync specified cluster workload
 */
export const getSpectroClustersUidWorkloadsSyncUrl = (uid: string,) => {


  

  return `/v1/spectroclusters/${uid}/workloads/sync`
}

export const spectroClustersUidWorkloadsSync = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidWorkloadsSyncUrl(uid),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * @summary Sync specified cluster workload
 */
export const getSpectroClustersUidWorkloadsKindSyncUrl = (uid: string,
    workloadKind: 'namespace' | 'pod' | 'deployment' | 'statefulset' | 'daemonset' | 'job' | 'cronjob' | 'rolebinding' | 'clusterrolebinding',) => {


  

  return `/v1/spectroclusters/${uid}/workloads/${workloadKind}/sync`
}

export const spectroClustersUidWorkloadsKindSync = async (uid: string,
    workloadKind: 'namespace' | 'pod' | 'deployment' | 'statefulset' | 'daemonset' | 'job' | 'cronjob' | 'rolebinding' | 'clusterrolebinding', options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getSpectroClustersUidWorkloadsKindSyncUrl(uid,workloadKind),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * @summary get the system config reverse proxy
 */
export const getV1SystemConfigReverseProxyGetUrl = () => {


  

  return `/v1/system/config/reverseproxy`
}

export const v1SystemConfigReverseProxyGet = async ( options?: RequestInit): Promise<SystemReverseProxy> => {
  
  return customFetch<SystemReverseProxy>(getV1SystemConfigReverseProxyGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary updates the system config reverse proxy
 */
export const getV1SystemConfigReverseProxyUpdateUrl = () => {


  

  return `/v1/system/config/reverseproxy`
}

export const v1SystemConfigReverseProxyUpdate = async (systemReverseProxy: SystemReverseProxy, options?: RequestInit): Promise<Updated> => {
  
  return customFetch<Updated>(getV1SystemConfigReverseProxyUpdateUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      systemReverseProxy,)
  }
);}



/**
 * @summary Delete a list of block listed passwords
 */
export const getV1PasswordsBlockListDeleteUrl = () => {


  

  return `/v1/system/passwords/blocklist`
}

export const v1PasswordsBlockListDelete = async (v1PasswordsBlockListBody: V1PasswordsBlockListBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1PasswordsBlockListDeleteUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1PasswordsBlockListBody,)
  }
);}



/**
 * @summary List of block listed passwords
 */
export const getV1PasswordsBlockListUpdateUrl = () => {


  

  return `/v1/system/passwords/blocklist`
}

export const v1PasswordsBlockListUpdate = async (v1PasswordsBlockListBody: V1PasswordsBlockListBody, options?: RequestInit): Promise<Updated> => {
  
  return customFetch<Updated>(getV1PasswordsBlockListUpdateUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1PasswordsBlockListBody,)
  }
);}



/**
 * @summary Retrieves a list of teams
 */
export const getTeamsListUrl = (params?: TeamsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/teams?${stringifiedParams}` : `/v1/teams`
}

export const teamsList = async (params?: TeamsListParams, options?: RequestInit): Promise<Teams> => {
  
  return customFetch<Teams>(getTeamsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a team with the specified users and roles
 */
export const getTeamsCreateUrl = () => {


  

  return `/v1/teams`
}

export const teamsCreate = async (v1TeamBody: V1TeamBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getTeamsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1TeamBody,)
  }
);}



/**
 * @summary Retrieves a list of teams summary with provided filter spec
 */
export const getTeamsSummaryGetUrl = () => {


  

  return `/v1/teams/summary`
}

export const teamsSummaryGet = async (teamsSummarySpec: TeamsSummarySpec, options?: RequestInit): Promise<TeamsSummaryList> => {
  
  return customFetch<TeamsSummaryList>(getTeamsSummaryGetUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      teamsSummarySpec,)
  }
);}



/**
 * @summary Deletes the specified team
 */
export const getTeamsUidDeleteUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}`
}

export const teamsUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the sepcified team
 */
export const getTeamsUidGetUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}`
}

export const teamsUidGet = async (uid: string, options?: RequestInit): Promise<Team> => {
  
  return customFetch<Team>(getTeamsUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Patches the specified team
 */
export const getTeamsUidPatchUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}`
}

export const teamsUidPatch = async (uid: string,
    teamPatch: TeamPatch, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsUidPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      teamPatch,)
  }
);}



/**
 * @summary Updates the sepcified team
 */
export const getTeamsUidUpdateUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}`
}

export const teamsUidUpdate = async (uid: string,
    v1TeamBody: V1TeamBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1TeamBody,)
  }
);}



/**
 * @summary Returns the specified team's project and roles data
 */
export const getTeamsProjectRolesUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}/projects`
}

export const teamsProjectRoles = async (uid: string, options?: RequestInit): Promise<ProjectRolesEntity> => {
  
  return customFetch<ProjectRolesEntity>(getTeamsProjectRolesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the projects and roles for the specified team
 */
export const getTeamsProjectRolesPutUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}/projects`
}

export const teamsProjectRolesPut = async (uid: string,
    v1ProjectRolesPatchBody: V1ProjectRolesPatchBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsProjectRolesPutUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ProjectRolesPatchBody,)
  }
);}



/**
 * Returns resource roles for team
 * @summary Returns the specified individual and resource roles for a team
 */
export const getTeamsUidResourceRolesUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}/resourceRoles`
}

export const teamsUidResourceRoles = async (uid: string, options?: RequestInit): Promise<ResourceRoles> => {
  
  return customFetch<ResourceRoles>(getTeamsUidResourceRolesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Resource roles added to specific team
 * @summary Add resource roles for team
 */
export const getTeamsUidResourceRolesCreateUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}/resourceRoles`
}

export const teamsUidResourceRolesCreate = async (uid: string,
    v1ResourceRolesUpdateEntityBody: V1ResourceRolesUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsUidResourceRolesCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ResourceRolesUpdateEntityBody,)
  }
);}



/**
 * @summary Deleted the resource roles from team
 */
export const getTeamsUidResourceRolesUidDeleteUrl = (uid: string,
    resourceRoleUid: string,) => {


  

  return `/v1/teams/${uid}/resourceRoles/${resourceRoleUid}`
}

export const teamsUidResourceRolesUidDelete = async (uid: string,
    resourceRoleUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsUidResourceRolesUidDeleteUrl(uid,resourceRoleUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Specific resource roles fo team is updated
 * @summary Updates the resource roles for team
 */
export const getTeamsResourceRolesUidUpdateUrl = (uid: string,
    resourceRoleUid: string,) => {


  

  return `/v1/teams/${uid}/resourceRoles/${resourceRoleUid}`
}

export const teamsResourceRolesUidUpdate = async (uid: string,
    resourceRoleUid: string,
    v1ResourceRolesUpdateEntityBody: V1ResourceRolesUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsResourceRolesUidUpdateUrl(uid,resourceRoleUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ResourceRolesUpdateEntityBody,)
  }
);}



/**
 * @summary Returns the specified team's tenant roles
 */
export const getV1TeamsUidTenantRolesGetUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}/roles`
}

export const v1TeamsUidTenantRolesGet = async (uid: string, options?: RequestInit): Promise<TeamTenantRolesEntity> => {
  
  return customFetch<TeamTenantRolesEntity>(getV1TeamsUidTenantRolesGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the tenant roles of the specified team
 */
export const getV1TeamsUidTenantRolesUpdateUrl = (uid: string,) => {


  

  return `/v1/teams/${uid}/roles`
}

export const v1TeamsUidTenantRolesUpdate = async (uid: string,
    teamTenantRolesUpdate: TeamTenantRolesUpdate, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TeamsUidTenantRolesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      teamTenantRolesUpdate,)
  }
);}



/**
 * @summary Update tenant address
 */
export const getPatchTenantAddressUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/address`
}

export const patchTenantAddress = async (tenantUid: string,
    tenantAddressPatch: TenantAddressPatch, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getPatchTenantAddressUrl(tenantUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantAddressPatch,)
  }
);}



/**
 * @summary lists the certificates for the tenant
 */
export const getV1TenantUIdAssetsCertsListUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/certs`
}

export const v1TenantUIdAssetsCertsList = async (tenantUid: string, options?: RequestInit): Promise<TenantAssetCerts> => {
  
  return customFetch<TenantAssetCerts>(getV1TenantUIdAssetsCertsListUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary create the tenant certificate
 */
export const getV1TenantUidAssetsCertsCreateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/certs`
}

export const v1TenantUidAssetsCertsCreate = async (tenantUid: string,
    v1TenantAssetCertBody: V1TenantAssetCertBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1TenantUidAssetsCertsCreateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1TenantAssetCertBody,)
  }
);}



/**
 * @summary deletes the tenant certificate
 */
export const getV1TenantUidAssetsCertsUidDeleteUrl = (tenantUid: string,
    certificateUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/certs/${certificateUid}`
}

export const v1TenantUidAssetsCertsUidDelete = async (tenantUid: string,
    certificateUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidAssetsCertsUidDeleteUrl(tenantUid,certificateUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the ca certificate for the tenant
 */
export const getV1TenantUidAssetsCertsUidGetUrl = (tenantUid: string,
    certificateUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/certs/${certificateUid}`
}

export const v1TenantUidAssetsCertsUidGet = async (tenantUid: string,
    certificateUid: string, options?: RequestInit): Promise<TenantAssetCert> => {
  
  return customFetch<TenantAssetCert>(getV1TenantUidAssetsCertsUidGetUrl(tenantUid,certificateUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary updates the tenant certificate
 */
export const getV1TenantUidAssetsCertsUidUpdateUrl = (tenantUid: string,
    certificateUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/certs/${certificateUid}`
}

export const v1TenantUidAssetsCertsUidUpdate = async (tenantUid: string,
    certificateUid: string,
    v1TenantAssetCertBody: V1TenantAssetCertBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidAssetsCertsUidUpdateUrl(tenantUid,certificateUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1TenantAssetCertBody,)
  }
);}



/**
 * @summary deletes the tenant data sink config
 */
export const getV1TenantUidAssetsDataSinksDeleteUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/dataSinks`
}

export const v1TenantUidAssetsDataSinksDelete = async (tenantUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidAssetsDataSinksDeleteUrl(tenantUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns data sink config of tenant
 */
export const getV1TenantUidAssetsDataSinksGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/dataSinks`
}

export const v1TenantUidAssetsDataSinksGet = async (tenantUid: string, options?: RequestInit): Promise<DataSinkConfig> => {
  
  return customFetch<DataSinkConfig>(getV1TenantUidAssetsDataSinksGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary create data sink config
 */
export const getV1TenantUidAssetsDataSinksCreateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/dataSinks`
}

export const v1TenantUidAssetsDataSinksCreate = async (tenantUid: string,
    v1DataSinkConfigBody: V1DataSinkConfigBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getV1TenantUidAssetsDataSinksCreateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1DataSinkConfigBody,)
  }
);}



/**
 * @summary updates the tenant data sink config
 */
export const getV1TenantUidAssetsDataSinksUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/assets/dataSinks`
}

export const v1TenantUidAssetsDataSinksUpdate = async (tenantUid: string,
    v1DataSinkConfigBody: V1DataSinkConfigBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidAssetsDataSinksUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1DataSinkConfigBody,)
  }
);}



/**
 * @summary Get tenant auth token settings
 */
export const getTenantUidAuthTokenSettingsGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/authTokenSettings`
}

export const tenantUidAuthTokenSettingsGet = async (tenantUid: string, options?: RequestInit): Promise<AuthTokenSettings> => {
  
  return customFetch<AuthTokenSettings>(getTenantUidAuthTokenSettingsGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant auth token settings
 */
export const getTenantUidAuthTokenSettingsUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/authTokenSettings`
}

export const tenantUidAuthTokenSettingsUpdate = async (tenantUid: string,
    authTokenSettings: AuthTokenSettings, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantUidAuthTokenSettingsUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authTokenSettings,)
  }
);}



/**
 * @summary Tenant to accept the contract agreement
 */
export const getTenantsUidContractAcceptUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/contract/accept`
}

export const tenantsUidContractAccept = async (tenantUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantsUidContractAcceptUrl(tenantUid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Deletes the aws credit account for tenants
 */
export const getTenantsCreditAccountDeleteUrl = (tenantUid: string,
    params?: TenantsCreditAccountDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/tenants/${tenantUid}/creditAccount/aws?${stringifiedParams}` : `/v1/tenants/${tenantUid}/creditAccount/aws`
}

export const tenantsCreditAccountDelete = async (tenantUid: string,
    params?: TenantsCreditAccountDeleteParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantsCreditAccountDeleteUrl(tenantUid,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Get the credit accounts for the tenants with free tier access
 */
export const getTenantsCreditAccountGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/creditAccount/aws`
}

export const tenantsCreditAccountGet = async (tenantUid: string, options?: RequestInit): Promise<AwsCreditAccountEntity> => {
  
  return customFetch<AwsCreditAccountEntity>(getTenantsCreditAccountGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary retrieves the domains for tenant
 */
export const getV1TenantUidDomainsGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/domains`
}

export const v1TenantUidDomainsGet = async (tenantUid: string, options?: RequestInit): Promise<TenantDomains> => {
  
  return customFetch<TenantDomains>(getV1TenantUidDomainsGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary creates or updates domains for tenant
 */
export const getV1TenantUidDomainsUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/domains`
}

export const v1TenantUidDomainsUpdate = async (tenantUid: string,
    tenantDomains: TenantDomains, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidDomainsUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantDomains,)
  }
);}



/**
 * @summary Update tenant emailId
 */
export const getPatchTenantEmailIdUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/emailId`
}

export const patchTenantEmailId = async (tenantUid: string,
    tenantEmailPatch: TenantEmailPatch, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getPatchTenantEmailIdUrl(tenantUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantEmailPatch,)
  }
);}



/**
 * @summary Get tenant level freemium configuration
 */
export const getTenantFreemiumGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/freemium`
}

export const tenantFreemiumGet = async (tenantUid: string, options?: RequestInit): Promise<TenantFreemium> => {
  
  return customFetch<TenantFreemium>(getTenantFreemiumGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant freemium configuration
 */
export const getTenantFreemiumUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/freemium`
}

export const tenantFreemiumUpdate = async (tenantUid: string,
    tenantFreemium: TenantFreemium, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantFreemiumUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantFreemium,)
  }
);}



/**
 * @summary Get tenant freemium usage
 */
export const getTenantFreemiumUsageGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/freemiumUsage`
}

export const tenantFreemiumUsageGet = async (tenantUid: string, options?: RequestInit): Promise<TenantFreemiumUsage> => {
  
  return customFetch<TenantFreemiumUsage>(getTenantFreemiumUsageGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns a specified invoice
 */
export const getInvoicesUidGetUrl = (tenantUid: string,
    invoiceUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/invoices/${invoiceUid}`
}

export const invoicesUidGet = async (tenantUid: string,
    invoiceUid: string, options?: RequestInit): Promise<Invoice> => {
  
  return customFetch<Invoice>(getInvoicesUidGetUrl(tenantUid,invoiceUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Downloads the specified invoice report
 */
export const getV1InvoiceUidReportInvoicePdfUrl = (tenantUid: string,
    invoiceUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/invoices/${invoiceUid}/report/invoice/pdf`
}

export const v1InvoiceUidReportInvoicePdf = async (tenantUid: string,
    invoiceUid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getV1InvoiceUidReportInvoicePdfUrl(tenantUid,invoiceUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Downloads the specified monthly invoice report
 */
export const getV1InvoiceUidReportPdfUrl = (tenantUid: string,
    invoiceUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/invoices/${invoiceUid}/report/pdf`
}

export const v1InvoiceUidReportPdf = async (tenantUid: string,
    invoiceUid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getV1InvoiceUidReportPdfUrl(tenantUid,invoiceUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Downloads the specified tenant usage
 */
export const getV1InvoiceUidReportUsagePdfUrl = (tenantUid: string,
    invoiceUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/invoices/${invoiceUid}/report/usage/pdf`
}

export const v1InvoiceUidReportUsagePdf = async (tenantUid: string,
    invoiceUid: string, options?: RequestInit): Promise<Blob> => {
  
  return customFetch<Blob>(getV1InvoiceUidReportUsagePdfUrl(tenantUid,invoiceUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Get tenant login banner settings
 */
export const getTenantUidLoginBannerGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/loginBanner`
}

export const tenantUidLoginBannerGet = async (tenantUid: string, options?: RequestInit): Promise<LoginBannerSettings> => {
  
  return customFetch<LoginBannerSettings>(getTenantUidLoginBannerGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant login banner settings
 */
export const getTenantUidLoginBannerUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/loginBanner`
}

export const tenantUidLoginBannerUpdate = async (tenantUid: string,
    loginBannerSettings: LoginBannerSettings, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantUidLoginBannerUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginBannerSettings,)
  }
);}



/**
 * @summary Delete the macros for the specified tenant by given macro name
 */
export const getTenantsUidMacrosDeleteByMacroNameUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/macros`
}

export const tenantsUidMacrosDeleteByMacroName = async (tenantUid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantsUidMacrosDeleteByMacroNameUrl(tenantUid),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary List the macros of the specified tenant
 */
export const getTenantsUidMacrosListUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/macros`
}

export const tenantsUidMacrosList = async (tenantUid: string, options?: RequestInit): Promise<Macros> => {
  
  return customFetch<Macros>(getTenantsUidMacrosListUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the macros for the specified tenant by given macro name
 */
export const getTenantsUidMacrosUpdateByMacroNameUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/macros`
}

export const tenantsUidMacrosUpdateByMacroName = async (tenantUid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantsUidMacrosUpdateByMacroNameUrl(tenantUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Create or add new macros for the specified tenant
 */
export const getTenantsUidMacrosCreateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/macros`
}

export const tenantsUidMacrosCreate = async (tenantUid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantsUidMacrosCreateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Update the macros of the specified tenant
 */
export const getTenantsUidMacrosUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/macros`
}

export const tenantsUidMacrosUpdate = async (tenantUid: string,
    v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantsUidMacrosUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Returns the oidc Spec for tenant
 */
export const getV1TenantUidOidcConfigGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/oidc/config`
}

export const v1TenantUidOidcConfigGet = async (tenantUid: string, options?: RequestInit): Promise<TenantOidcClientSpec> => {
  
  return customFetch<TenantOidcClientSpec>(getV1TenantUidOidcConfigGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Associates the  oidc Spec for the tenant
 */
export const getV1TenantUidOidcConfigUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/oidc/config`
}

export const v1TenantUidOidcConfigUpdate = async (tenantUid: string,
    tenantOidcClientSpec: TenantOidcClientSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidOidcConfigUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantOidcClientSpec,)
  }
);}



/**
 * @summary retrieves the password policy for tenant
 */
export const getV1TenantUidPasswordPolicyGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/password/policy`
}

export const v1TenantUidPasswordPolicyGet = async (tenantUid: string, options?: RequestInit): Promise<TenantPasswordPolicyEntity> => {
  
  return customFetch<TenantPasswordPolicyEntity>(getV1TenantUidPasswordPolicyGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary creates or updates a password policy for tenant
 */
export const getV1TenantUidPasswordPolicyUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/password/policy`
}

export const v1TenantUidPasswordPolicyUpdate = async (tenantUid: string,
    tenantPasswordPolicyEntity: TenantPasswordPolicyEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidPasswordPolicyUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantPasswordPolicyEntity,)
  }
);}



/**
 * @summary Get is cluster group enabled for a specific tenant
 */
export const getV1TenantPrefClusterGroupGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/clusterGroup`
}

export const v1TenantPrefClusterGroupGet = async (tenantUid: string, options?: RequestInit): Promise<TenantEnableClusterGroup> => {
  
  return customFetch<TenantEnableClusterGroup>(getV1TenantPrefClusterGroupGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Enable or Disable cluster group for a specific tenant
 */
export const getV1TenantPrefClusterGroupUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/clusterGroup`
}

export const v1TenantPrefClusterGroupUpdate = async (tenantUid: string,
    tenantEnableClusterGroup: TenantEnableClusterGroup, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantPrefClusterGroupUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantEnableClusterGroup,)
  }
);}



/**
 * @summary Get tenant cluster RBAC settings
 */
export const getTenantClusterRbacSettingsGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/clusterRbacSettings`
}

export const tenantClusterRbacSettingsGet = async (tenantUid: string, options?: RequestInit): Promise<TenantClusterRbacSettings> => {
  
  return customFetch<TenantClusterRbacSettings>(getTenantClusterRbacSettingsGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant cluster RBAC settings
 */
export const getTenantClusterRbacSettingsUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/clusterRbacSettings`
}

export const tenantClusterRbacSettingsUpdate = async (tenantUid: string,
    tenantClusterRbacSettings: TenantClusterRbacSettings, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantClusterRbacSettingsUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantClusterRbacSettings,)
  }
);}



/**
 * @summary Get tenant cluster settings
 */
export const getTenantClusterSettingsGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/clusterSettings`
}

export const tenantClusterSettingsGet = async (tenantUid: string, options?: RequestInit): Promise<TenantClusterSettings> => {
  
  return customFetch<TenantClusterSettings>(getTenantClusterSettingsGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant clusters nodes auto remediation setting
 */
export const getTenantClustersNodesAutoRemediationSettingUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/clusterSettings/nodesAutoRemediationSetting`
}

export const tenantClustersNodesAutoRemediationSettingUpdate = async (tenantUid: string,
    v1NodesAutoRemediationSettingsBody: V1NodesAutoRemediationSettingsBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantClustersNodesAutoRemediationSettingUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1NodesAutoRemediationSettingsBody,)
  }
);}



/**
 * @summary Get developer credit enabled for a specific tenant
 */
export const getV1TenantDeveloperCreditGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/developerCredit`
}

export const v1TenantDeveloperCreditGet = async (tenantUid: string, options?: RequestInit): Promise<DeveloperCredit> => {
  
  return customFetch<DeveloperCredit>(getV1TenantDeveloperCreditGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary update developer credit for a specific tenant
 */
export const getV1TenantDeveloperCreditUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/developerCredit`
}

export const v1TenantDeveloperCreditUpdate = async (tenantUid: string,
    developerCredit: DeveloperCredit, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantDeveloperCreditUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      developerCredit,)
  }
);}



/**
 * @summary Get tenant fips settings
 */
export const getTenantFipsSettingsGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/fips`
}

export const tenantFipsSettingsGet = async (tenantUid: string, options?: RequestInit): Promise<FipsSettings> => {
  
  return customFetch<FipsSettings>(getTenantFipsSettingsGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant fips setting
 */
export const getTenantFipsSettingsUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/preferences/fips`
}

export const tenantFipsSettingsUpdate = async (tenantUid: string,
    fipsSettings: FipsSettings, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantFipsSettingsUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      fipsSettings,)
  }
);}



/**
 * @summary Get all rate config for public and private cloud
 */
export const getRateConfigGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/rateConfig`
}

export const rateConfigGet = async (tenantUid: string, options?: RequestInit): Promise<RateConfig> => {
  
  return customFetch<RateConfig>(getRateConfigGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary updates the rate config for public and private cloud
 */
export const getRateConfigUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/rateConfig`
}

export const rateConfigUpdate = async (tenantUid: string,
    rateConfig: RateConfig, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getRateConfigUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rateConfig,)
  }
);}



/**
 * @summary Get tenant level resource limits configuration
 */
export const getTenantResourceLimitsGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/resourceLimits`
}

export const tenantResourceLimitsGet = async (tenantUid: string, options?: RequestInit): Promise<TenantResourceLimits> => {
  
  return customFetch<TenantResourceLimits>(getTenantResourceLimitsGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update tenant resource limits configuration
 */
export const getTenantResourceLimitsUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/resourceLimits`
}

export const tenantResourceLimitsUpdate = async (tenantUid: string,
    tenantResourceLimitsEntity: TenantResourceLimitsEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTenantResourceLimitsUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantResourceLimitsEntity,)
  }
);}



/**
 * @summary Returns the specified service provider metadata and Saml Spec for tenant
 */
export const getV1TenantUidSamlConfigSpecGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/saml/config`
}

export const v1TenantUidSamlConfigSpecGet = async (tenantUid: string, options?: RequestInit): Promise<TenantSamlSpec> => {
  
  return customFetch<TenantSamlSpec>(getV1TenantUidSamlConfigSpecGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Associates the specified federation metadata for the tenant
 */
export const getV1TenantUidSamlConfigUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/saml/config`
}

export const v1TenantUidSamlConfigUpdate = async (tenantUid: string,
    tenantSamlRequestSpec: TenantSamlRequestSpec, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidSamlConfigUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantSamlRequestSpec,)
  }
);}



/**
 * @summary get sso logins for the tenants
 */
export const getV1TenantUidSsoAuthProvidersGetUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/sso/auth/providers`
}

export const v1TenantUidSsoAuthProvidersGet = async (tenantUid: string, options?: RequestInit): Promise<TenantSsoAuthProvidersEntity> => {
  
  return customFetch<TenantSsoAuthProvidersEntity>(getV1TenantUidSsoAuthProvidersGetUrl(tenantUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary enable sso logins for the tenants
 */
export const getV1TenantUidSsoAuthProvidersUpdateUrl = (tenantUid: string,) => {


  

  return `/v1/tenants/${tenantUid}/sso/auth/providers`
}

export const v1TenantUidSsoAuthProvidersUpdate = async (tenantUid: string,
    tenantSsoAuthProvidersEntity: TenantSsoAuthProvidersEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1TenantUidSsoAuthProvidersUpdateUrl(tenantUid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tenantSsoAuthProvidersEntity,)
  }
);}



/**
 * Lists users the given user context
 * @summary Lists users
 */
export const getUsersListUrl = (params?: UsersListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/users?${stringifiedParams}` : `/v1/users`
}

export const usersList = async (params?: UsersListParams, options?: RequestInit): Promise<Users> => {
  
  return customFetch<Users>(getUsersListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * A user is created for the given user context
 * @summary Create User
 */
export const getUsersCreateUrl = () => {


  

  return `/v1/users`
}

export const usersCreate = async (userEntity: UserEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getUsersCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userEntity,)
  }
);}



/**
 * @summary Returns the specified users location
 */
export const getUsersAssetsLocationGetUrl = (params?: UsersAssetsLocationGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/users/assets/locations?${stringifiedParams}` : `/v1/users/assets/locations`
}

export const usersAssetsLocationGet = async (params?: UsersAssetsLocationGetParams, options?: RequestInit): Promise<UserAssetsLocations> => {
  
  return customFetch<UserAssetsLocations>(getUsersAssetsLocationGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create a Azure location
 */
export const getUsersAssetsLocationAzureCreateUrl = () => {


  

  return `/v1/users/assets/locations/azure`
}

export const usersAssetsLocationAzureCreate = async (v1UserAssetsLocationAzureBody: V1UserAssetsLocationAzureBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getUsersAssetsLocationAzureCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationAzureBody,)
  }
);}



/**
 * @summary Returns the specified Azure location
 */
export const getUsersAssetsLocationAzureGetUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/azure/${uid}`
}

export const usersAssetsLocationAzureGet = async (uid: string, options?: RequestInit): Promise<UserAssetsLocationAzure> => {
  
  return customFetch<UserAssetsLocationAzure>(getUsersAssetsLocationAzureGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified Azure location
 */
export const getUsersAssetsLocationAzureUpdateUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/azure/${uid}`
}

export const usersAssetsLocationAzureUpdate = async (uid: string,
    v1UserAssetsLocationAzureBody: V1UserAssetsLocationAzureBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationAzureUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationAzureBody,)
  }
);}



/**
 * @summary Create a GCP location
 */
export const getUsersAssetsLocationGcpCreateUrl = () => {


  

  return `/v1/users/assets/locations/gcp`
}

export const usersAssetsLocationGcpCreate = async (v1UserAssetsLocationGcpBody: V1UserAssetsLocationGcpBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getUsersAssetsLocationGcpCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationGcpBody,)
  }
);}



/**
 * @summary Returns the specified GCP location
 */
export const getUsersAssetsLocationGcpGetUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/gcp/${uid}`
}

export const usersAssetsLocationGcpGet = async (uid: string, options?: RequestInit): Promise<UserAssetsLocationGcp> => {
  
  return customFetch<UserAssetsLocationGcp>(getUsersAssetsLocationGcpGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified GCP location
 */
export const getUsersAssetsLocationGcpUpdateUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/gcp/${uid}`
}

export const usersAssetsLocationGcpUpdate = async (uid: string,
    v1UserAssetsLocationGcpBody: V1UserAssetsLocationGcpBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationGcpUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationGcpBody,)
  }
);}



/**
 * @summary Create a MinIO location
 */
export const getUsersAssetsLocationMinioCreateUrl = () => {


  

  return `/v1/users/assets/locations/minio`
}

export const usersAssetsLocationMinioCreate = async (v1UserAssetsLocationS3Body: V1UserAssetsLocationS3Body, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getUsersAssetsLocationMinioCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationS3Body,)
  }
);}



/**
 * @summary Returns the specified MinIO location
 */
export const getUsersAssetsLocationMinioGetUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/minio/${uid}`
}

export const usersAssetsLocationMinioGet = async (uid: string, options?: RequestInit): Promise<UserAssetsLocationS3> => {
  
  return customFetch<UserAssetsLocationS3>(getUsersAssetsLocationMinioGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified MinIO location
 */
export const getUsersAssetsLocationMinioUpdateUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/minio/${uid}`
}

export const usersAssetsLocationMinioUpdate = async (uid: string,
    v1UserAssetsLocationS3Body: V1UserAssetsLocationS3Body, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationMinioUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationS3Body,)
  }
);}



/**
 * @summary Create a S3 location
 */
export const getUsersAssetsLocationS3CreateUrl = () => {


  

  return `/v1/users/assets/locations/s3`
}

export const usersAssetsLocationS3Create = async (v1UserAssetsLocationS3Body: V1UserAssetsLocationS3Body, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getUsersAssetsLocationS3CreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationS3Body,)
  }
);}



/**
 * @summary Returns the specified S3 location
 */
export const getUsersAssetsLocationS3DeleteUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/s3/${uid}`
}

export const usersAssetsLocationS3Delete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationS3DeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified S3 location
 */
export const getUsersAssetsLocationS3GetUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/s3/${uid}`
}

export const usersAssetsLocationS3Get = async (uid: string, options?: RequestInit): Promise<UserAssetsLocationS3> => {
  
  return customFetch<UserAssetsLocationS3>(getUsersAssetsLocationS3GetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified S3 location
 */
export const getUsersAssetsLocationS3UpdateUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/s3/${uid}`
}

export const usersAssetsLocationS3Update = async (uid: string,
    v1UserAssetsLocationS3Body: V1UserAssetsLocationS3Body, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationS3UpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UserAssetsLocationS3Body,)
  }
);}



/**
 * @summary Update the default backup location
 */
export const getUsersAssetsLocationDefaultUpdateUrl = (type: string,
    uid: string,) => {


  

  return `/v1/users/assets/locations/${type}/${uid}/default`
}

export const usersAssetsLocationDefaultUpdate = async (type: string,
    uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationDefaultUpdateUrl(type,uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * @summary Deletes the specified location
 */
export const getUsersAssetsLocationDeleteUrl = (uid: string,) => {


  

  return `/v1/users/assets/locations/${uid}`
}

export const usersAssetsLocationDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetsLocationDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the SSH keys
 */
export const getUsersAssetsSshGetUrl = (params?: UsersAssetsSshGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/users/assets/sshkeys?${stringifiedParams}` : `/v1/users/assets/sshkeys`
}

export const usersAssetsSshGet = async (params?: UsersAssetsSshGetParams, options?: RequestInit): Promise<UserAssetsSsh> => {
  
  return customFetch<UserAssetsSsh>(getUsersAssetsSshGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Creates a SSH key
 */
export const getUserAssetsSshCreateUrl = () => {


  

  return `/v1/users/assets/sshkeys`
}

export const userAssetsSshCreate = async (userAssetSshEntity: UserAssetSshEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getUserAssetsSshCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userAssetSshEntity,)
  }
);}



/**
 * @summary Returns the specified user ssh key
 */
export const getUsersAssetSshDeleteUrl = (uid: string,) => {


  

  return `/v1/users/assets/sshkeys/${uid}`
}

export const usersAssetSshDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetSshDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified user ssh key
 */
export const getUsersAssetSshGetUidUrl = (uid: string,) => {


  

  return `/v1/users/assets/sshkeys/${uid}`
}

export const usersAssetSshGetUid = async (uid: string, options?: RequestInit): Promise<UserAssetSsh> => {
  
  return customFetch<UserAssetSsh>(getUsersAssetSshGetUidUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified user ssh key
 */
export const getUsersAssetSshUpdateUrl = (uid: string,) => {


  

  return `/v1/users/assets/sshkeys/${uid}`
}

export const usersAssetSshUpdate = async (uid: string,
    userAssetSsh: UserAssetSsh, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAssetSshUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userAssetSsh,)
  }
);}



/**
 * @summary Returns the specified vSphere DNS mapping
 */
export const getVsphereMappingGetUrl = (params: VsphereMappingGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/users/assets/vsphere/dnsMapping?${stringifiedParams}` : `/v1/users/assets/vsphere/dnsMapping`
}

export const vsphereMappingGet = async (params: VsphereMappingGetParams, options?: RequestInit): Promise<VsphereDnsMapping> => {
  
  return customFetch<VsphereDnsMapping>(getVsphereMappingGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Returns the specified vSphere DNS mappings
 */
export const getVsphereDnsMappingsGetUrl = (params?: VsphereDnsMappingsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/users/assets/vsphere/dnsMappings?${stringifiedParams}` : `/v1/users/assets/vsphere/dnsMappings`
}

export const vsphereDnsMappingsGet = async (params?: VsphereDnsMappingsGetParams, options?: RequestInit): Promise<VsphereDnsMappings> => {
  
  return customFetch<VsphereDnsMappings>(getVsphereDnsMappingsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create a vSphere DNS mapping
 */
export const getVsphereDnsMappingCreateUrl = () => {


  

  return `/v1/users/assets/vsphere/dnsMappings`
}

export const vsphereDnsMappingCreate = async (v1VsphereDnsMappingBody: V1VsphereDnsMappingBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getVsphereDnsMappingCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereDnsMappingBody,)
  }
);}



/**
 * @summary Deletes the specified vSphere DNS mapping
 */
export const getVsphereDnsMappingDeleteUrl = (uid: string,) => {


  

  return `/v1/users/assets/vsphere/dnsMappings/${uid}`
}

export const vsphereDnsMappingDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getVsphereDnsMappingDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified vSphere DNS mapping
 */
export const getVsphereDnsMappingGetUrl = (uid: string,) => {


  

  return `/v1/users/assets/vsphere/dnsMappings/${uid}`
}

export const vsphereDnsMappingGet = async (uid: string, options?: RequestInit): Promise<VsphereDnsMapping> => {
  
  return customFetch<VsphereDnsMapping>(getVsphereDnsMappingGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the specified vSphere DNS mapping
 */
export const getVsphereDnsMappingUpdateUrl = (uid: string,) => {


  

  return `/v1/users/assets/vsphere/dnsMappings/${uid}`
}

export const vsphereDnsMappingUpdate = async (uid: string,
    v1VsphereDnsMappingBody: V1VsphereDnsMappingBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getVsphereDnsMappingUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1VsphereDnsMappingBody,)
  }
);}



/**
 * @summary Revoke access of specific token(s)
 */
export const getUsersAuthTokensRevokeUrl = () => {


  

  return `/v1/users/auth/tokens/revoke`
}

export const usersAuthTokensRevoke = async (authTokenRevoke: AuthTokenRevoke, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersAuthTokensRevokeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authTokenRevoke,)
  }
);}



/**
 * @summary Get the system Spectro repository. Restricted to edge services
 */
export const getV1UsersConfigScarGetUrl = () => {


  

  return `/v1/users/config/scar`
}

export const v1UsersConfigScarGet = async ( options?: RequestInit): Promise<SystemScarSpec> => {
  
  return customFetch<SystemScarSpec>(getV1UsersConfigScarGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns a basic information of User for the specified uid.
 * @summary Returns the base information of specified User
 */
export const getUsersInfoGetUrl = () => {


  

  return `/v1/users/info`
}

export const usersInfoGet = async ( options?: RequestInit): Promise<UserInfo> => {
  
  return customFetch<UserInfo>(getUsersInfoGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * gets users kubectl session
 * @summary gets users kubectl session
 */
export const getV1UsersKubectlSessionUidUrl = (sessionUid: string,) => {


  

  return `/v1/users/kubectl/session/${sessionUid}`
}

export const v1UsersKubectlSessionUid = async (sessionUid: string, options?: RequestInit): Promise<UserKubectlSession> => {
  
  return customFetch<UserKubectlSession>(getV1UsersKubectlSessionUidUrl(sessionUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Retrieves a list of users metadata
 */
export const getUsersMetadataUrl = () => {


  

  return `/v1/users/meta`
}

export const usersMetadata = async ( options?: RequestInit): Promise<UsersMetadata> => {
  
  return customFetch<UsersMetadata>(getUsersMetadataUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * User password change request via current password and emailId
 * @summary User password change request using the user emailId
 */
export const getV1UsersPasswordChangeUrl = () => {


  

  return `/v1/users/password/change`
}

export const v1UsersPasswordChange = async (v1UsersPasswordChangeBody: V1UsersPasswordChangeBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getV1UsersPasswordChangeUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1UsersPasswordChangeBody,)
  }
);}



/**
 * User password request will be sent to the supplied emailId
 * @summary User password reset request using the email id
 */
export const getUsersEmailPasswordResetUrl = () => {


  

  return `/v1/users/password/reset`
}

export const usersEmailPasswordReset = async (usersEmailPasswordResetBody: UsersEmailPasswordResetBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersEmailPasswordResetUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      usersEmailPasswordResetBody,)
  }
);}



/**
 * @summary Retrieves a list of users summary with provided filter spec
 */
export const getUsersSummaryGetUrl = () => {


  

  return `/v1/users/summary`
}

export const usersSummaryGet = async (usersSummarySpec: UsersSummarySpec, options?: RequestInit): Promise<UsersSummaryList> => {
  
  return customFetch<UsersSummaryList>(getUsersSummaryGetUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      usersSummarySpec,)
  }
);}



/**
 * Returns the users system feature
 * @summary Returns the users system feature
 */
export const getUsersSystemFeatureUrl = () => {


  

  return `/v1/users/system/features`
}

export const usersSystemFeature = async ( options?: RequestInit): Promise<SystemFeatures> => {
  
  return customFetch<SystemFeatures>(getUsersSystemFeatureUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Delete the macros for the system user by macro name
 */
export const getUsersSystemMacrosDeleteByMacroNameUrl = () => {


  

  return `/v1/users/system/macros`
}

export const usersSystemMacrosDeleteByMacroName = async (v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersSystemMacrosDeleteByMacroNameUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary List the macros of the system
 */
export const getUsersSystemMacrosListUrl = () => {


  

  return `/v1/users/system/macros`
}

export const usersSystemMacrosList = async ( options?: RequestInit): Promise<Macros> => {
  
  return customFetch<Macros>(getUsersSystemMacrosListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Update the macros for the system user by macro name
 */
export const getUsersSystemMacrosUpdateByMacroNameUrl = () => {


  

  return `/v1/users/system/macros`
}

export const usersSystemMacrosUpdateByMacroName = async (v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersSystemMacrosUpdateByMacroNameUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Create or add new macros for the system user
 */
export const getUsersSystemMacrosCreateUrl = () => {


  

  return `/v1/users/system/macros`
}

export const usersSystemMacrosCreate = async (v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersSystemMacrosCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * @summary Update the macros of the system
 */
export const getUsersSystemMacrosUpdateUrl = () => {


  

  return `/v1/users/system/macros`
}

export const usersSystemMacrosUpdate = async (v1MacrosBody: V1MacrosBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersSystemMacrosUpdateUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1MacrosBody,)
  }
);}



/**
 * Deletes the specified User for given uid
 * @summary Deletes the specified User
 */
export const getUsersUidDeleteUrl = (uid: string,) => {


  

  return `/v1/users/${uid}`
}

export const usersUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Returns a User for the specified uid.
 * @summary Returns the specified User
 */
export const getUsersUidGetUrl = (uid: string,) => {


  

  return `/v1/users/${uid}`
}

export const usersUidGet = async (uid: string, options?: RequestInit): Promise<User> => {
  
  return customFetch<User>(getUsersUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * User is patched for the specified information
 * @summary Patches the specified User
 */
export const getUsersUidPatchUrl = (uid: string,) => {


  

  return `/v1/users/${uid}`
}

export const usersUidPatch = async (uid: string,
    userPatch: UserPatch, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidPatchUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userPatch,)
  }
);}



/**
 * A user is created for the given user context
 * @summary Update User
 */
export const getUsersUidUpdateUrl = (uid: string,) => {


  

  return `/v1/users/${uid}`
}

export const usersUidUpdate = async (uid: string,
    userUpdateEntity: UserUpdateEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userUpdateEntity,)
  }
);}



/**
 * User password change request via current password
 * @summary User password change request using the user uid
 */
export const getUsersUidPasswordChangeUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/password/change`
}

export const usersUidPasswordChange = async (uid: string,
    usersUidPasswordChangeBody: UsersUidPasswordChangeBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidPasswordChangeUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      usersUidPasswordChangeBody,)
  }
);}



/**
 * User password reset request, will send the password reset option through the emailId
 * @summary User password reset request using the user uid
 */
export const getUsersUidPasswordResetUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/password/reset`
}

export const usersUidPasswordReset = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidPasswordResetUrl(uid),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * Returns a User with projects and roles
 * @summary Returns the specified User Projects and Roles information
 */
export const getUsersProjectRolesUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/projects`
}

export const usersProjectRoles = async (uid: string, options?: RequestInit): Promise<ProjectRolesEntity> => {
  
  return customFetch<ProjectRolesEntity>(getUsersProjectRolesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * User is updated with projects and roles
 * @summary Updates the projects and roles for user
 */
export const getUsersProjectRolesPutUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/projects`
}

export const usersProjectRolesPut = async (uid: string,
    v1ProjectRolesPatchBody: V1ProjectRolesPatchBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersProjectRolesPutUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ProjectRolesPatchBody,)
  }
);}



/**
 * Returns resource roles for user
 * @summary Returns the specified individual and resource roles for a user
 */
export const getUsersUidResourceRolesUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/resourceRoles`
}

export const usersUidResourceRoles = async (uid: string, options?: RequestInit): Promise<ResourceRoles> => {
  
  return customFetch<ResourceRoles>(getUsersUidResourceRolesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Resource roles added to specific user
 * @summary Add resource roles for user
 */
export const getUsersUidResourceRolesCreateUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/resourceRoles`
}

export const usersUidResourceRolesCreate = async (uid: string,
    v1ResourceRolesUpdateEntityBody: V1ResourceRolesUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidResourceRolesCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ResourceRolesUpdateEntityBody,)
  }
);}



/**
 * @summary Deleted the resource roles from user
 */
export const getUsersUidResourceRolesUidDeleteUrl = (uid: string,
    resourceRoleUid: string,) => {


  

  return `/v1/users/${uid}/resourceRoles/${resourceRoleUid}`
}

export const usersUidResourceRolesUidDelete = async (uid: string,
    resourceRoleUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidResourceRolesUidDeleteUrl(uid,resourceRoleUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Specific resource roles fo user is updated
 * @summary Updates the resource roles for user
 */
export const getUsersResourceRolesUidUpdateUrl = (uid: string,
    resourceRoleUid: string,) => {


  

  return `/v1/users/${uid}/resourceRoles/${resourceRoleUid}`
}

export const usersResourceRolesUidUpdate = async (uid: string,
    resourceRoleUid: string,
    v1ResourceRolesUpdateEntityBody: V1ResourceRolesUpdateEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersResourceRolesUidUpdateUrl(uid,resourceRoleUid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ResourceRolesUpdateEntityBody,)
  }
);}



/**
 * Returns roles clubbed from team
 * @summary Returns the specified individual and team roles for a user
 */
export const getUsersUidRolesUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/roles`
}

export const usersUidRoles = async (uid: string, options?: RequestInit): Promise<UserRolesEntity> => {
  
  return customFetch<UserRolesEntity>(getUsersUidRolesUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * User is updated with roles
 * @summary Updates the roles for user
 */
export const getUsersUidRolesUpdateUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/roles`
}

export const usersUidRolesUpdate = async (uid: string,
    userRoleUIDs: UserRoleUIDs, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersUidRolesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userRoleUIDs,)
  }
);}



/**
 * @summary Users status login mode
 */
export const getUsersStatusLoginModeUrl = (uid: string,) => {


  

  return `/v1/users/${uid}/status/loginMode`
}

export const usersStatusLoginMode = async (uid: string,
    userStatusLoginMode: UserStatusLoginMode, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersStatusLoginModeUrl(uid),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userStatusLoginMode,)
  }
);}



/**
 * @summary Create workspace
 */
export const getWorkspacesCreateUrl = () => {


  

  return `/v1/workspaces`
}

export const workspacesCreate = async (workspaceEntity: WorkspaceEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getWorkspacesCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      workspaceEntity,)
  }
);}



/**
 * @summary Returns the specified team's workspaces and roles data
 */
export const getTeamsWorkspaceGetRolesUrl = (teamUid: string,) => {


  

  return `/v1/workspaces/teams/${teamUid}/roles`
}

export const teamsWorkspaceGetRoles = async (teamUid: string, options?: RequestInit): Promise<WorkspaceScopeRoles> => {
  
  return customFetch<WorkspaceScopeRoles>(getTeamsWorkspaceGetRolesUrl(teamUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Updates the workspace roles for the specified team
 */
export const getTeamsWorkspaceRolesPutUrl = (teamUid: string,) => {


  

  return `/v1/workspaces/teams/${teamUid}/roles`
}

export const teamsWorkspaceRolesPut = async (teamUid: string,
    v1WorkspacesRolesPatchBody: V1WorkspacesRolesPatchBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getTeamsWorkspaceRolesPutUrl(teamUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspacesRolesPatchBody,)
  }
);}



/**
 * Returns a User with workspaces and roles
 * @summary Returns the specified User workspaces and Roles information
 */
export const getUsersWorkspaceGetRolesUrl = (userUid: string,) => {


  

  return `/v1/workspaces/users/${userUid}/roles`
}

export const usersWorkspaceGetRoles = async (userUid: string, options?: RequestInit): Promise<WorkspaceScopeRoles> => {
  
  return customFetch<WorkspaceScopeRoles>(getUsersWorkspaceGetRolesUrl(userUid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * User is updated with workspace roles
 * @summary Updates the workspace roles for user
 */
export const getUsersWorkspaceRolesPutUrl = (userUid: string,) => {


  

  return `/v1/workspaces/users/${userUid}/roles`
}

export const usersWorkspaceRolesPut = async (userUid: string,
    v1WorkspacesRolesPatchBody: V1WorkspacesRolesPatchBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getUsersWorkspaceRolesPutUrl(userUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspacesRolesPatchBody,)
  }
);}



/**
 * @summary Validates the workspace name
 */
export const getWorkspacesValidateNameUrl = (params: WorkspacesValidateNameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/workspaces/validate/name?${stringifiedParams}` : `/v1/workspaces/validate/name`
}

export const workspacesValidateName = async (params: WorkspacesValidateNameParams, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspacesValidateNameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Deletes the specified workspace
 */
export const getWorkspacesUidDeleteUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}`
}

export const workspacesUidDelete = async (uid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspacesUidDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Returns the specified workspace
 */
export const getWorkspacesUidGetUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}`
}

export const workspacesUidGet = async (uid: string, options?: RequestInit): Promise<Workspace> => {
  
  return customFetch<Workspace>(getWorkspacesUidGetUrl(uid),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Delete workspace backup
 */
export const getWorkspaceOpsBackupDeleteUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/backup`
}

export const workspaceOpsBackupDelete = async (uid: string,
    workspaceBackupDeleteEntity: WorkspaceBackupDeleteEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspaceOpsBackupDeleteUrl(uid),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      workspaceBackupDeleteEntity,)
  }
);}



/**
 * @summary Returns the  workspace backup result
 */
export const getWorkspaceOpsBackupGetUrl = (uid: string,
    params?: WorkspaceOpsBackupGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/workspaces/${uid}/backup?${stringifiedParams}` : `/v1/workspaces/${uid}/backup`
}

export const workspaceOpsBackupGet = async (uid: string,
    params?: WorkspaceOpsBackupGetParams, options?: RequestInit): Promise<WorkspaceBackup> => {
  
  return customFetch<WorkspaceBackup>(getWorkspaceOpsBackupGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create workspace backup settings
 */
export const getWorkspaceOpsBackupCreateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/backup`
}

export const workspaceOpsBackupCreate = async (uid: string,
    v1WorkspaceBackupConfigEntityBody: V1WorkspaceBackupConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getWorkspaceOpsBackupCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceBackupConfigEntityBody,)
  }
);}



/**
 * @summary Update workspace backup settings
 */
export const getWorkspaceOpsBackupUpdateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/backup`
}

export const workspaceOpsBackupUpdate = async (uid: string,
    v1WorkspaceBackupConfigEntityBody: V1WorkspaceBackupConfigEntityBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspaceOpsBackupUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceBackupConfigEntityBody,)
  }
);}



/**
 * @summary Create On demand Workspace Backup
 */
export const getWorkspaceOpsBackupOnDemandCreateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/backup/onDemand`
}

export const workspaceOpsBackupOnDemandCreate = async (uid: string,
    v1WorkspaceBackupConfigEntityBody: V1WorkspaceBackupConfigEntityBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getWorkspaceOpsBackupOnDemandCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1WorkspaceBackupConfigEntityBody,)
  }
);}



/**
 * @summary Updates the specified workspace namespaces
 */
export const getWorkspacesUidClusterNamespacesUpdateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/clusterNamespaces`
}

export const workspacesUidClusterNamespacesUpdate = async (uid: string,
    workspaceClusterNamespacesEntity: WorkspaceClusterNamespacesEntity, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspacesUidClusterNamespacesUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      workspaceClusterNamespacesEntity,)
  }
);}



/**
 * @summary Create cluster rbac in workspace
 */
export const getWorkspacesClusterRbacCreateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/clusterRbacs`
}

export const workspacesClusterRbacCreate = async (uid: string,
    v1ClusterRbacBody: V1ClusterRbacBody, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getWorkspacesClusterRbacCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterRbacBody,)
  }
);}



/**
 * @summary Deletes the specified workspace cluster rbac
 */
export const getWorkspacesUidClusterRbacDeleteUrl = (uid: string,
    clusterRbacUid: string,) => {


  

  return `/v1/workspaces/${uid}/clusterRbacs/${clusterRbacUid}`
}

export const workspacesUidClusterRbacDelete = async (uid: string,
    clusterRbacUid: string, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspacesUidClusterRbacDeleteUrl(uid,clusterRbacUid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * @summary Updates the specified workspace cluster rbac
 */
export const getWorkspacesUidClusterRbacUpdateUrl = (uid: string,
    clusterRbacUid: string,) => {


  

  return `/v1/workspaces/${uid}/clusterRbacs/${clusterRbacUid}`
}

export const workspacesUidClusterRbacUpdate = async (uid: string,
    clusterRbacUid: string,
    v1ClusterRbacBody: V1ClusterRbacBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspacesUidClusterRbacUpdateUrl(uid,clusterRbacUid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ClusterRbacBody,)
  }
);}



/**
 * @summary Updates the specified workspace meta
 */
export const getWorkspacesUidMetaUpdateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/meta`
}

export const workspacesUidMetaUpdate = async (uid: string,
    v1ObjectMetaBody: V1ObjectMetaBody, options?: RequestInit): Promise<void> => {
  
  return customFetch<void>(getWorkspacesUidMetaUpdateUrl(uid),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      v1ObjectMetaBody,)
  }
);}



/**
 * @summary Returns the  workspace restore result
 */
export const getWorkspaceOpsRestoreGetUrl = (uid: string,
    params?: WorkspaceOpsRestoreGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/workspaces/${uid}/restore?${stringifiedParams}` : `/v1/workspaces/${uid}/restore`
}

export const workspaceOpsRestoreGet = async (uid: string,
    params?: WorkspaceOpsRestoreGetParams, options?: RequestInit): Promise<WorkspaceRestore> => {
  
  return customFetch<WorkspaceRestore>(getWorkspaceOpsRestoreGetUrl(uid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * @summary Create On demand Workspace Restore
 */
export const getWorkspaceOpsRestoreOnDemandCreateUrl = (uid: string,) => {


  

  return `/v1/workspaces/${uid}/restore/onDemand`
}

export const workspaceOpsRestoreOnDemandCreate = async (uid: string,
    workspaceRestoreConfigEntity: WorkspaceRestoreConfigEntity, options?: RequestInit): Promise<Uid> => {
  
  return customFetch<Uid>(getWorkspaceOpsRestoreOnDemandCreateUrl(uid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      workspaceRestoreConfigEntity,)
  }
);}
